(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var _ = require('underscore');

/*global navigator: false */
module.exports = function(AV) {
  var PUBLIC_KEY = "*";

  /**
   * Creates a new ACL.
   * If no argument is given, the ACL has no permissions for anyone.
   * If the argument is a AV.User, the ACL will have read and write
   *   permission for only that user.
   * If the argument is any other JSON object, that object will be interpretted
   *   as a serialized ACL created with toJSON().
   * @see AV.Object#setACL
   * @class
   *
   * <p>An ACL, or Access Control List can be added to any
   * <code>AV.Object</code> to restrict access to only a subset of users
   * of your application.</p>
   */
  AV.ACL = function(arg1) {
    var self = this;
    self.permissionsById = {};
    if (_.isObject(arg1)) {
      if (arg1 instanceof AV.User) {
        self.setReadAccess(arg1, true);
        self.setWriteAccess(arg1, true);
      } else {
        if (_.isFunction(arg1)) {
          throw "AV.ACL() called with a function.  Did you forget ()?";
        }
        AV._objectEach(arg1, function(accessList, userId) {
          if (!_.isString(userId)) {
            throw "Tried to create an ACL with an invalid userId.";
          }
          self.permissionsById[userId] = {};
          AV._objectEach(accessList, function(allowed, permission) {
            if (permission !== "read" && permission !== "write") {
              throw "Tried to create an ACL with an invalid permission type.";
            }
            if (!_.isBoolean(allowed)) {
              throw "Tried to create an ACL with an invalid permission value.";
            }
            self.permissionsById[userId][permission] = allowed;
          });
        });
      }
    }
  };

  /**
   * Returns a JSON-encoded version of the ACL.
   * @return {Object}
   */
  AV.ACL.prototype.toJSON = function() {
    return _.clone(this.permissionsById);
  };

  AV.ACL.prototype._setAccess = function(accessType, userId, allowed) {
    if (userId instanceof AV.User) {
      userId = userId.id;
    } else if (userId instanceof AV.Role) {
      userId = "role:" + userId.getName();
    }
    if (!_.isString(userId)) {
      throw "userId must be a string.";
    }
    if (!_.isBoolean(allowed)) {
      throw "allowed must be either true or false.";
    }
    var permissions = this.permissionsById[userId];
    if (!permissions) {
      if (!allowed) {
        // The user already doesn't have this permission, so no action needed.
        return;
      } else {
        permissions = {};
        this.permissionsById[userId] = permissions;
      }
    }

    if (allowed) {
      this.permissionsById[userId][accessType] = true;
    } else {
      delete permissions[accessType];
      if (_.isEmpty(permissions)) {
        delete permissions[userId];
      }
    }
  };

  AV.ACL.prototype._getAccess = function(accessType, userId) {
    if (userId instanceof AV.User) {
      userId = userId.id;
    } else if (userId instanceof AV.Role) {
      userId = "role:" + userId.getName();
    }
    var permissions = this.permissionsById[userId];
    if (!permissions) {
      return false;
    }
    return permissions[accessType] ? true : false;
  };

  /**
   * Set whether the given user is allowed to read this object.
   * @param userId An instance of AV.User or its objectId.
   * @param {Boolean} allowed Whether that user should have read access.
   */
  AV.ACL.prototype.setReadAccess = function(userId, allowed) {
    this._setAccess("read", userId, allowed);
  };

  /**
   * Get whether the given user id is *explicitly* allowed to read this object.
   * Even if this returns false, the user may still be able to access it if
   * getPublicReadAccess returns true or a role that the user belongs to has
   * write access.
   * @param userId An instance of AV.User or its objectId, or a AV.Role.
   * @return {Boolean}
   */
  AV.ACL.prototype.getReadAccess = function(userId) {
    return this._getAccess("read", userId);
  };

  /**
   * Set whether the given user id is allowed to write this object.
   * @param userId An instance of AV.User or its objectId, or a AV.Role..
   * @param {Boolean} allowed Whether that user should have write access.
   */
  AV.ACL.prototype.setWriteAccess = function(userId, allowed) {
    this._setAccess("write", userId, allowed);
  };

  /**
   * Get whether the given user id is *explicitly* allowed to write this object.
   * Even if this returns false, the user may still be able to write it if
   * getPublicWriteAccess returns true or a role that the user belongs to has
   * write access.
   * @param userId An instance of AV.User or its objectId, or a AV.Role.
   * @return {Boolean}
   */
  AV.ACL.prototype.getWriteAccess = function(userId) {
    return this._getAccess("write", userId);
  };

  /**
   * Set whether the public is allowed to read this object.
   * @param {Boolean} allowed
   */
  AV.ACL.prototype.setPublicReadAccess = function(allowed) {
    this.setReadAccess(PUBLIC_KEY, allowed);
  };

  /**
   * Get whether the public is allowed to read this object.
   * @return {Boolean}
   */
  AV.ACL.prototype.getPublicReadAccess = function() {
    return this.getReadAccess(PUBLIC_KEY);
  };

  /**
   * Set whether the public is allowed to write this object.
   * @param {Boolean} allowed
   */
  AV.ACL.prototype.setPublicWriteAccess = function(allowed) {
    this.setWriteAccess(PUBLIC_KEY, allowed);
  };

  /**
   * Get whether the public is allowed to write this object.
   * @return {Boolean}
   */
  AV.ACL.prototype.getPublicWriteAccess = function() {
    return this.getWriteAccess(PUBLIC_KEY);
  };

  /**
   * Get whether users belonging to the given role are allowed
   * to read this object. Even if this returns false, the role may
   * still be able to write it if a parent role has read access.
   *
   * @param role The name of the role, or a AV.Role object.
   * @return {Boolean} true if the role has read access. false otherwise.
   * @throws {String} If role is neither a AV.Role nor a String.
   */
  AV.ACL.prototype.getRoleReadAccess = function(role) {
    if (role instanceof AV.Role) {
      // Normalize to the String name
      role = role.getName();
    }
    if (_.isString(role)) {
      return this.getReadAccess("role:" + role);
    }
    throw "role must be a AV.Role or a String";
  };

  /**
   * Get whether users belonging to the given role are allowed
   * to write this object. Even if this returns false, the role may
   * still be able to write it if a parent role has write access.
   *
   * @param role The name of the role, or a AV.Role object.
   * @return {Boolean} true if the role has write access. false otherwise.
   * @throws {String} If role is neither a AV.Role nor a String.
   */
  AV.ACL.prototype.getRoleWriteAccess = function(role) {
    if (role instanceof AV.Role) {
      // Normalize to the String name
      role = role.getName();
    }
    if (_.isString(role)) {
      return this.getWriteAccess("role:" + role);
    }
    throw "role must be a AV.Role or a String";
  };

  /**
   * Set whether users belonging to the given role are allowed
   * to read this object.
   *
   * @param role The name of the role, or a AV.Role object.
   * @param {Boolean} allowed Whether the given role can read this object.
   * @throws {String} If role is neither a AV.Role nor a String.
   */
  AV.ACL.prototype.setRoleReadAccess = function(role, allowed) {
    if (role instanceof AV.Role) {
      // Normalize to the String name
      role = role.getName();
    }
    if (_.isString(role)) {
      this.setReadAccess("role:" + role, allowed);
      return;
    }
    throw "role must be a AV.Role or a String";
  };

  /**
   * Set whether users belonging to the given role are allowed
   * to write this object.
   *
   * @param role The name of the role, or a AV.Role object.
   * @param {Boolean} allowed Whether the given role can write this object.
   * @throws {String} If role is neither a AV.Role nor a String.
   */
  AV.ACL.prototype.setRoleWriteAccess = function(role, allowed) {
    if (role instanceof AV.Role) {
      // Normalize to the String name
      role = role.getName();
    }
    if (_.isString(role)) {
      this.setWriteAccess("role:" + role, allowed);
      return;
    }
    throw "role must be a AV.Role or a String";
  };

};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/acl.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],2:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * AVOSCloud JavaScript SDK
 * Built: Mon Jun 03 2013 13:45:00
 * https://leancloud.cn
 *
 * Copyright 2015 LeanCloud.cn, Inc.
 * The AVOS Cloud JavaScript SDK is freely distributable under the MIT license.
 */

var AV = module.exports = {};

AV._ = require('underscore');
AV.VERSION = require('./version');
AV.Promise = require('./promise');
AV.XMLHttpRequest = require('./browserify-wrapper/xmlhttprequest').XMLHttpRequest;
AV.localStorage = require('./localstorage');

// 以下模块为了兼容原有代码，使用这种加载方式。
// The module order is important.
require('./utils')(AV);
require('./error')(AV);
require('./event')(AV);
require('./geopoint')(AV);
require('./acl')(AV);
require('./op')(AV);
require('./relation')(AV);
require('./file')(AV);
require('./object')(AV);
require('./role')(AV);
require('./collection')(AV);
require('./view')(AV);
require('./user')(AV);
require('./query')(AV);
require('./facebook')(AV);
require('./history')(AV);
require('./router')(AV);
require('./cloudfunction')(AV);
require('./push')(AV);
require('./status')(AV);
require('./search')(AV);
require('./insight')(AV);
require('./bigquery')(AV);

AV.AV = AV; // Backward compatibility

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/av.js","/../../node_modules/avoscloud-sdk/lib")
},{"./acl":1,"./bigquery":3,"./browserify-wrapper/xmlhttprequest":7,"./cloudfunction":8,"./collection":9,"./error":10,"./event":11,"./facebook":12,"./file":13,"./geopoint":14,"./history":15,"./insight":16,"./localstorage":17,"./object":18,"./op":19,"./promise":20,"./push":21,"./query":22,"./relation":23,"./role":24,"./router":25,"./search":26,"./status":27,"./user":28,"./utils":29,"./version":30,"./view":31,"buffer":35,"oMfpAn":38,"underscore":33}],3:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = function(AV) {
  /**
   * @namespace 包含了使用了 LeanCloud
   *  <a href='/docs/leaninsight_guide.html'>离线数据分析功能</a>的函数，本模块已经废弃，
   * 请使用 AV.Insight 。
   * <p><strong><em>
   *   部分函数仅在云引擎运行环境下有效。
   * </em></strong></p>
   */
  Object.defineProperty(AV, "BigQuery", {
    get: function() {
      console.warn("AV.BigQuery is deprecated, please use AV.Insight instead.");
      return AV.Insight;
    },
  });
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/bigquery.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38}],4:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');
var Promise = require('../promise');

// interface Storage {
//   readonly attribute boolean async;
//   string getItem(string key);
//   void setItem(string key, string value);
//   void removeItem(string key);
//   void clear();
//   Promise getItemAsync(string key);
//   Promise setItemAsync(string key, string value);
//   Promise removeItemAsync(string key);
//   Promise clearAsync();
// }
var Storage = {};
var apiNames = [
  'getItem',
  'setItem',
  'removeItem',
  'clear'
];

if (global.localStorage) {

  var localStorage = global.localStorage;

  try {
    var testKey = '__storejs__';
    localStorage.setItem(testKey, testKey);
    if (localStorage.getItem(testKey) != testKey) {
      throw new Error();
    }
    localStorage.removeItem(testKey);
  } catch (e) {
    localStorage = require('localstorage-memory');
  }

  // in browser, `localStorage.async = false` will excute `localStorage.setItem('async', false)`
  _(apiNames).each(function(apiName) {
    Storage[apiName] = function() {
      return global.localStorage[apiName].apply(global.localStorage, arguments);
    };
  });
  Storage.async = false;
} else {
  var AsyncStorage = require('react-native').AsyncStorage;
  _(apiNames).each(function(apiName) {
    Storage[apiName + 'Async'] = function() {
      return Promise.as(AsyncStorage[apiName].apply(AsyncStorage, arguments));
    };
  });
  Storage.async = true;
}

module.exports = Storage;

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/browserify-wrapper/localstorage-browser.js","/../../node_modules/avoscloud-sdk/lib/browserify-wrapper")
},{"../promise":20,"buffer":35,"localstorage-memory":32,"oMfpAn":38,"react-native":34,"underscore":33}],5:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var dataURItoBlob = function(dataURI, type) {
  var byteString;

  // 传入的 base64，不是 dataURL
  if (dataURI.indexOf('base64') < 0) {
    byteString = atob(dataURI);
  } else if (dataURI.split(',')[0].indexOf('base64') >= 0) {
    byteString = atob(dataURI.split(',')[1]);
  } else {
    byteString = unescape(dataURI.split(',')[1]);
  }
  // separate out the mime component
  var mimeString = type || dataURI.split(',')[0].split(':')[1].split(';')[0];
  var ia = new Uint8Array(byteString.length);
  for (var i = 0; i < byteString.length; i ++) {
      ia[i] = byteString.charCodeAt(i);
  }
  return new Blob([ia], {type:mimeString});
};

module.exports = dataURItoBlob;

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/browserify-wrapper/parse-base64-browser.js","/../../node_modules/avoscloud-sdk/lib/browserify-wrapper")
},{"buffer":35,"oMfpAn":38}],6:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = function upload(file, AV, saveOptions) {
  //use /files endpoint.
  var self = file;
  var dataFormat;
  self._previousSave = self._source.then(function(data, type) {
    dataFormat = data;
    return self._qiniuToken(type);
  }).then(function(response) {
    self._url = response.url;
    self._bucket = response.bucket;
    self.id = response.objectId;
    //Get the uptoken to upload files to qiniu.
    var uptoken = response.token;

    var data = new FormData();
    data.append("file", dataFormat, self._name);
    data.append("key", self._qiniu_key);
    data.append("token", uptoken);

    var promise = new AV.Promise();
    var handled = false;

    var xhr = new AV.XMLHttpRequest();

    if (xhr.upload) {
      xhr.upload.onprogress = saveOptions.onProgress;
    }

    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (handled) {
          return;
        }
        handled = true;

        delete self._qiniu_key;
        if (xhr.status >= 200 && xhr.status < 300) {
          var response;
          try {
            response = JSON.parse(xhr.responseText);
          } catch (e) {
            promise.reject(e);
            self.destroy();
          }
          if (response) {
            promise.resolve(self);
          } else {
            promise.reject(response);
          }
        } else {
          promise.reject(xhr);
          self.destroy();
        }
      }
    };
    xhr.open('POST', 'http://upload.qiniu.com', true);
    xhr.send(data);

    return promise;
  });
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/browserify-wrapper/upload-browser.js","/../../node_modules/avoscloud-sdk/lib/browserify-wrapper")
},{"buffer":35,"oMfpAn":38}],7:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

exports.XMLHttpRequest = global.XMLHttpRequest;

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/browserify-wrapper/xmlhttprequest-browser.js","/../../node_modules/avoscloud-sdk/lib/browserify-wrapper")
},{"buffer":35,"oMfpAn":38}],8:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

module.exports = function(AV) {
  /**
   * @namespace Contains functions for calling and declaring
   * <a href="/docs/cloud_code_guide#functions">cloud functions</a>.
   * <p><strong><em>
   *   Some functions are only available from Cloud Code.
   * </em></strong></p>
   */
  AV.Cloud = AV.Cloud || {};

  _.extend(AV.Cloud, /** @lends AV.Cloud */ {
    /**
     * Makes a call to a cloud function.
     * @param {String} name The function name.
     * @param {Object} data The parameters to send to the cloud function.
     * @param {Object} options A Backbone-style options object
     * options.success, if set, should be a function to handle a successful
     * call to a cloud function.  options.error should be a function that
     * handles an error running the cloud function.  Both functions are
     * optional.  Both functions take a single argument.
     * @return {AV.Promise} A promise that will be resolved with the result
     * of the function.
     */
    run: function(name, data, options) {
      var request = AV._request("functions", name, null, 'POST',
                                   AV._encode(data, null, true));

      return request.then(function(resp) {
        return AV._decode(null, resp).result;
      })._thenRunCallbacks(options);
    },

    /**
     * Make a call to request server date time.
     * @param {Object} options A Backbone-style options object
     * options.success, if set, should be a function to handle a successful
     * call to a cloud function.  options.error should be a function that
     * handles an error running the cloud function.  Both functions are
     * optional.  Both functions take a single argument.
     * @return {AV.Promise} A promise that will be resolved with the result
     * of the function.
     * @since 0.5.9
     */
    getServerDate: function(options) {
      var request = AV._request("date", null, null, 'GET');

      return request.then(function(resp) {
        return AV._decode(null, resp);
      })._thenRunCallbacks(options);
    },

    /**
     * Makes a call to request a sms code for operation verification.
     * @param {Object} data The mobile phone number string or a JSON
     *    object that contains mobilePhoneNumber,template,op,ttl,name etc.
     * @param {Object} options A Backbone-style options object
     * @return {AV.Promise} A promise that will be resolved with the result
     * of the function.
     */
    requestSmsCode: function(data, options){
      if(_.isString(data)) {
        data = { mobilePhoneNumber: data };
      }
      if(!data.mobilePhoneNumber) {
        throw "Missing mobilePhoneNumber.";
      }
      var request = AV._request("requestSmsCode", null, null, 'POST',
                                    data);
      return request._thenRunCallbacks(options);
    },

    /**
     * Makes a call to verify sms code that sent by AV.Cloud.requestSmsCode
     * @param {String} code The sms code sent by AV.Cloud.requestSmsCode
     * @param {phone} phone The mobile phoner number(optional).
     * @param {Object} options A Backbone-style options object
     * @return {AV.Promise} A promise that will be resolved with the result
     * of the function.
     */
    verifySmsCode: function(code, phone, options){
      if(!code)
        throw "Missing sms code.";
      var params = {};
      if(AV._.isString(phone)) {
         params['mobilePhoneNumber'] = phone;
      } else {
        // To be compatible with old versions.
         options = phone;
      }

      var request = AV._request("verifySmsCode", code, null, 'POST',
                                   params);
      return request._thenRunCallbacks(options);
    }
  });
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/cloudfunction.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],9:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

module.exports = function(AV) {
  /**
   * Creates a new instance with the given models and options.  Typically, you
   * will not call this method directly, but will instead make a subclass using
   * <code>AV.Collection.extend</code>.
   *
   * @param {Array} models An array of instances of <code>AV.Object</code>.
   *
   * @param {Object} options An optional object with Backbone-style options.
   * Valid options are:<ul>
   *   <li>model: The AV.Object subclass that this collection contains.
   *   <li>query: An instance of AV.Query to use when fetching items.
   *   <li>comparator: A string property name or function to sort by.
   * </ul>
   *
   * @see AV.Collection.extend
   *
   * @class
   *
   * <p>Provides a standard collection class for our sets of models, ordered
   * or unordered.  For more information, see the
   * <a href="http://documentcloud.github.com/backbone/#Collection">Backbone
   * documentation</a>.</p>
   */
  AV.Collection = function(models, options) {
    console.warn("AV.Collection is deprecated, please don't use it anymore.");
    options = options || {};
    if (options.comparator) {
      this.comparator = options.comparator;
    }
    if (options.model) {
      this.model = options.model;
    }
    if (options.query) {
      this.query = options.query;
    }
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) {
      this.reset(models, {silent: true, parse: options.parse});
    }
  };

  // Define the Collection's inheritable methods.
  _.extend(AV.Collection.prototype, AV.Events,
      /** @lends AV.Collection.prototype */ {

    // The default model for a collection is just a AV.Object.
    // This should be overridden in most cases.

    model: AV.Object,

    /**
     * Initialize is an empty function by default. Override it with your own
     * initialization logic.
     */
    initialize: function(){},

    /**
     * The JSON representation of a Collection is an array of the
     * models' attributes.
     */
    toJSON: function() {
      return this.map(function(model){ return model.toJSON(); });
    },

    /**
     * Add a model, or list of models to the set. Pass **silent** to avoid
     * firing the `add` event for every new model.
     */
    add: function(models, options) {
      var i, index, length, model, cid, id, cids = {}, ids = {};
      options = options || {};
      models = _.isArray(models) ? models.slice() : [models];

      // Begin by turning bare objects into model references, and preventing
      // invalid models or duplicate models from being added.
      for (i = 0, length = models.length; i < length; i++) {
        models[i] = this._prepareModel(models[i], options);
        model = models[i];
        if (!model) {
          throw new Error("Can't add an invalid model to a collection");
        }
        cid = model.cid;
        if (cids[cid] || this._byCid[cid]) {
          throw new Error("Duplicate cid: can't add the same model " +
                          "to a collection twice");
        }
        id = model.id;
        if (!AV._isNullOrUndefined(id) && (ids[id] || this._byId[id])) {
          throw new Error("Duplicate id: can't add the same model " +
                          "to a collection twice");
        }
        ids[id] = model;
        cids[cid] = model;
      }

      // Listen to added models' events, and index models for lookup by
      // `id` and by `cid`.
      for (i = 0; i < length; i++) {
        (model = models[i]).on('all', this._onModelEvent, this);
        this._byCid[model.cid] = model;
        if (model.id) {
          this._byId[model.id] = model;
        }
      }

      // Insert models into the collection, re-sorting if needed, and triggering
      // `add` events unless silenced.
      this.length += length;
      index = AV._isNullOrUndefined(options.at) ?
          this.models.length : options.at;
      this.models.splice.apply(this.models, [index, 0].concat(models));
      if (this.comparator) {
        this.sort({silent: true});
      }
      if (options.silent) {
        return this;
      }
      for (i = 0, length = this.models.length; i < length; i++) {
        model = this.models[i];
        if (cids[model.cid]) {
          options.index = i;
          model.trigger('add', model, this, options);
        }
      }
      return this;
    },

    /**
     * Remove a model, or a list of models from the set. Pass silent to avoid
     * firing the <code>remove</code> event for every model removed.
     */
    remove: function(models, options) {
      var i, l, index, model;
      options = options || {};
      models = _.isArray(models) ? models.slice() : [models];
      for (i = 0, l = models.length; i < l; i++) {
        model = this.getByCid(models[i]) || this.get(models[i]);
        if (!model) {
          continue;
        }
        delete this._byId[model.id];
        delete this._byCid[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return this;
    },

    /**
     * Gets a model from the set by id.
     */
    get: function(id) {
      return id && this._byId[id.id || id];
    },

    /**
     * Gets a model from the set by client id.
     */
    getByCid: function(cid) {
      return cid && this._byCid[cid.cid || cid];
    },

    /**
     * Gets the model at the given index.
     */
    at: function(index) {
      return this.models[index];
    },

    /**
     * Forces the collection to re-sort itself. You don't need to call this
     * under normal circumstances, as the set will maintain sort order as each
     * item is added.
     */
    sort: function(options) {
      options = options || {};
      if (!this.comparator) {
        throw new Error('Cannot sort a set without a comparator');
      }
      var boundComparator = _.bind(this.comparator, this);
      if (this.comparator.length === 1) {
        this.models = this.sortBy(boundComparator);
      } else {
        this.models.sort(boundComparator);
      }
      if (!options.silent) {
        this.trigger('reset', this, options);
      }
      return this;
    },

    /**
     * Plucks an attribute from each model in the collection.
     */
    pluck: function(attr) {
      return _.map(this.models, function(model){ return model.get(attr); });
    },

    /**
     * When you have more items than you want to add or remove individually,
     * you can reset the entire set with a new list of models, without firing
     * any `add` or `remove` events. Fires `reset` when finished.
     */
    reset: function(models, options) {
      var self = this;
      models = models || [];
      options = options || {};
      AV._arrayEach(this.models, function(model) {
        self._removeReference(model);
      });
      this._reset();
      this.add(models, {silent: true, parse: options.parse});
      if (!options.silent) {
        this.trigger('reset', this, options);
      }
      return this;
    },

    /**
     * Fetches the default set of models for this collection, resetting the
     * collection when they arrive. If `add: true` is passed, appends the
     * models to the collection instead of resetting.
     */
    fetch: function(options) {
      options = _.clone(options) || {};
      if (options.parse === undefined) {
        options.parse = true;
      }
      var collection = this;
      var query = this.query || new AV.Query(this.model);
      return query.find().then(function(results) {
        if (options.add) {
          collection.add(results, options);
        } else {
          collection.reset(results, options);
        }
        return collection;
      })._thenRunCallbacks(options, this);
    },

    /**
     * Creates a new instance of a model in this collection. Add the model to
     * the collection immediately, unless `wait: true` is passed, in which case
     * we wait for the server to agree.
     */
    create: function(model, options) {
      var coll = this;
      options = options ? _.clone(options) : {};
      model = this._prepareModel(model, options);
      if (!model) {
        return false;
      }
      if (!options.wait) {
        coll.add(model, options);
      }
      var success = options.success;
      options.success = function(nextModel, resp, xhr) {
        if (options.wait) {
          coll.add(nextModel, options);
        }
        if (success) {
          success(nextModel, resp);
        } else {
          nextModel.trigger('sync', model, resp, options);
        }
      };
      model.save(null, options);
      return model;
    },

    /**
     * Converts a response into a list of models to be added to the collection.
     * The default implementation is just to pass it through.
     * @ignore
     */
    parse: function(resp, xhr) {
      return resp;
    },

    /**
     * Proxy to _'s chain. Can't be proxied the same way the rest of the
     * underscore methods are proxied because it relies on the underscore
     * constructor.
     */
    chain: function() {
      return _(this.models).chain();
    },

    /**
     * Reset all internal state. Called when the collection is reset.
     */
    _reset: function(options) {
      this.length = 0;
      this.models = [];
      this._byId  = {};
      this._byCid = {};
    },

    /**
     * Prepare a model or hash of attributes to be added to this collection.
     */
    _prepareModel: function(model, options) {
      if (!(model instanceof AV.Object)) {
        var attrs = model;
        options.collection = this;
        model = new this.model(attrs, options);
        if (!model._validate(model.attributes, options)) {
          model = false;
        }
      } else if (!model.collection) {
        model.collection = this;
      }
      return model;
    },

    /**
     * Internal method to remove a model's ties to a collection.
     */
    _removeReference: function(model) {
      if (this === model.collection) {
        delete model.collection;
      }
      model.off('all', this._onModelEvent, this);
    },

    /**
     * Internal method called every time a model in the set fires an event.
     * Sets need to update their indexes when models change ids. All other
     * events simply proxy through. "add" and "remove" events that originate
     * in other collections are ignored.
     */
    _onModelEvent: function(ev, model, collection, options) {
      if ((ev === 'add' || ev === 'remove') && collection !== this) {
        return;
      }
      if (ev === 'destroy') {
        this.remove(model, options);
      }
      if (model && ev === 'change:objectId') {
        delete this._byId[model.previous("objectId")];
        this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  var methods = ['forEach', 'each', 'map', 'reduce', 'reduceRight', 'find',
    'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any',
    'include', 'contains', 'invoke', 'max', 'min', 'sortBy', 'sortedIndex',
    'toArray', 'size', 'first', 'initial', 'rest', 'last', 'without', 'indexOf',
    'shuffle', 'lastIndexOf', 'isEmpty', 'groupBy'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  AV._arrayEach(methods, function(method) {
    AV.Collection.prototype[method] = function() {
      return _[method].apply(_, [this.models].concat(_.toArray(arguments)));
    };
  });

  /**
   * Creates a new subclass of <code>AV.Collection</code>.  For example,<pre>
   *   var MyCollection = AV.Collection.extend({
   *     // Instance properties
   *
   *     model: MyClass,
   *     query: MyQuery,
   *
   *     getFirst: function() {
   *       return this.at(0);
   *     }
   *   }, {
   *     // Class properties
   *
   *     makeOne: function() {
   *       return new MyCollection();
   *     }
   *   });
   *
   *   var collection = new MyCollection();
   * </pre>
   *
   * @function
   * @param {Object} instanceProps Instance properties for the collection.
   * @param {Object} classProps Class properies for the collection.
   * @return {Class} A new subclass of <code>AV.Collection</code>.
   */
  AV.Collection.extend = AV._extend;

};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/collection.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],10:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

module.exports = function(AV) {

  /**
   * Constructs a new AV.Error object with the given code and message.
   * @param {Number} code An error code constant from <code>AV.Error</code>.
   * @param {String} message A detailed description of the error.
   * @class
   *
   * <p>Class used for all objects passed to error callbacks.</p>
   */
  AV.Error = function(code, message) {
    this.code = code;
    this.message = message;
  };

  _.extend(AV.Error, /** @lends AV.Error */ {
    /**
     * Error code indicating some error other than those enumerated here.
     * @constant
     */
    OTHER_CAUSE: -1,

    /**
     * Error code indicating that something has gone wrong with the server.
     * If you get this error code, it is AV's fault. Contact us at
     * https://avoscloud.com/help
     * @constant
     */
    INTERNAL_SERVER_ERROR: 1,

    /**
     * Error code indicating the connection to the AV servers failed.
     * @constant
     */
    CONNECTION_FAILED: 100,

    /**
     * Error code indicating the specified object doesn't exist.
     * @constant
     */
    OBJECT_NOT_FOUND: 101,

    /**
     * Error code indicating you tried to query with a datatype that doesn't
     * support it, like exact matching an array or object.
     * @constant
     */
    INVALID_QUERY: 102,

    /**
     * Error code indicating a missing or invalid classname. Classnames are
     * case-sensitive. They must start with a letter, and a-zA-Z0-9_ are the
     * only valid characters.
     * @constant
     */
    INVALID_CLASS_NAME: 103,

    /**
     * Error code indicating an unspecified object id.
     * @constant
     */
    MISSING_OBJECT_ID: 104,

    /**
     * Error code indicating an invalid key name. Keys are case-sensitive. They
     * must start with a letter, and a-zA-Z0-9_ are the only valid characters.
     * @constant
     */
    INVALID_KEY_NAME: 105,

    /**
     * Error code indicating a malformed pointer. You should not see this unless
     * you have been mucking about changing internal AV code.
     * @constant
     */
    INVALID_POINTER: 106,

    /**
     * Error code indicating that badly formed JSON was received upstream. This
     * either indicates you have done something unusual with modifying how
     * things encode to JSON, or the network is failing badly.
     * @constant
     */
    INVALID_JSON: 107,

    /**
     * Error code indicating that the feature you tried to access is only
     * available internally for testing purposes.
     * @constant
     */
    COMMAND_UNAVAILABLE: 108,

    /**
     * You must call AV.initialize before using the AV library.
     * @constant
     */
    NOT_INITIALIZED: 109,

    /**
     * Error code indicating that a field was set to an inconsistent type.
     * @constant
     */
    INCORRECT_TYPE: 111,

    /**
     * Error code indicating an invalid channel name. A channel name is either
     * an empty string (the broadcast channel) or contains only a-zA-Z0-9_
     * characters and starts with a letter.
     * @constant
     */
    INVALID_CHANNEL_NAME: 112,

    /**
     * Error code indicating that push is misconfigured.
     * @constant
     */
    PUSH_MISCONFIGURED: 115,

    /**
     * Error code indicating that the object is too large.
     * @constant
     */
    OBJECT_TOO_LARGE: 116,

    /**
     * Error code indicating that the operation isn't allowed for clients.
     * @constant
     */
    OPERATION_FORBIDDEN: 119,

    /**
     * Error code indicating the result was not found in the cache.
     * @constant
     */
    CACHE_MISS: 120,

    /**
     * Error code indicating that an invalid key was used in a nested
     * JSONObject.
     * @constant
     */
    INVALID_NESTED_KEY: 121,

    /**
     * Error code indicating that an invalid filename was used for AVFile.
     * A valid file name contains only a-zA-Z0-9_. characters and is between 1
     * and 128 characters.
     * @constant
     */
    INVALID_FILE_NAME: 122,

    /**
     * Error code indicating an invalid ACL was provided.
     * @constant
     */
    INVALID_ACL: 123,

    /**
     * Error code indicating that the request timed out on the server. Typically
     * this indicates that the request is too expensive to run.
     * @constant
     */
    TIMEOUT: 124,

    /**
     * Error code indicating that the email address was invalid.
     * @constant
     */
    INVALID_EMAIL_ADDRESS: 125,

    /**
     * Error code indicating a missing content type.
     * @constant
     */
    MISSING_CONTENT_TYPE: 126,

    /**
     * Error code indicating a missing content length.
     * @constant
     */
    MISSING_CONTENT_LENGTH: 127,

    /**
     * Error code indicating an invalid content length.
     * @constant
     */
    INVALID_CONTENT_LENGTH: 128,

    /**
     * Error code indicating a file that was too large.
     * @constant
     */
    FILE_TOO_LARGE: 129,

    /**
     * Error code indicating an error saving a file.
     * @constant
     */
    FILE_SAVE_ERROR: 130,

    /**
     * Error code indicating an error deleting a file.
     * @constant
     */
    FILE_DELETE_ERROR: 153,

    /**
     * Error code indicating that a unique field was given a value that is
     * already taken.
     * @constant
     */
    DUPLICATE_VALUE: 137,

    /**
     * Error code indicating that a role's name is invalid.
     * @constant
     */
    INVALID_ROLE_NAME: 139,

    /**
     * Error code indicating that an application quota was exceeded.  Upgrade to
     * resolve.
     * @constant
     */
    EXCEEDED_QUOTA: 140,

    /**
     * Error code indicating that a Cloud Code script failed.
     * @constant
     */
    SCRIPT_FAILED: 141,

    /**
     * Error code indicating that a Cloud Code validation failed.
     * @constant
     */
    VALIDATION_ERROR: 142,

    /**
     * Error code indicating that invalid image data was provided.
     * @constant
     */
    INVALID_IMAGE_DATA: 150,

    /**
     * Error code indicating an unsaved file.
     * @constant
     */
    UNSAVED_FILE_ERROR: 151,

    /**
     * Error code indicating an invalid push time.
     */
    INVALID_PUSH_TIME_ERROR: 152,

    /**
     * Error code indicating that the username is missing or empty.
     * @constant
     */
    USERNAME_MISSING: 200,

    /**
     * Error code indicating that the password is missing or empty.
     * @constant
     */
    PASSWORD_MISSING: 201,

    /**
     * Error code indicating that the username has already been taken.
     * @constant
     */
    USERNAME_TAKEN: 202,

    /**
     * Error code indicating that the email has already been taken.
     * @constant
     */
    EMAIL_TAKEN: 203,

    /**
     * Error code indicating that the email is missing, but must be specified.
     * @constant
     */
    EMAIL_MISSING: 204,

    /**
     * Error code indicating that a user with the specified email was not found.
     * @constant
     */
    EMAIL_NOT_FOUND: 205,

    /**
     * Error code indicating that a user object without a valid session could
     * not be altered.
     * @constant
     */
    SESSION_MISSING: 206,

    /**
     * Error code indicating that a user can only be created through signup.
     * @constant
     */
    MUST_CREATE_USER_THROUGH_SIGNUP: 207,

    /**
     * Error code indicating that an an account being linked is already linked
     * to another user.
     * @constant
     */
    ACCOUNT_ALREADY_LINKED: 208,

    /**
     * Error code indicating that a user cannot be linked to an account because
     * that account's id could not be found.
     * @constant
     */
    LINKED_ID_MISSING: 250,

    /**
     * Error code indicating that a user with a linked (e.g. Facebook) account
     * has an invalid session.
     * @constant
     */
    INVALID_LINKED_SESSION: 251,

    /**
     * Error code indicating that a service being linked (e.g. Facebook or
     * Twitter) is unsupported.
     * @constant
     */
    UNSUPPORTED_SERVICE: 252,
    /**
     * Error code indicating a real error code is unavailable because
     * we had to use an XDomainRequest object to allow CORS requests in
     * Internet Explorer, which strips the body from HTTP responses that have
     * a non-2XX status code.
     * @constant
     */
    X_DOMAIN_REQUEST: 602
  });

};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/error.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],11:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*global _: false */
module.exports = function(AV) {
  var eventSplitter = /\s+/;
  var slice = Array.prototype.slice;

  /**
   * @class
   *
   * <p>AV.Events is a fork of Backbone's Events module, provided for your
   * convenience.</p>
   *
   * <p>A module that can be mixed in to any object in order to provide
   * it with custom events. You may bind callback functions to an event
   * with `on`, or remove these functions with `off`.
   * Triggering an event fires all callbacks in the order that `on` was
   * called.
   *
   * <pre>
   *     var object = {};
   *     _.extend(object, AV.Events);
   *     object.on('expand', function(){ alert('expanded'); });
   *     object.trigger('expand');</pre></p>
   *
   * <p>For more information, see the
   * <a href="http://documentcloud.github.com/backbone/#Events">Backbone
   * documentation</a>.</p>
   */
  AV.Events = {
    /**
     * Bind one or more space separated events, `events`, to a `callback`
     * function. Passing `"all"` will bind the callback to all events fired.
     */
    on: function(events, callback, context) {

      var calls, event, node, tail, list;
      if (!callback) {
        return this;
      }
      events = events.split(eventSplitter);
      calls = this._callbacks || (this._callbacks = {});

      // Create an immutable callback list, allowing traversal during
      // modification.  The tail is an empty object that will always be used
      // as the next node.
      event = events.shift();
      while (event) {
        list = calls[event];
        node = list ? list.tail : {};
        node.next = tail = {};
        node.context = context;
        node.callback = callback;
        calls[event] = {tail: tail, next: list ? list.next : node};
        event = events.shift();
      }

      return this;
    },

    /**
     * Remove one or many callbacks. If `context` is null, removes all callbacks
     * with that function. If `callback` is null, removes all callbacks for the
     * event. If `events` is null, removes all bound callbacks for all events.
     */
    off: function(events, callback, context) {
      var event, calls, node, tail, cb, ctx;

      // No events, or removing *all* events.
      if (!(calls = this._callbacks)) {
        return;
      }
      if (!(events || callback || context)) {
        delete this._callbacks;
        return this;
      }

      // Loop through the listed events and contexts, splicing them out of the
      // linked list of callbacks if appropriate.
      events = events ? events.split(eventSplitter) : _.keys(calls);
      event = events.shift();
      while (event) {
        node = calls[event];
        delete calls[event];
        if (!node || !(callback || context)) {
          continue;
        }
        // Create a new list, omitting the indicated callbacks.
        tail = node.tail;
        node = node.next;
        while (node !== tail) {
          cb = node.callback;
          ctx = node.context;
          if ((callback && cb !== callback) || (context && ctx !== context)) {
            this.on(event, cb, ctx);
          }
          node = node.next;
        }
        event = events.shift();
      }

      return this;
    },

    /**
     * Trigger one or many events, firing all bound callbacks. Callbacks are
     * passed the same arguments as `trigger` is, apart from the event name
     * (unless you're listening on `"all"`, which will cause your callback to
     * receive the true name of the event as the first argument).
     */
    trigger: function(events) {
      var event, node, calls, tail, args, all, rest;
      if (!(calls = this._callbacks)) {
        return this;
      }
      all = calls.all;
      events = events.split(eventSplitter);
      rest = slice.call(arguments, 1);

      // For each event, walk through the linked list of callbacks twice,
      // first to trigger the event, then to trigger any `"all"` callbacks.
      event = events.shift();
      while (event) {
        node = calls[event];
        if (node) {
          tail = node.tail;
          while ((node = node.next) !== tail) {
            node.callback.apply(node.context || this, rest);
          }
        }
        node = all;
        if (node) {
          tail = node.tail;
          args = [event].concat(rest);
          while ((node = node.next) !== tail) {
            node.callback.apply(node.context || this, args);
          }
        }
        event = events.shift();
      }

      return this;
    }
  };

  /**
   * @function
   */
  AV.Events.bind = AV.Events.on;

  /**
   * @function
   */
  AV.Events.unbind = AV.Events.off;
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/event.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38}],12:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

/*global FB: false , console: false*/
module.exports = function(AV) {
  var PUBLIC_KEY = "*";

  var initialized = false;
  var requestedPermissions;
  var initOptions;
  var provider = {
    authenticate: function(options) {
      var self = this;
      FB.login(function(response) {
        if (response.authResponse) {
          if (options.success) {
            options.success(self, {
              id: response.authResponse.userID,
              access_token: response.authResponse.accessToken,
              expiration_date: new Date(response.authResponse.expiresIn * 1000 +
                  (new Date()).getTime()).toJSON()
            });
          }
        } else {
          if (options.error) {
            options.error(self, response);
          }
        }
      }, {
        scope: requestedPermissions
      });
    },
    restoreAuthentication: function(authData) {
      if (authData) {
        var authResponse = {
          userID: authData.id,
          accessToken: authData.access_token,
          expiresIn: (AV._parseDate(authData.expiration_date).getTime() -
              (new Date()).getTime()) / 1000
        };
        var newOptions = _.clone(initOptions);
        newOptions.authResponse = authResponse;

        // Suppress checks for login status from the browser.
        newOptions.status = false;
        FB.init(newOptions);
      }
      return true;
    },
    getAuthType: function() {
      return "facebook";
    },
    deauthenticate: function() {
      this.restoreAuthentication(null);
      FB.logout();
    }
  };

  /**
   * Provides a set of utilities for using AV with Facebook.
   * @namespace
   * Provides a set of utilities for using AV with Facebook.
   */
  AV.FacebookUtils = {
    /**
     * Initializes AV Facebook integration.  Call this function after you
     * have loaded the Facebook Javascript SDK with the same parameters
     * as you would pass to<code>
     * <a href=
     * "https://developers.facebook.com/docs/reference/javascript/FB.init/">
     * FB.init()</a></code>.  AV.FacebookUtils will invoke FB.init() for you
     * with these arguments.
     *
     * @param {Object} options Facebook options argument as described here:
     *   <a href=
     *   "https://developers.facebook.com/docs/reference/javascript/FB.init/">
     *   FB.init()</a>. The status flag will be coerced to 'false' because it
     *   interferes with AV Facebook integration. Call FB.getLoginStatus()
     *   explicitly if this behavior is required by your application.
     */
    init: function(options) {
      console.warn("AV.FacebookUtils is deprecated, please don't use it anymore.");
      if (typeof(FB) === 'undefined') {
        throw "The Facebook JavaScript SDK must be loaded before calling init.";
      }
      initOptions = _.clone(options) || {};
      if (initOptions.status && typeof(console) !== "undefined") {
        var warn = console.warn || console.log || function() {};
        warn.call(console, "The 'status' flag passed into" +
          " FB.init, when set to true, can interfere with AV Facebook" +
          " integration, so it has been suppressed. Please call" +
          " FB.getLoginStatus() explicitly if you require this behavior.");
      }
      initOptions.status = false;
      FB.init(initOptions);
      AV.User._registerAuthenticationProvider(provider);
      initialized = true;
    },

    /**
     * Gets whether the user has their account linked to Facebook.
     *
     * @param {AV.User} user User to check for a facebook link.
     *     The user must be logged in on this device.
     * @return {Boolean} <code>true</code> if the user has their account
     *     linked to Facebook.
     */
    isLinked: function(user) {
      return user._isLinked("facebook");
    },

    /**
     * Logs in a user using Facebook. This method delegates to the Facebook
     * SDK to authenticate the user, and then automatically logs in (or
     * creates, in the case where it is a new user) a AV.User.
     *
     * @param {String, Object} permissions The permissions required for Facebook
     *    log in.  This is a comma-separated string of permissions.
     *    Alternatively, supply a Facebook authData object as described in our
     *    REST API docs if you want to handle getting facebook auth tokens
     *    yourself.
     * @param {Object} options Standard options object with success and error
     *    callbacks.
     */
    logIn: function(permissions, options) {
      if (!permissions || _.isString(permissions)) {
        if (!initialized) {
          throw "You must initialize FacebookUtils before calling logIn.";
        }
        requestedPermissions = permissions;
        return AV.User._logInWith("facebook", options);
      } else {
        var newOptions = _.clone(options) || {};
        newOptions.authData = permissions;
        return AV.User._logInWith("facebook", newOptions);
      }
    },

    /**
     * Links Facebook to an existing PFUser. This method delegates to the
     * Facebook SDK to authenticate the user, and then automatically links
     * the account to the AV.User.
     *
     * @param {AV.User} user User to link to Facebook. This must be the
     *     current user.
     * @param {String, Object} permissions The permissions required for Facebook
     *    log in.  This is a comma-separated string of permissions.
     *    Alternatively, supply a Facebook authData object as described in our
     *    REST API docs if you want to handle getting facebook auth tokens
     *    yourself.
     * @param {Object} options Standard options object with success and error
     *    callbacks.
     */
    link: function(user, permissions, options) {
      if (!permissions || _.isString(permissions)) {
        if (!initialized) {
          throw "You must initialize FacebookUtils before calling link.";
        }
        requestedPermissions = permissions;
        return user._linkWith("facebook", options);
      } else {
        var newOptions = _.clone(options) || {};
        newOptions.authData = permissions;
        return user._linkWith("facebook", newOptions);
      }
    },

    /**
     * Unlinks the AV.User from a Facebook account.
     *
     * @param {AV.User} user User to unlink from Facebook. This must be the
     *     current user.
     * @param {Object} options Standard options object with success and error
     *    callbacks.
     */
    unlink: function(user, options) {
      if (!initialized) {
        throw "You must initialize FacebookUtils before calling unlink.";
      }
      return user._unlinkFrom("facebook", options);
    }
  };

};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/facebook.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],13:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

// port from browserify path module
// since react-native packager won't shim node modules.
function extname(path) {
  return path.match(/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/)[4];
}

/*jshint bitwise:false *//*global FileReader: true, File: true */
module.exports = function(AV) {
  var b64Digit = function(number) {
    if (number < 26) {
      return String.fromCharCode(65 + number);
    }
    if (number < 52) {
      return String.fromCharCode(97 + (number - 26));
    }
    if (number < 62) {
      return String.fromCharCode(48 + (number - 52));
    }
    if (number === 62) {
      return "+";
    }
    if (number === 63) {
      return "/";
    }
    throw "Tried to encode large digit " + number + " in base64.";
  };

  var encodeBase64 = function(array) {
    var chunks = [];
    chunks.length = Math.ceil(array.length / 3);
    _.times(chunks.length, function(i) {
      var b1 = array[i * 3];
      var b2 = array[i * 3 + 1] || 0;
      var b3 = array[i * 3 + 2] || 0;

      var has2 = (i * 3 + 1) < array.length;
      var has3 = (i * 3 + 2) < array.length;

      chunks[i] = [
        b64Digit((b1 >> 2) & 0x3F),
        b64Digit(((b1 << 4) & 0x30) | ((b2 >> 4) & 0x0F)),
        has2 ? b64Digit(((b2 << 2) & 0x3C) | ((b3 >> 6) & 0x03)) : "=",
        has3 ? b64Digit(b3 & 0x3F) : "="
      ].join("");
    });
    return chunks.join("");
  };

  // A list of file extensions to mime types as found here:
  // http://stackoverflow.com/questions/58510/using-net-how-can-you-find-the-
  //     mime-type-of-a-file-based-on-the-file-signature
  var mimeTypes = {
    ai: "application/postscript",
    aif: "audio/x-aiff",
    aifc: "audio/x-aiff",
    aiff: "audio/x-aiff",
    asc: "text/plain",
    atom: "application/atom+xml",
    au: "audio/basic",
    avi: "video/x-msvideo",
    bcpio: "application/x-bcpio",
    bin: "application/octet-stream",
    bmp: "image/bmp",
    cdf: "application/x-netcdf",
    cgm: "image/cgm",
    "class": "application/octet-stream",
    cpio: "application/x-cpio",
    cpt: "application/mac-compactpro",
    csh: "application/x-csh",
    css: "text/css",
    dcr: "application/x-director",
    dif: "video/x-dv",
    dir: "application/x-director",
    djv: "image/vnd.djvu",
    djvu: "image/vnd.djvu",
    dll: "application/octet-stream",
    dmg: "application/octet-stream",
    dms: "application/octet-stream",
    doc: "application/msword",
    docx: "application/vnd.openxmlformats-officedocument.wordprocessingml." +
          "document",
    dotx: "application/vnd.openxmlformats-officedocument.wordprocessingml." +
          "template",
    docm: "application/vnd.ms-word.document.macroEnabled.12",
    dotm: "application/vnd.ms-word.template.macroEnabled.12",
    dtd: "application/xml-dtd",
    dv: "video/x-dv",
    dvi: "application/x-dvi",
    dxr: "application/x-director",
    eps: "application/postscript",
    etx: "text/x-setext",
    exe: "application/octet-stream",
    ez: "application/andrew-inset",
    gif: "image/gif",
    gram: "application/srgs",
    grxml: "application/srgs+xml",
    gtar: "application/x-gtar",
    hdf: "application/x-hdf",
    hqx: "application/mac-binhex40",
    htm: "text/html",
    html: "text/html",
    ice: "x-conference/x-cooltalk",
    ico: "image/x-icon",
    ics: "text/calendar",
    ief: "image/ief",
    ifb: "text/calendar",
    iges: "model/iges",
    igs: "model/iges",
    jnlp: "application/x-java-jnlp-file",
    jp2: "image/jp2",
    jpe: "image/jpeg",
    jpeg: "image/jpeg",
    jpg: "image/jpeg",
    js: "application/x-javascript",
    kar: "audio/midi",
    latex: "application/x-latex",
    lha: "application/octet-stream",
    lzh: "application/octet-stream",
    m3u: "audio/x-mpegurl",
    m4a: "audio/mp4a-latm",
    m4b: "audio/mp4a-latm",
    m4p: "audio/mp4a-latm",
    m4u: "video/vnd.mpegurl",
    m4v: "video/x-m4v",
    mac: "image/x-macpaint",
    man: "application/x-troff-man",
    mathml: "application/mathml+xml",
    me: "application/x-troff-me",
    mesh: "model/mesh",
    mid: "audio/midi",
    midi: "audio/midi",
    mif: "application/vnd.mif",
    mov: "video/quicktime",
    movie: "video/x-sgi-movie",
    mp2: "audio/mpeg",
    mp3: "audio/mpeg",
    mp4: "video/mp4",
    mpe: "video/mpeg",
    mpeg: "video/mpeg",
    mpg: "video/mpeg",
    mpga: "audio/mpeg",
    ms: "application/x-troff-ms",
    msh: "model/mesh",
    mxu: "video/vnd.mpegurl",
    nc: "application/x-netcdf",
    oda: "application/oda",
    ogg: "application/ogg",
    pbm: "image/x-portable-bitmap",
    pct: "image/pict",
    pdb: "chemical/x-pdb",
    pdf: "application/pdf",
    pgm: "image/x-portable-graymap",
    pgn: "application/x-chess-pgn",
    pic: "image/pict",
    pict: "image/pict",
    png: "image/png",
    pnm: "image/x-portable-anymap",
    pnt: "image/x-macpaint",
    pntg: "image/x-macpaint",
    ppm: "image/x-portable-pixmap",
    ppt: "application/vnd.ms-powerpoint",
    pptx: "application/vnd.openxmlformats-officedocument.presentationml." +
          "presentation",
    potx: "application/vnd.openxmlformats-officedocument.presentationml." +
          "template",
    ppsx: "application/vnd.openxmlformats-officedocument.presentationml." +
          "slideshow",
    ppam: "application/vnd.ms-powerpoint.addin.macroEnabled.12",
    pptm: "application/vnd.ms-powerpoint.presentation.macroEnabled.12",
    potm: "application/vnd.ms-powerpoint.template.macroEnabled.12",
    ppsm: "application/vnd.ms-powerpoint.slideshow.macroEnabled.12",
    ps: "application/postscript",
    qt: "video/quicktime",
    qti: "image/x-quicktime",
    qtif: "image/x-quicktime",
    ra: "audio/x-pn-realaudio",
    ram: "audio/x-pn-realaudio",
    ras: "image/x-cmu-raster",
    rdf: "application/rdf+xml",
    rgb: "image/x-rgb",
    rm: "application/vnd.rn-realmedia",
    roff: "application/x-troff",
    rtf: "text/rtf",
    rtx: "text/richtext",
    sgm: "text/sgml",
    sgml: "text/sgml",
    sh: "application/x-sh",
    shar: "application/x-shar",
    silo: "model/mesh",
    sit: "application/x-stuffit",
    skd: "application/x-koan",
    skm: "application/x-koan",
    skp: "application/x-koan",
    skt: "application/x-koan",
    smi: "application/smil",
    smil: "application/smil",
    snd: "audio/basic",
    so: "application/octet-stream",
    spl: "application/x-futuresplash",
    src: "application/x-wais-source",
    sv4cpio: "application/x-sv4cpio",
    sv4crc: "application/x-sv4crc",
    svg: "image/svg+xml",
    swf: "application/x-shockwave-flash",
    t: "application/x-troff",
    tar: "application/x-tar",
    tcl: "application/x-tcl",
    tex: "application/x-tex",
    texi: "application/x-texinfo",
    texinfo: "application/x-texinfo",
    tif: "image/tiff",
    tiff: "image/tiff",
    tr: "application/x-troff",
    tsv: "text/tab-separated-values",
    txt: "text/plain",
    ustar: "application/x-ustar",
    vcd: "application/x-cdlink",
    vrml: "model/vrml",
    vxml: "application/voicexml+xml",
    wav: "audio/x-wav",
    wbmp: "image/vnd.wap.wbmp",
    wbmxl: "application/vnd.wap.wbxml",
    wml: "text/vnd.wap.wml",
    wmlc: "application/vnd.wap.wmlc",
    wmls: "text/vnd.wap.wmlscript",
    wmlsc: "application/vnd.wap.wmlscriptc",
    wrl: "model/vrml",
    xbm: "image/x-xbitmap",
    xht: "application/xhtml+xml",
    xhtml: "application/xhtml+xml",
    xls: "application/vnd.ms-excel",
    xml: "application/xml",
    xpm: "image/x-xpixmap",
    xsl: "application/xml",
    xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    xltx: "application/vnd.openxmlformats-officedocument.spreadsheetml." +
          "template",
    xlsm: "application/vnd.ms-excel.sheet.macroEnabled.12",
    xltm: "application/vnd.ms-excel.template.macroEnabled.12",
    xlam: "application/vnd.ms-excel.addin.macroEnabled.12",
    xlsb: "application/vnd.ms-excel.sheet.binary.macroEnabled.12",
    xslt: "application/xslt+xml",
    xul: "application/vnd.mozilla.xul+xml",
    xwd: "image/x-xwindowdump",
    xyz: "chemical/x-xyz",
    zip: "application/zip"
  };

  /**
   * Reads a File using a FileReader.
   * @param file {File} the File to read.
   * @param type {String} (optional) the mimetype to override with.
   * @return {AV.Promise} A Promise that will be fulfilled with a
   *     base64-encoded string of the data and its mime type.
   */
  var readAsync = function(file, type) {
    var promise = new AV.Promise();

    if (typeof(FileReader) === "undefined") {
      return AV.Promise.error(new AV.Error(
          -1, "Attempted to use a FileReader on an unsupported browser."));
    }

    var reader = new FileReader();
    reader.onloadend = function() {
      if (reader.readyState !== 2) {
        promise.reject(new AV.Error(-1, "Error reading file."));
        return;
      }

      var dataURL = reader.result;
      var matches = /^data:([^;]*);base64,(.*)$/.exec(dataURL);
      if (!matches) {
        promise.reject(
            new AV.Error(-1, "Unable to interpret data URL: " + dataURL));
        return;
      }

      promise.resolve(matches[2], type || matches[1]);
    };
    reader.readAsDataURL(file);
    return promise;
  };

  /**
   * A AV.File is a local representation of a file that is saved to the AV
   * cloud.
   * @param name {String} The file's name. This will change to a unique value
   *     once the file has finished saving.
   * @param data {Array} The data for the file, as either:
   *     1. an Array of byte value Numbers, or
   *     2. an Object like { base64: "..." } with a base64-encoded String.
   *     3. a File object selected with a file upload control. (3) only works
   *        in Firefox 3.6+, Safari 6.0.2+, Chrome 7+, and IE 10+.
   *        For example:<pre>
   *     4.a Buffer object in Node.js runtime.
   * var fileUploadControl = $("#profilePhotoFileUpload")[0];
   * if (fileUploadControl.files.length > 0) {
   *   var file = fileUploadControl.files[0];
   *   var name = "photo.jpg";
   *   var parseFile = new AV.File(name, file);
   *   parseFile.save().then(function() {
   *     // The file has been saved to AV.
   *   }, function(error) {
   *     // The file either could not be read, or could not be saved to AV.
   *   });
   * }</pre>
   *
   * @class
   * @param type {String} Optional Content-Type header to use for the file. If
   *     this is omitted, the content type will be inferred from the name's
   *     extension.
   */
  AV.File = function(name, data, type) {
    this._name = name;
    var currentUser;
    try {
      currentUser = AV.User.current();
    }
    catch (e) {
      console.warn('Get current user failed. It seems this runtime use an async storage system, please new AV.File in the callback of AV.User.currentAsync().');
    }
    this._metaData = {
       owner: (currentUser != null ? currentUser.id : 'unknown')
    };

    // Guess the content type from the extension if we need to.
    var extension = /\.([^.]*)$/.exec(name);
    if (extension) {
      extension = extension[1].toLowerCase();
    }
    var guessedType = type || mimeTypes[extension] || "text/plain";
    this._guessedType = guessedType;

    if (_.isArray(data)) {
      this._source = AV.Promise.as(encodeBase64(data), guessedType);
      this._metaData.size = data.length;
    } else if (data && data.base64) {
      var parseBase64 = require('./browserify-wrapper/parse-base64');
      var dataBase64 = parseBase64(data.base64, guessedType);
      this._source = AV.Promise.as(dataBase64, guessedType);
    } else if (data && data.blob) {
      this._source = AV.Promise.as(data.blob, guessedType);
    } else if (typeof(File) !== "undefined" && data instanceof File) {
      this._source = AV.Promise.as(data, guessedType);
    } else if(AV._isNode && global.Buffer.isBuffer(data)) {
      // use global.Buffer to prevent browserify pack Buffer module
      this._source = AV.Promise.as(data.toString('base64'), guessedType);
      this._metaData.size = data.length;
    } else if (_.isString(data)) {
      throw "Creating a AV.File from a String is not yet supported.";
    }
  };

  /**
   * Creates a fresh AV.File object with exists url for saving to AVOS Cloud.
   * @param {String} name the file name
   * @param {String} url the file url.
   * @param {Object} metaData the file metadata object,it's optional.
   * @param {String} Optional Content-Type header to use for the file. If
   *     this is omitted, the content type will be inferred from the name's
   *     extension.
   * @return {AV.File} the file object
   */
  AV.File.withURL = function(name, url, metaData, type){
    if(!name || !url){
      throw "Please provide file name and url";
    }
    var file = new AV.File(name, null, type);
    //copy metaData properties to file.
    if(metaData){
      for(var prop in metaData){
        if(!file._metaData[prop])
          file._metaData[prop] = metaData[prop];
      }
    }
    file._url = url;
    //Mark the file is from external source.
    file._metaData['__source'] = 'external';
    return file;
  };

  /**
   * Creates a file object with exists objectId.
   * @param {String} objectId The objectId string
   * @return {AV.File} the file object
   */
  AV.File.createWithoutData = function(objectId){
    var file = new AV.File();
    file.id = objectId;
    return file;
  };

  AV.File.prototype = {

    toJSON: function() {
      return AV._encode(this);
    },

    /**
     * Returns the ACL for this file.
     * @returns {AV.ACL} An instance of AV.ACL.
     */
    getACL: function() {
      return this._acl;
    },

    /**
     * Sets the ACL to be used for this file.
     * @param {AV.ACL} acl An instance of AV.ACL.
     */
    setACL: function(acl) {
        if(!(acl instanceof AV.ACL)) {
          return new AV.Error(AV.Error.OTHER_CAUSE,
                               "ACL must be a AV.ACL.");
        }
        this._acl = acl;
    },

    /**
     * Gets the name of the file. Before save is called, this is the filename
     * given by the user. After save is called, that name gets prefixed with a
     * unique identifier.
     */
    name: function() {
      return this._name;
    },

    /**
     * Gets the url of the file. It is only available after you save the file or
     * after you get the file from a AV.Object.
     * @return {String}
     */
    url: function() {
      return this._url;
    },

    /**
    * <p>Returns the file's metadata JSON object if no arguments is given.Returns the
    * metadata value if a key is given.Set metadata value if key and value are both given.</p>
    * <p><pre>
    *  var metadata = file.metaData(); //Get metadata JSON object.
    *  var size = file.metaData('size');  // Get the size metadata value.
    *  file.metaData('format', 'jpeg'); //set metadata attribute and value.
    *</pre></p>
    * @return {Object} The file's metadata JSON object.
    * @param {String} attr an optional metadata key.
    * @param {Object} value an optional metadata value.
    **/
    metaData: function(attr, value) {
      if(attr != null && value != null){
         this._metaData[attr] = value;
         return this;
      }else if(attr != null){
         return this._metaData[attr];
      }else{
        return this._metaData;
      }
    },

   /**
    * 如果文件是图片，获取图片的缩略图URL。可以传入宽度、高度、质量、格式等参数。
    * @return {String} 缩略图URL
    * @param {Number} width 宽度，单位：像素
    * @param {Number} heigth 高度，单位：像素
    * @param {Number} quality 质量，1-100的数字，默认100
    * @param {Number} scaleToFit 是否将图片自适应大小。默认为true。
    * @param {String} fmt 格式，默认为png，也可以为jpeg,gif等格式。
    */
   thumbnailURL: function(width, height, quality, scaleToFit, fmt){
     if(!this.url()){
       throw "Invalid url.";
     }
     if(!width || !height || width<=0 || height <=0 ){
       throw "Invalid width or height value.";
     }
     quality = quality || 100;
     scaleToFit = (scaleToFit == null) ? true: scaleToFit;
     if(quality<=0 || quality>100){
       throw "Invalid quality value.";
     }
     fmt = fmt || 'png';
     var mode = scaleToFit ? 2: 1;
     return this.url() + '?imageView/' + mode + '/w/' + width + '/h/' + height
       + '/q/' + quality + '/format/' + fmt;
   },

    /**
    * Returns the file's size.
    * @return {Number} The file's size in bytes.
    **/
    size: function(){
      return this.metaData().size;
    },

    /**
     * Returns the file's owner.
     * @return {String} The file's owner id.
     */
    ownerId: function(){
      return this.metaData().owner;
    },
     /**
     * Destroy the file.
     * @return {AV.Promise} A promise that is fulfilled when the destroy
     *     completes.
     */
    destroy: function(options){
      if(!this.id)
        return AV.Promise.error('The file id is not eixsts.')._thenRunCallbacks(options);
      var request = AV._request("files", null, this.id, 'DELETE');
      return request._thenRunCallbacks(options);
    },

    /**
     * Request Qiniu upload token
     * @param {string} type
     * @return {AV.Promise} Resolved with the response
     * @private
     */
    _qiniuToken: function(type) {
      var self = this;
      //Create 16-bits uuid as qiniu key.
      var extName = extname(self._name);
      var hexOctet = function() {
        return Math.floor((1+Math.random())*0x10000).toString(16).substring(1);
      };
      var key = hexOctet() + hexOctet() + hexOctet() + hexOctet() + hexOctet()
          + extName;

      var data = {
        key: key,
        ACL: self._acl,
        name:self._name,
        mime_type: type,
        metaData: self._metaData
      };
      if(type && self._metaData.mime_type == null)
        self._metaData.mime_type = type;
      self._qiniu_key = key;
      return AV._request("qiniu", null, null, 'POST', data);
    },

    /**
     * @callback UploadProgressCallback
     * @param {XMLHttpRequestProgressEvent} event - The progress event with 'loaded' and 'total' attributes
     */
    /**
     * Saves the file to the AV cloud.
     * @param {Object} saveOptions
     * @param {UploadProgressCallback} [saveOptions.onProgress]
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} Promise that is resolved when the save finishes.
     */
    save: function() {
      var options = null;
      var saveOptions = {};
      if(arguments.length === 1) {
        options = arguments[0];
      } else if(arguments.length === 2) {
        saveOptions = arguments[0];
        options = arguments[1];
      }
      var self = this;
      if (!self._previousSave) {
        if(self._source) {
          var upload = require('./browserify-wrapper/upload');
          upload(self, AV, saveOptions);
        } else if(self._url && self._metaData['__source'] == 'external') {
          //external link file.
          var data = {
            name: self._name,
            ACL: self._acl,
            metaData: self._metaData,
            mime_type: self._guessedType,
            url: self._url
          };
          self._previousSave = AV._request("files", self._name, null, 'POST', data).then(function(response) {
            self._name = response.name;
            self._url = response.url;
            self.id = response.objectId;
            if(response.size) {
              self._metaData.size = response.size;
            }
            return self;
          });
        }
      }
      return self._previousSave._thenRunCallbacks(options);
    }
  };

};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/file.js","/../../node_modules/avoscloud-sdk/lib")
},{"./browserify-wrapper/parse-base64":5,"./browserify-wrapper/upload":6,"buffer":35,"oMfpAn":38,"underscore":33}],14:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var _ = require('underscore');

/*global navigator: false */
module.exports = function(AV) {
  /**
   * Creates a new GeoPoint with any of the following forms:<br>
   *   <pre>
   *   new GeoPoint(otherGeoPoint)
   *   new GeoPoint(30, 30)
   *   new GeoPoint([30, 30])
   *   new GeoPoint({latitude: 30, longitude: 30})
   *   new GeoPoint()  // defaults to (0, 0)
   *   </pre>
   * @class
   *
   * <p>Represents a latitude / longitude point that may be associated
   * with a key in a AVObject or used as a reference point for geo queries.
   * This allows proximity-based queries on the key.</p>
   *
   * <p>Only one key in a class may contain a GeoPoint.</p>
   *
   * <p>Example:<pre>
   *   var point = new AV.GeoPoint(30.0, -20.0);
   *   var object = new AV.Object("PlaceObject");
   *   object.set("location", point);
   *   object.save();</pre></p>
   */
  AV.GeoPoint = function(arg1, arg2) {
    if (_.isArray(arg1)) {
      AV.GeoPoint._validate(arg1[0], arg1[1]);
      this.latitude = arg1[0];
      this.longitude = arg1[1];
    } else if (_.isObject(arg1)) {
      AV.GeoPoint._validate(arg1.latitude, arg1.longitude);
      this.latitude = arg1.latitude;
      this.longitude = arg1.longitude;
    } else if (_.isNumber(arg1) && _.isNumber(arg2)) {
      AV.GeoPoint._validate(arg1, arg2);
      this.latitude = arg1;
      this.longitude = arg2;
    } else {
      this.latitude = 0;
      this.longitude = 0;
    }

    // Add properties so that anyone using Webkit or Mozilla will get an error
    // if they try to set values that are out of bounds.
    var self = this;
    if (this.__defineGetter__ && this.__defineSetter__) {
      // Use _latitude and _longitude to actually store the values, and add
      // getters and setters for latitude and longitude.
      this._latitude = this.latitude;
      this._longitude = this.longitude;
      this.__defineGetter__("latitude", function() {
        return self._latitude;
      });
      this.__defineGetter__("longitude", function() {
        return self._longitude;
      });
      this.__defineSetter__("latitude", function(val) {
        AV.GeoPoint._validate(val, self.longitude);
        self._latitude = val;
      });
      this.__defineSetter__("longitude", function(val) {
        AV.GeoPoint._validate(self.latitude, val);
        self._longitude = val;
      });
    }
  };

  /**
   * @lends AV.GeoPoint.prototype
   * @property {float} latitude North-south portion of the coordinate, in range
   *   [-90, 90].  Throws an exception if set out of range in a modern browser.
   * @property {float} longitude East-west portion of the coordinate, in range
   *   [-180, 180].  Throws if set out of range in a modern browser.
   */

  /**
   * Throws an exception if the given lat-long is out of bounds.
   */
  AV.GeoPoint._validate = function(latitude, longitude) {
    if (latitude < -90.0) {
      throw "AV.GeoPoint latitude " + latitude + " < -90.0.";
    }
    if (latitude > 90.0) {
      throw "AV.GeoPoint latitude " + latitude + " > 90.0.";
    }
    if (longitude < -180.0) {
      throw "AV.GeoPoint longitude " + longitude + " < -180.0.";
    }
    if (longitude > 180.0) {
      throw "AV.GeoPoint longitude " + longitude + " > 180.0.";
    }
  };

  /**
   * Creates a GeoPoint with the user's current location, if available.
   * Calls options.success with a new GeoPoint instance or calls options.error.
   * @param {Object} options An object with success and error callbacks.
   */
  AV.GeoPoint.current = function(options) {
    var promise = new AV.Promise();
    navigator.geolocation.getCurrentPosition(function(location) {
      promise.resolve(new AV.GeoPoint({
        latitude: location.coords.latitude,
        longitude: location.coords.longitude
      }));

    }, function(error) {
      promise.reject(error);
    });

    return promise._thenRunCallbacks(options);
  };

  AV.GeoPoint.prototype = {
    /**
     * Returns a JSON representation of the GeoPoint, suitable for AV.
     * @return {Object}
     */
    toJSON: function() {
      AV.GeoPoint._validate(this.latitude, this.longitude);
      return {
        "__type": "GeoPoint",
        latitude: this.latitude,
        longitude: this.longitude
      };
    },

    /**
     * Returns the distance from this GeoPoint to another in radians.
     * @param {AV.GeoPoint} point the other AV.GeoPoint.
     * @return {Number}
     */
    radiansTo: function(point) {
      var d2r = Math.PI / 180.0;
      var lat1rad = this.latitude * d2r;
      var long1rad = this.longitude * d2r;
      var lat2rad = point.latitude * d2r;
      var long2rad = point.longitude * d2r;
      var deltaLat = lat1rad - lat2rad;
      var deltaLong = long1rad - long2rad;
      var sinDeltaLatDiv2 = Math.sin(deltaLat / 2);
      var sinDeltaLongDiv2 = Math.sin(deltaLong / 2);
      // Square of half the straight line chord distance between both points.
      var a = ((sinDeltaLatDiv2 * sinDeltaLatDiv2) +
               (Math.cos(lat1rad) * Math.cos(lat2rad) *
                sinDeltaLongDiv2 * sinDeltaLongDiv2));
      a = Math.min(1.0, a);
      return 2 * Math.asin(Math.sqrt(a));
    },

    /**
     * Returns the distance from this GeoPoint to another in kilometers.
     * @param {AV.GeoPoint} point the other AV.GeoPoint.
     * @return {Number}
     */
    kilometersTo: function(point) {
      return this.radiansTo(point) * 6371.0;
    },

    /**
     * Returns the distance from this GeoPoint to another in miles.
     * @param {AV.GeoPoint} point the other AV.GeoPoint.
     * @return {Number}
     */
    milesTo: function(point) {
      return this.radiansTo(point) * 3958.8;
    }
  };
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/geopoint.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],15:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

/*global _: false, document: false, window: false, navigator: false */
module.exports = function(AV) {
  /**
   * History serves as a global router (per frame) to handle hashchange
   * events or pushState, match the appropriate route, and trigger
   * callbacks. You shouldn't ever have to create one of these yourself
   * — you should use the reference to <code>AV.history</code>
   * that will be created for you automatically if you make use of
   * Routers with routes.
   * @class
   *
   * <p>A fork of Backbone.History, provided for your convenience.  If you
   * use this class, you must also include jQuery, or another library
   * that provides a jQuery-compatible $ function.  For more information,
   * see the <a href="http://documentcloud.github.com/backbone/#History">
   * Backbone documentation</a>.</p>
   * <p><strong><em>Available in the client SDK only.</em></strong></p>
   */
  AV.History = function() {
    console.warn("AV.History is deprecated, please don't use it anymore.");
    this.handlers = [];
    _.bindAll(this, 'checkUrl');
  };

  // Cached regex for cleaning leading hashes and slashes .
  var routeStripper = /^[#\/]/;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Has the history handling already been started?
  AV.History.started = false;

  // Set up all inheritable **AV.History** properties and methods.
  _.extend(AV.History.prototype, AV.Events,
           /** @lends AV.History.prototype */ {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(windowOverride) {
      var loc = windowOverride ? windowOverride.location : window.location;
      var match = loc.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (AV._isNullOrUndefined(fragment)) {
        if (this._hasPushState || forcePushState) {
          fragment = window.location.pathname;
          var search = window.location.search;
          if (search) {
            fragment += search;
          }
        } else {
          fragment = this.getHash();
        }
      }
      if (!fragment.indexOf(this.options.root)) {
        fragment = fragment.substr(this.options.root.length);
      }
      return fragment.replace(routeStripper, '');
    },

    /**
     * Start the hash change handling, returning `true` if the current
     * URL matches an existing route, and `false` otherwise.
     */
    start: function(options) {
      if (AV.History.started) {
        throw new Error("AV.history has already been started");
      }
      AV.History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options = _.extend({}, {root: '/'}, this.options, options);
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState = !!this.options.pushState;
      this._hasPushState = !!(this.options.pushState &&
                              window.history &&
                              window.history.pushState);
      var fragment = this.getFragment();
      var docMode = document.documentMode;
      var oldIE = (isExplorer.exec(navigator.userAgent.toLowerCase()) &&
                   (!docMode || docMode <= 7));

      if (oldIE) {
        this.iframe = AV.$('<iframe src="javascript:0" tabindex="-1" />')
                      .hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        AV.$(window).bind('popstate', this.checkUrl);
      } else if (this._wantsHashChange &&
                 ('onhashchange' in window) &&
                 !oldIE) {
        AV.$(window).bind('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = window.setInterval(this.checkUrl,
                                                    this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = window.location;
      var atRoot  = loc.pathname === this.options.root;

      // If we've started off with a route from a `pushState`-enabled browser,
      // but we're currently in a browser that doesn't support it...
      if (this._wantsHashChange &&
          this._wantsPushState &&
          !this._hasPushState &&
          !atRoot) {
        this.fragment = this.getFragment(null, true);
        window.location.replace(this.options.root + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._wantsPushState &&
                 this._hasPushState &&
                 atRoot &&
                 loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        window.history.replaceState({}, document.title,
            loc.protocol + '//' + loc.host + this.options.root + this.fragment);
      }

      if (!this.options.silent) {
        return this.loadUrl();
      }
    },

    // Disable AV.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      AV.$(window).unbind('popstate', this.checkUrl)
                     .unbind('hashchange', this.checkUrl);
      window.clearInterval(this._checkUrlInterval);
      AV.History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) {
        return false;
      }
      if (this.iframe) {
        this.navigate(current);
      }
      if (!this.loadUrl()) {
        this.loadUrl(this.getHash());
      }
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragmentOverride) {
      var fragment = this.fragment = this.getFragment(fragmentOverride);
      var matched = _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
      return matched;
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the
    // history.
    navigate: function(fragment, options) {
      if (!AV.History.started) {
        return false;
      }
      if (!options || options === true) {
        options = {trigger: options};
      }
      var frag = (fragment || '').replace(routeStripper, '');
      if (this.fragment === frag) {
        return;
      }

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        if (frag.indexOf(this.options.root) !== 0) {
          frag = this.options.root + frag;
        }
        this.fragment = frag;
        var replaceOrPush = options.replace ? 'replaceState' : 'pushState';
        window.history[replaceOrPush]({}, document.title, frag);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this.fragment = frag;
        this._updateHash(window.location, frag, options.replace);
        if (this.iframe &&
            (frag !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier
          // to push a history entry on hash-tag change.
          // When replace is true, we don't want this.
          if (!options.replace) {
            this.iframe.document.open().close();
          }
          this._updateHash(this.iframe.location, frag, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        window.location.assign(this.options.root + fragment);
      }
      if (options.trigger) {
        this.loadUrl(fragment);
      }
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var s = location.toString().replace(/(javascript:|#).*$/, '');
        location.replace(s + '#' + fragment);
      } else {
        location.hash = fragment;
      }
    }
  });
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/history.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],16:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

module.exports = function(AV) {
  /**
   * @namespace 包含了使用了 LeanCloud
   *  <a href='/docs/leaninsight_guide.html'>离线数据分析功能</a>的函数。
   * <p><strong><em>
   *   部分函数仅在云引擎运行环境下有效。
   * </em></strong></p>
   */
  AV.Insight = AV.Insight || {};

  _.extend(AV.Insight, /** @lends AV.Insight */ {

    /**
     * 开始一个 Insight 任务。结果里将返回 Job id，你可以拿得到的 id 使用
     * AV.Insight.JobQuery 查询任务状态和结果。
     * @param {Object} jobConfig 任务配置的 JSON 对象，例如：<code><pre>
     *                   { "sql" : "select count(*) as c,gender from _User group by gender",
     *                     "saveAs": {
     *                         "className" : "UserGender",
     *                         "limit": 1
     *                      }
     *                   }
     *                  </pre></code>
     *               sql 指定任务执行的 SQL 语句， saveAs（可选） 指定将结果保存在哪张表里，limit 最大 1000。
     * @param {Object} options A Backbone-style options object
     * options.success, if set, should be a function to handle a successful
     * call to a cloud function.  options.error should be a function that
     * handles an error running the cloud function.  Both functions are
     * optional.  Both functions take a single argument.
     * @return {AV.Promise} A promise that will be resolved with the result
     * of the function.
     */
    startJob: function(jobConfig, options) {
      if(!jobConfig || !jobConfig.sql) {
        throw new Error('Please provide the sql to run the job.');
      }
      var data = {
        jobConfig: jobConfig,
        appId: AV.applicationId
      };
      var request = AV._request("bigquery", 'jobs', null, 'POST',
                                   AV._encode(data, null, true));

      return request.then(function(resp) {
        return AV._decode(null, resp).id;
      })._thenRunCallbacks(options);
    },

    /**
     * 监听 Insight 任务事件，目前仅支持 end 事件，表示任务完成。
     *  <p><strong><em>
     *     仅在云引擎运行环境下有效。
     *  </em></strong></p>
     * @param {String} event 监听的事件，目前仅支持 'end' ，表示任务完成
     * @param {Function} 监听回调函数，接收 (err, id) 两个参数，err 表示错误信息，
     *                   id 表示任务 id。接下来你可以拿这个 id 使用AV.Insight.JobQuery 查询任务状态和结果。
     *
     */
    on: function(event, cb) {
    }
  });

  /**
   * 创建一个对象，用于查询 Insight 任务状态和结果。
   * @class
   * @param {String} id 任务 id
   * @since 0.5.5
   */
  AV.Insight.JobQuery = function(id, className) {
    if(!id) {
      throw new Error('Please provide the job id.');
    }
    this.id = id;
    this.className = className;
    this._skip = 0;
    this._limit = 100;
  };

  AV.Insight.JobQuery.prototype = {

    /**
     * Sets the number of results to skip before returning any results.
     * This is useful for pagination.
     * Default is to skip zero results.
     * @param {Number} n the number of results to skip.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    skip: function(n) {
      this._skip = n;
      return this;
    },

    /**
     * Sets the limit of the number of results to return. The default limit is
     * 100, with a maximum of 1000 results being returned at a time.
     * @param {Number} n the number of results to limit to.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    limit: function(n) {
      this._limit = n;
      return this;
    },

    /**
     * 查询任务状态和结果，任务结果为一个 JSON 对象，包括 status 表示任务状态， totalCount 表示总数，
     * results 数组表示任务结果数组，previewCount 表示可以返回的结果总数，任务的开始和截止时间
     * startTime、endTime 等信息。
     *
     * @param {Object} options A Backbone-style options object
     * options.success, if set, should be a function to handle a successful
     * call to a cloud function.  options.error should be a function that
     * handles an error running the cloud function.  Both functions are
     * optional.  Both functions take a single argument.
     * @return {AV.Promise} A promise that will be resolved with the result
     * of the function.
     *
     */
    find: function(options) {
      var params = {
        skip: this._skip,
        limit: this._limit
      };

      var request = AV._request("bigquery", 'jobs', this.id, "GET",
                                   params);
      var self = this;
      return request.then(function(response) {
        if(response.error) {
          return AV.Promise.error(new AV.Error(response.code, response.error));
        }
        return AV.Promise.as(response);
      })._thenRunCallbacks(options);
    }

  };

};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/insight.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],17:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');
var Promise = require('./promise');
var localStorage = require('./browserify-wrapper/localStorage');

var syncApiNames = [
  'getItem',
  'setItem',
  'removeItem',
  'clear'
];

if (!localStorage.async) {
  // wrap sync apis with async ones.
  _(syncApiNames).each(function(apiName) {
    if (typeof localStorage[apiName] === 'function') {
      localStorage[apiName + 'Async'] = function() {
        return Promise.as(localStorage[apiName].apply(localStorage, arguments));
      };
    }
  });
} else {
  _(syncApiNames).each(function(apiName) {
    if (typeof localStorage[apiName] !== 'function') {
      localStorage[apiName] = function() {
        throw new Error('Synchronous API [' + apiName + '] is not available in this runtime.');
      };
    }
  });
}

module.exports = localStorage;

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/localstorage.js","/../../node_modules/avoscloud-sdk/lib")
},{"./browserify-wrapper/localStorage":4,"./promise":20,"buffer":35,"oMfpAn":38,"underscore":33}],18:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

// AV.Object is analogous to the Java AVObject.
// It also implements the same interface as a Backbone model.

module.exports = function(AV) {
  /**
   * Creates a new model with defined attributes. A client id (cid) is
   * automatically generated and assigned for you.
   *
   * <p>You won't normally call this method directly.  It is recommended that
   * you use a subclass of <code>AV.Object</code> instead, created by calling
   * <code>extend</code>.</p>
   *
   * <p>However, if you don't want to use a subclass, or aren't sure which
   * subclass is appropriate, you can use this form:<pre>
   *     var object = new AV.Object("ClassName");
   * </pre>
   * That is basically equivalent to:<pre>
   *     var MyClass = AV.Object.extend("ClassName");
   *     var object = new MyClass();
   * </pre></p>
   *
   * @param {Object} attributes The initial set of data to store in the object.
   * @param {Object} options A set of Backbone-like options for creating the
   *     object.  The only option currently supported is "collection".
   * @see AV.Object.extend
   *
   * @class
   *
   * <p>The fundamental unit of AV data, which implements the Backbone Model
   * interface.</p>
   */
  AV.Object = function(attributes, options) {
    // Allow new AV.Object("ClassName") as a shortcut to _create.
    if (_.isString(attributes)) {
      return AV.Object._create.apply(this, arguments);
    }

    attributes = attributes || {};
    if (options && options.parse) {
      attributes = this.parse(attributes);
    }
    var defaults = AV._getValue(this, 'defaults');
    if (defaults) {
      attributes = _.extend({}, defaults, attributes);
    }
    if (options && options.collection) {
      this.collection = options.collection;
    }

    this._serverData = {};  // The last known data for this object from cloud.
    this._opSetQueue = [{}];  // List of sets of changes to the data.
    this.attributes = {};  // The best estimate of this's current data.

    this._hashedJSON = {};  // Hash of values of containers at last save.
    this._escapedAttributes = {};
    this.cid = _.uniqueId('c');
    this.changed = {};
    this._silent = {};
    this._pending = {};
    if (!this.set(attributes, {silent: true})) {
      throw new Error("Can't create an invalid AV.Object");
    }
    this.changed = {};
    this._silent = {};
    this._pending = {};
    this._hasData = true;
    this._previousAttributes = _.clone(this.attributes);
    this.initialize.apply(this, arguments);
  };

  /**
   * @lends AV.Object.prototype
   * @property {String} id The objectId of the AV Object.
   */

  /**
   * Saves the given list of AV.Object.
   * If any error is encountered, stops and calls the error handler.
   * There are two ways you can call this function.
   *
   * The Backbone way:<pre>
   *   AV.Object.saveAll([object1, object2, ...], {
   *     success: function(list) {
   *       // All the objects were saved.
   *     },
   *     error: function(error) {
   *       // An error occurred while saving one of the objects.
   *     },
   *   });
   * </pre>
   * A simplified syntax:<pre>
   *   AV.Object.saveAll([object1, object2, ...], function(list, error) {
   *     if (list) {
   *       // All the objects were saved.
   *     } else {
   *       // An error occurred.
   *     }
   *   });
   * </pre>
   *
   * @param {Array} list A list of <code>AV.Object</code>.
   * @param {Object} options A Backbone-style callback object.
   */
  AV.Object.saveAll = function(list, options) {
    return AV.Object._deepSaveAsync(list)._thenRunCallbacks(options);
  };

  // Attach all inheritable methods to the AV.Object prototype.
  _.extend(AV.Object.prototype, AV.Events,
           /** @lends AV.Object.prototype */ {
    _existed: false,
    _fetchWhenSave: false,

    /**
     * Initialize is an empty function by default. Override it with your own
     * initialization logic.
     */
    initialize: function(){},

   /**
     * Set whether to enable fetchWhenSave option when updating object.
     * When set true, SDK would fetch the latest object after saving.
     * Default is false.
     * @param {boolean} enable  true to enable fetchWhenSave option.
     */
    fetchWhenSave: function(enable){
      if (!_.isBoolean(enable)) {
        throw "Expect boolean value for fetchWhenSave";
      }
      this._fetchWhenSave = enable;
    },

   /**
    * Returns the object's objectId.
    * @return {String} the objectId.
    */
    getObjectId: function() {
      return this.id;
    },

   /**
    * Returns the object's createdAt attribute.
    * @return {Date}
    */
    getCreatedAt: function() {
      return this.createdAt || this.get('createdAt');
    },

   /**
    * Returns the object's updatedAt attribute.
    * @return {Date}
    */
    getUpdatedAt: function() {
      return this.updatedAt || this.get('updatedAt');
    },

    /**
     * Returns a JSON version of the object suitable for saving to AV.
     * @return {Object}
     */
    toJSON: function() {
      var json = this._toFullJSON();
      AV._arrayEach(["__type", "className"],
                       function(key) { delete json[key]; });
      return json;
    },

    _toFullJSON: function(seenObjects) {
      var json = _.clone(this.attributes);
      AV._objectEach(json, function(val, key) {
        json[key] = AV._encode(val, seenObjects);
      });
      AV._objectEach(this._operations, function(val, key) {
        json[key] = val;
      });

      if (_.has(this, "id")) {
        json.objectId = this.id;
      }
      if (_.has(this, "createdAt")) {
        if (_.isDate(this.createdAt)) {
          json.createdAt = this.createdAt.toJSON();
        } else {
          json.createdAt = this.createdAt;
        }
      }

      if (_.has(this, "updatedAt")) {
        if (_.isDate(this.updatedAt)) {
          json.updatedAt = this.updatedAt.toJSON();
        } else {
          json.updatedAt = this.updatedAt;
        }
      }
      json.__type = "Object";
      json.className = this.className;
      return json;
    },

    /**
     * Updates _hashedJSON to reflect the current state of this object.
     * Adds any changed hash values to the set of pending changes.
     */
    _refreshCache: function() {
      var self = this;
      if (self._refreshingCache) {
        return;
      }
      self._refreshingCache = true;
      AV._objectEach(this.attributes, function(value, key) {
        if (value instanceof AV.Object) {
          value._refreshCache();
        } else if (_.isObject(value)) {
          if (self._resetCacheForKey(key)) {
            self.set(key, new AV.Op.Set(value), { silent: true });
          }
        }
      });
      delete self._refreshingCache;
    },

    /**
     * Returns true if this object has been modified since its last
     * save/refresh.  If an attribute is specified, it returns true only if that
     * particular attribute has been modified since the last save/refresh.
     * @param {String} attr An attribute name (optional).
     * @return {Boolean}
     */
    dirty: function(attr) {
      this._refreshCache();

      var currentChanges = _.last(this._opSetQueue);

      if (attr) {
        return (currentChanges[attr] ? true : false);
      }
      if (!this.id) {
        return true;
      }
      if (_.keys(currentChanges).length > 0) {
        return true;
      }
      return false;
    },

    /**
     * Gets a Pointer referencing this Object.
     */
    _toPointer: function() {
      // if (!this.id) {
      //   throw new Error("Can't serialize an unsaved AV.Object");
      // }
      return { __type: "Pointer",
               className: this.className,
               objectId: this.id };
    },

    /**
     * Gets the value of an attribute.
     * @param {String} attr The string name of an attribute.
     */
    get: function(attr) {
      return this.attributes[attr];
    },

    /**
     * Gets a relation on the given class for the attribute.
     * @param String attr The attribute to get the relation for.
     */
    relation: function(attr) {
      var value = this.get(attr);
      if (value) {
        if (!(value instanceof AV.Relation)) {
          throw "Called relation() on non-relation field " + attr;
        }
        value._ensureParentAndKey(this, attr);
        return value;
      } else {
        return new AV.Relation(this, attr);
      }
    },

    /**
     * Gets the HTML-escaped value of an attribute.
     */
    escape: function(attr) {
      var html = this._escapedAttributes[attr];
      if (html) {
        return html;
      }
      var val = this.attributes[attr];
      var escaped;
      if (AV._isNullOrUndefined(val)) {
        escaped = '';
      } else {
        escaped = _.escape(val.toString());
      }
      this._escapedAttributes[attr] = escaped;
      return escaped;
    },

    /**
     * Returns <code>true</code> if the attribute contains a value that is not
     * null or undefined.
     * @param {String} attr The string name of the attribute.
     * @return {Boolean}
     */
    has: function(attr) {
      return !AV._isNullOrUndefined(this.attributes[attr]);
    },

    /**
     * Pulls "special" fields like objectId, createdAt, etc. out of attrs
     * and puts them on "this" directly.  Removes them from attrs.
     * @param attrs - A dictionary with the data for this AV.Object.
     */
    _mergeMagicFields: function(attrs) {
      // Check for changes of magic fields.
      var model = this;
      var specialFields = ["id", "objectId", "createdAt", "updatedAt"];
      AV._arrayEach(specialFields, function(attr) {
        if (attrs[attr]) {
          if (attr === "objectId") {
            model.id = attrs[attr];
          } else if ((attr === "createdAt" || attr === "updatedAt") &&
                     !_.isDate(attrs[attr])) {
            model[attr] = AV._parseDate(attrs[attr]);
          } else {
            model[attr] = attrs[attr];
          }
          delete attrs[attr];
        }
      });
    },

    /**
     * Returns the json to be sent to the server.
     */
    _startSave: function() {
      this._opSetQueue.push({});
    },

    /**
     * Called when a save fails because of an error. Any changes that were part
     * of the save need to be merged with changes made after the save. This
     * might throw an exception is you do conflicting operations. For example,
     * if you do:
     *   object.set("foo", "bar");
     *   object.set("invalid field name", "baz");
     *   object.save();
     *   object.increment("foo");
     * then this will throw when the save fails and the client tries to merge
     * "bar" with the +1.
     */
    _cancelSave: function() {
      var self = this;
      var failedChanges = _.first(this._opSetQueue);
      this._opSetQueue = _.rest(this._opSetQueue);
      var nextChanges = _.first(this._opSetQueue);
      AV._objectEach(failedChanges, function(op, key) {
        var op1 = failedChanges[key];
        var op2 = nextChanges[key];
        if (op1 && op2) {
          nextChanges[key] = op2._mergeWithPrevious(op1);
        } else if (op1) {
          nextChanges[key] = op1;
        }
      });
      this._saving = this._saving - 1;
    },

    /**
     * Called when a save completes successfully. This merges the changes that
     * were saved into the known server data, and overrides it with any data
     * sent directly from the server.
     */
    _finishSave: function(serverData) {
      // Grab a copy of any object referenced by this object. These instances
      // may have already been fetched, and we don't want to lose their data.
      // Note that doing it like this means we will unify separate copies of the
      // same object, but that's a risk we have to take.
      var fetchedObjects = {};
      AV._traverse(this.attributes, function(object) {
        if (object instanceof AV.Object && object.id && object._hasData) {
          fetchedObjects[object.id] = object;
        }
      });

      var savedChanges = _.first(this._opSetQueue);
      this._opSetQueue = _.rest(this._opSetQueue);
      this._applyOpSet(savedChanges, this._serverData);
      this._mergeMagicFields(serverData);
      var self = this;
      AV._objectEach(serverData, function(value, key) {
        self._serverData[key] = AV._decode(key, value);

        // Look for any objects that might have become unfetched and fix them
        // by replacing their values with the previously observed values.
        var fetched = AV._traverse(self._serverData[key], function(object) {
          if (object instanceof AV.Object && fetchedObjects[object.id]) {
            return fetchedObjects[object.id];
          }
        });
        if (fetched) {
          self._serverData[key] = fetched;
        }
      });
      this._rebuildAllEstimatedData();
      this._saving = this._saving - 1;
    },

    /**
     * Called when a fetch or login is complete to set the known server data to
     * the given object.
     */
    _finishFetch: function(serverData, hasData) {
      // Clear out any changes the user might have made previously.
      this._opSetQueue = [{}];

      // Bring in all the new server data.
      this._mergeMagicFields(serverData);
      var self = this;
      AV._objectEach(serverData, function(value, key) {
        self._serverData[key] = AV._decode(key, value);
      });

      // Refresh the attributes.
      this._rebuildAllEstimatedData();

      // Clear out the cache of mutable containers.
      this._refreshCache();
      this._opSetQueue = [{}];

      this._hasData = hasData;
    },

    /**
     * Applies the set of AV.Op in opSet to the object target.
     */
    _applyOpSet: function(opSet, target) {
      var self = this;
      AV._objectEach(opSet, function(change, key) {
        target[key] = change._estimate(target[key], self, key);
        if (target[key] === AV.Op._UNSET) {
          delete target[key];
        }
      });
    },

    /**
     * Replaces the cached value for key with the current value.
     * Returns true if the new value is different than the old value.
     */
    _resetCacheForKey: function(key) {
      var value = this.attributes[key];
      if (_.isObject(value) &&
          !(value instanceof AV.Object) &&
          !(value instanceof AV.File)) {

        value = value.toJSON ? value.toJSON() : value;
        var json = JSON.stringify(value);
        if (this._hashedJSON[key] !== json) {
          var wasSet = !! this._hashedJSON[key];
          this._hashedJSON[key] = json;
          return wasSet;
        }
      }
      return false;
    },

    /**
     * Populates attributes[key] by starting with the last known data from the
     * server, and applying all of the local changes that have been made to that
     * key since then.
     */
    _rebuildEstimatedDataForKey: function(key) {
      var self = this;
      delete this.attributes[key];
      if (this._serverData[key]) {
        this.attributes[key] = this._serverData[key];
      }
      AV._arrayEach(this._opSetQueue, function(opSet) {
        var op = opSet[key];
        if (op) {
          self.attributes[key] = op._estimate(self.attributes[key], self, key);
          if (self.attributes[key] === AV.Op._UNSET) {
            delete self.attributes[key];
          } else {
            self._resetCacheForKey(key);
          }
        }
      });
    },

    /**
     * Populates attributes by starting with the last known data from the
     * server, and applying all of the local changes that have been made since
     * then.
     */
    _rebuildAllEstimatedData: function() {
      var self = this;

      var previousAttributes = _.clone(this.attributes);

      this.attributes = _.clone(this._serverData);
      AV._arrayEach(this._opSetQueue, function(opSet) {
        self._applyOpSet(opSet, self.attributes);
        AV._objectEach(opSet, function(op, key) {
          self._resetCacheForKey(key);
        });
      });

      // Trigger change events for anything that changed because of the fetch.
      AV._objectEach(previousAttributes, function(oldValue, key) {
        if (self.attributes[key] !== oldValue) {
          self.trigger('change:' + key, self, self.attributes[key], {});
        }
      });
      AV._objectEach(this.attributes, function(newValue, key) {
        if (!_.has(previousAttributes, key)) {
          self.trigger('change:' + key, self, newValue, {});
        }
      });
    },

    /**
     * Sets a hash of model attributes on the object, firing
     * <code>"change"</code> unless you choose to silence it.
     *
     * <p>You can call it with an object containing keys and values, or with one
     * key and value.  For example:<pre>
     *   gameTurn.set({
     *     player: player1,
     *     diceRoll: 2
     *   }, {
     *     error: function(gameTurnAgain, error) {
     *       // The set failed validation.
     *     }
     *   });
     *
     *   game.set("currentPlayer", player2, {
     *     error: function(gameTurnAgain, error) {
     *       // The set failed validation.
     *     }
     *   });
     *
     *   game.set("finished", true);</pre></p>
     *
     * @param {String} key The key to set.
     * @param {} value The value to give it.
     * @param {Object} options A set of Backbone-like options for the set.
     *     The only supported options are <code>silent</code>,
     *     <code>error</code>, and <code>promise</code>.
     * @return {Boolean} true if the set succeeded.
     * @see AV.Object#validate
     * @see AV.Error
     */
    set: function(key, value, options) {
      var attrs, attr;
      if (_.isObject(key) || AV._isNullOrUndefined(key)) {
        attrs = key;
        AV._objectEach(attrs, function(v, k) {
          attrs[k] = AV._decode(k, v);
        });
        options = value;
      } else {
        attrs = {};
        attrs[key] = AV._decode(key, value);
      }

      // Extract attributes and options.
      options = options || {};
      if (!attrs) {
        return this;
      }
      if (attrs instanceof AV.Object) {
        attrs = attrs.attributes;
      }

      // If the unset option is used, every attribute should be a Unset.
      if (options.unset) {
        AV._objectEach(attrs, function(unused_value, key) {
          attrs[key] = new AV.Op.Unset();
        });
      }

      // Apply all the attributes to get the estimated values.
      var dataToValidate = _.clone(attrs);
      var self = this;
      AV._objectEach(dataToValidate, function(value, key) {
        if (value instanceof AV.Op) {
          dataToValidate[key] = value._estimate(self.attributes[key],
                                                self, key);
          if (dataToValidate[key] === AV.Op._UNSET) {
            delete dataToValidate[key];
          }
        }
      });

      // Run validation.
      if (!this._validate(attrs, options)) {
        return false;
      }

      this._mergeMagicFields(attrs);

      options.changes = {};
      var escaped = this._escapedAttributes;
      var prev = this._previousAttributes || {};

      // Update attributes.
      AV._arrayEach(_.keys(attrs), function(attr) {
        var val = attrs[attr];

        // If this is a relation object we need to set the parent correctly,
        // since the location where it was parsed does not have access to
        // this object.
        if (val instanceof AV.Relation) {
          val.parent = self;
        }

        if (!(val instanceof AV.Op)) {
          val = new AV.Op.Set(val);
        }

        // See if this change will actually have any effect.
        var isRealChange = true;
        if (val instanceof AV.Op.Set &&
            _.isEqual(self.attributes[attr], val.value)) {
          isRealChange = false;
        }

        if (isRealChange) {
          delete escaped[attr];
          if (options.silent) {
            self._silent[attr] = true;
          } else {
            options.changes[attr] = true;
          }
        }

        var currentChanges = _.last(self._opSetQueue);
        currentChanges[attr] = val._mergeWithPrevious(currentChanges[attr]);
        self._rebuildEstimatedDataForKey(attr);

        if (isRealChange) {
          self.changed[attr] = self.attributes[attr];
          if (!options.silent) {
            self._pending[attr] = true;
          }
        } else {
          delete self.changed[attr];
          delete self._pending[attr];
        }
      });

      if (!options.silent) {
        this.change(options);
      }
      return this;
    },

    /**
     * Remove an attribute from the model, firing <code>"change"</code> unless
     * you choose to silence it. This is a noop if the attribute doesn't
     * exist.
     */
    unset: function(attr, options) {
      options = options || {};
      options.unset = true;
      return this.set(attr, null, options);
    },

    /**
     * Atomically increments the value of the given attribute the next time the
     * object is saved. If no amount is specified, 1 is used by default.
     *
     * @param attr {String} The key.
     * @param amount {Number} The amount to increment by.
     */
    increment: function(attr, amount) {
      if (_.isUndefined(amount) || _.isNull(amount)) {
        amount = 1;
      }
      return this.set(attr, new AV.Op.Increment(amount));
    },

    /**
     * Atomically add an object to the end of the array associated with a given
     * key.
     * @param attr {String} The key.
     * @param item {} The item to add.
     */
    add: function(attr, item) {
      return this.set(attr, new AV.Op.Add([item]));
    },

    /**
     * Atomically add an object to the array associated with a given key, only
     * if it is not already present in the array. The position of the insert is
     * not guaranteed.
     *
     * @param attr {String} The key.
     * @param item {} The object to add.
     */
    addUnique: function(attr, item) {
      return this.set(attr, new AV.Op.AddUnique([item]));
    },

    /**
     * Atomically remove all instances of an object from the array associated
     * with a given key.
     *
     * @param attr {String} The key.
     * @param item {} The object to remove.
     */
    remove: function(attr, item) {
      return this.set(attr, new AV.Op.Remove([item]));
    },

    /**
     * Returns an instance of a subclass of AV.Op describing what kind of
     * modification has been performed on this field since the last time it was
     * saved. For example, after calling object.increment("x"), calling
     * object.op("x") would return an instance of AV.Op.Increment.
     *
     * @param attr {String} The key.
     * @returns {AV.Op} The operation, or undefined if none.
     */
    op: function(attr) {
      return _.last(this._opSetQueue)[attr];
    },

    /**
     * Clear all attributes on the model, firing <code>"change"</code> unless
     * you choose to silence it.
     */
    clear: function(options) {
      options = options || {};
      options.unset = true;
      var keysToClear = _.extend(this.attributes, this._operations);
      return this.set(keysToClear, options);
    },

    /**
     * Returns a JSON-encoded set of operations to be sent with the next save
     * request.
     */
    _getSaveJSON: function() {
      var json = _.clone(_.first(this._opSetQueue));
      AV._objectEach(json, function(op, key) {
        json[key] = op.toJSON();
      });
      return json;
    },

    /**
     * Returns true if this object can be serialized for saving.
     */
    _canBeSerialized: function() {
      return AV.Object._canBeSerializedAsValue(this.attributes);
    },

    /**
     * Fetch the model from the server. If the server's representation of the
     * model differs from its current attributes, they will be overriden,
     * triggering a <code>"change"</code> event.
     * @param {Object} fetchOptions Optional options to set 'keys' and
     *      'include' option.
     * @param {Object} options Optional Backbone-like options object to be
     *     passed in to set.
     * @return {AV.Promise} A promise that is fulfilled when the fetch
     *     completes.
     */
    fetch: function() {
      var options = null;
      var fetchOptions = {};
      if(arguments.length === 1) {
        options = arguments[0];
      } else if(arguments.length === 2) {
        fetchOptions = arguments[0];
        options = arguments[1];
      }

      var self = this;
      var request = AV._request("classes", this.className, this.id, 'GET',
                                fetchOptions);
      return request.then(function(response, status, xhr) {
        self._finishFetch(self.parse(response, status, xhr), true);
        return self;
      })._thenRunCallbacks(options, this);
    },

    /**
     * Set a hash of model attributes, and save the model to the server.
     * updatedAt will be updated when the request returns.
     * You can either call it as:<pre>
     *   object.save();</pre>
     * or<pre>
     *   object.save(null, options);</pre>
     * or<pre>
     *   object.save(attrs, options);</pre>
     * or<pre>
     *   object.save(key, value, options);</pre>
     *
     * For example, <pre>
     *   gameTurn.save({
     *     player: "Jake Cutter",
     *     diceRoll: 2
     *   }, {
     *     success: function(gameTurnAgain) {
     *       // The save was successful.
     *     },
     *     error: function(gameTurnAgain, error) {
     *       // The save failed.  Error is an instance of AV.Error.
     *     }
     *   });</pre>
     * or with promises:<pre>
     *   gameTurn.save({
     *     player: "Jake Cutter",
     *     diceRoll: 2
     *   }).then(function(gameTurnAgain) {
     *     // The save was successful.
     *   }, function(error) {
     *     // The save failed.  Error is an instance of AV.Error.
     *   });</pre>
     *
     * @return {AV.Promise} A promise that is fulfilled when the save
     *     completes.
     * @see AV.Error
     */
    save: function(arg1, arg2, arg3) {
      var i, attrs, current, options, saved;
      if (_.isObject(arg1) || AV._isNullOrUndefined(arg1)) {
        attrs = arg1;
        options = arg2;
      } else {
        attrs = {};
        attrs[arg1] = arg2;
        options = arg3;
      }

      // Make save({ success: function() {} }) work.
      if (!options && attrs) {
        var extra_keys = _.reject(attrs, function(value, key) {
          return _.include(["success", "error", "wait"], key);
        });
        if (extra_keys.length === 0) {
          var all_functions = true;
          if (_.has(attrs, "success") && !_.isFunction(attrs.success)) {
            all_functions = false;
          }
          if (_.has(attrs, "error") && !_.isFunction(attrs.error)) {
            all_functions = false;
          }
          if (all_functions) {
            // This attrs object looks like it's really an options object,
            // and there's no other options object, so let's just use it.
            return this.save(null, attrs);
          }
        }
      }

      options = _.clone(options) || {};
      if (options.wait) {
        current = _.clone(this.attributes);
      }

      var setOptions = _.clone(options) || {};
      if (setOptions.wait) {
        setOptions.silent = true;
      }
      var setError;
      setOptions.error = function(model, error) {
        setError = error;
      };
      if (attrs && !this.set(attrs, setOptions)) {
        return AV.Promise.error(setError)._thenRunCallbacks(options, this);
      }

      var model = this;

      // If there is any unsaved child, save it first.
      model._refreshCache();



      var unsavedChildren = [];
      var unsavedFiles = [];
      AV.Object._findUnsavedChildren(model.attributes,
                                        unsavedChildren,
                                        unsavedFiles);
      if (unsavedChildren.length + unsavedFiles.length > 0) {
        return AV.Object._deepSaveAsync(this.attributes, model).then(function() {
          return model.save(null, options);
        }, function(error) {
          return AV.Promise.error(error)._thenRunCallbacks(options, model);
        });
      }

      this._startSave();
      this._saving = (this._saving || 0) + 1;

      this._allPreviousSaves = this._allPreviousSaves || AV.Promise.as();
      this._allPreviousSaves = this._allPreviousSaves._continueWith(function() {
        var method = model.id ? 'PUT' : 'POST';

        var json = model._getSaveJSON();

        if(model._fetchWhenSave){
          //Sepcial-case fetchWhenSave when updating object.
          json._fetchWhenSave = true;
        }

        var route = "classes";
        var className = model.className;
        if (model.className === "_User" && !model.id) {
          // Special-case user sign-up.
          route = "users";
          className = null;
        }
        //hook makeRequest in options.
        var makeRequest = options._makeRequest || AV._request;
        var request = makeRequest(route, className, model.id, method, json);

        request = request.then(function(resp, status, xhr) {
          var serverAttrs = model.parse(resp, status, xhr);
          if (options.wait) {
            serverAttrs = _.extend(attrs || {}, serverAttrs);
          }
          model._finishSave(serverAttrs);
          if (options.wait) {
            model.set(current, setOptions);
          }
          return model;

        }, function(error) {
          model._cancelSave();
          return AV.Promise.error(error);

        })._thenRunCallbacks(options, model);

        return request;
      });
      return this._allPreviousSaves;
    },

    /**
     * Destroy this model on the server if it was already persisted.
     * Optimistically removes the model from its collection, if it has one.
     * If `wait: true` is passed, waits for the server to respond
     * before removal.
     *
     * @return {AV.Promise} A promise that is fulfilled when the destroy
     *     completes.
     */
    destroy: function(options) {
      options = options || {};
      var model = this;

      var triggerDestroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      if (!this.id) {
        return triggerDestroy();
      }

      if (!options.wait) {
        triggerDestroy();
      }

      var request =
          AV._request("classes", this.className, this.id, 'DELETE');
      return request.then(function() {
        if (options.wait) {
          triggerDestroy();
        }
        return model;
      })._thenRunCallbacks(options, this);
    },

    /**
     * Converts a response into the hash of attributes to be set on the model.
     * @ignore
     */
    parse: function(resp, status, xhr) {
      var output = _.clone(resp);
      _(["createdAt", "updatedAt"]).each(function(key) {
        if (output[key]) {
          output[key] = AV._parseDate(output[key]);
        }
      });
      if (!output.updatedAt) {
        output.updatedAt = output.createdAt;
      }
      if (status) {
        this._existed = (status !== 201);
      }
      return output;
    },

    /**
     * Creates a new model with identical attributes to this one.
     * @return {AV.Object}
     */
    clone: function() {
      return new this.constructor(this.attributes);
    },

    /**
     * Returns true if this object has never been saved to AV.
     * @return {Boolean}
     */
    isNew: function() {
      return !this.id;
    },

    /**
     * Call this method to manually fire a `"change"` event for this model and
     * a `"change:attribute"` event for each changed attribute.
     * Calling this will cause all objects observing the model to update.
     */
    change: function(options) {
      options = options || {};
      var changing = this._changing;
      this._changing = true;

      // Silent changes become pending changes.
      var self = this;
      AV._objectEach(this._silent, function(attr) {
        self._pending[attr] = true;
      });

      // Silent changes are triggered.
      var changes = _.extend({}, options.changes, this._silent);
      this._silent = {};
      AV._objectEach(changes, function(unused_value, attr) {
        self.trigger('change:' + attr, self, self.get(attr), options);
      });
      if (changing) {
        return this;
      }

      // This is to get around lint not letting us make a function in a loop.
      var deleteChanged = function(value, attr) {
        if (!self._pending[attr] && !self._silent[attr]) {
          delete self.changed[attr];
        }
      };

      // Continue firing `"change"` events while there are pending changes.
      while (!_.isEmpty(this._pending)) {
        this._pending = {};
        this.trigger('change', this, options);
        // Pending and silent changes still remain.
        AV._objectEach(this.changed, deleteChanged);
        self._previousAttributes = _.clone(this.attributes);
      }

      this._changing = false;
      return this;
    },

    /**
     * Returns true if this object was created by the AV server when the
     * object might have already been there (e.g. in the case of a Facebook
     * login)
     */
    existed: function() {
      return this._existed;
    },

    /**
     * Determine if the model has changed since the last <code>"change"</code>
     * event.  If you specify an attribute name, determine if that attribute
     * has changed.
     * @param {String} attr Optional attribute name
     * @return {Boolean}
     */
    hasChanged: function(attr) {
      if (!arguments.length) {
        return !_.isEmpty(this.changed);
      }
      return this.changed && _.has(this.changed, attr);
    },

    /**
     * Returns an object containing all the attributes that have changed, or
     * false if there are no changed attributes. Useful for determining what
     * parts of a view need to be updated and/or what attributes need to be
     * persisted to the server. Unset attributes will be set to undefined.
     * You can also pass an attributes object to diff against the model,
     * determining if there *would be* a change.
     */
    changedAttributes: function(diff) {
      if (!diff) {
        return this.hasChanged() ? _.clone(this.changed) : false;
      }
      var changed = {};
      var old = this._previousAttributes;
      AV._objectEach(diff, function(diffVal, attr) {
        if (!_.isEqual(old[attr], diffVal)) {
          changed[attr] = diffVal;
        }
      });
      return changed;
    },

    /**
     * Gets the previous value of an attribute, recorded at the time the last
     * <code>"change"</code> event was fired.
     * @param {String} attr Name of the attribute to get.
     */
    previous: function(attr) {
      if (!arguments.length || !this._previousAttributes) {
        return null;
      }
      return this._previousAttributes[attr];
    },

    /**
     * Gets all of the attributes of the model at the time of the previous
     * <code>"change"</code> event.
     * @return {Object}
     */
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    /**
     * Checks if the model is currently in a valid state. It's only possible to
     * get into an *invalid* state if you're using silent changes.
     * @return {Boolean}
     */
    isValid: function() {
      return !this.validate(this.attributes);
    },

    /**
     * You should not call this function directly unless you subclass
     * <code>AV.Object</code>, in which case you can override this method
     * to provide additional validation on <code>set</code> and
     * <code>save</code>.  Your implementation should return
     *
     * @param {Object} attrs The current data to validate.
     * @param {Object} options A Backbone-like options object.
     * @return {} False if the data is valid.  An error object otherwise.
     * @see AV.Object#set
     */
    validate: function(attrs, options) {
      if (_.has(attrs, "ACL") && !(attrs.ACL instanceof AV.ACL)) {
        return new AV.Error(AV.Error.OTHER_CAUSE,
                               "ACL must be a AV.ACL.");
      }
      return false;
    },

    /**
     * Run validation against a set of incoming attributes, returning `true`
     * if all is well. If a specific `error` callback has been passed,
     * call that instead of firing the general `"error"` event.
     */
    _validate: function(attrs, options) {
      if (options.silent || !this.validate) {
        return true;
      }
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validate(attrs, options);
      if (!error) {
        return true;
      }
      if (options && options.error) {
        options.error(this, error, options);
      } else {
        this.trigger('error', this, error, options);
      }
      return false;
    },

    /**
     * Returns the ACL for this object.
     * @returns {AV.ACL} An instance of AV.ACL.
     * @see AV.Object#get
     */
    getACL: function() {
      return this.get("ACL");
    },

    /**
     * Sets the ACL to be used for this object.
     * @param {AV.ACL} acl An instance of AV.ACL.
     * @param {Object} options Optional Backbone-like options object to be
     *     passed in to set.
     * @return {Boolean} Whether the set passed validation.
     * @see AV.Object#set
     */
    setACL: function(acl, options) {
      return this.set("ACL", acl, options);
    }

  });

   /**
    * Creates an instance of a subclass of AV.Object for the give classname
    * and id.
    * @param  {String} className The name of the AV class backing this model.
    * @param {String} id The object id of this model.
    * @return {AV.Object} A new subclass instance of AV.Object.
    */
   AV.Object.createWithoutData = function(className, id, hasData){
     var result = new AV.Object(className);
     result.id = id;
     result._hasData = hasData;
     return result;
   };
   /**
    * Delete objects in batch.The objects className must be the same.
    * @param {Array} The ParseObject array to be deleted.
    * @param {Object} options Standard options object with success and error
    *     callbacks.
    * @return {AV.Promise} A promise that is fulfilled when the save
    *     completes.
    */
   AV.Object.destroyAll = function(objects, options){
      if(objects == null || objects.length == 0){
		  return AV.Promise.as()._thenRunCallbacks(options);
      }
      var className = objects[0].className;
      var id = "";
      var wasFirst = true;
      objects.forEach(function(obj){
        if(obj.className != className)
			  throw "AV.Object.destroyAll requires the argument object array's classNames must be the same";
          if(!obj.id)
              throw "Could not delete unsaved object";
          if(wasFirst){
              id = obj.id;
              wasFirst = false;
          }else{
              id = id + ',' + obj.id;
          }
      });
      var request =
          AV._request("classes", className, id, 'DELETE');
      return request._thenRunCallbacks(options);
   };

  /**
   * Returns the appropriate subclass for making new instances of the given
   * className string.
   */
  AV.Object._getSubclass = function(className) {
    if (!_.isString(className)) {
      throw "AV.Object._getSubclass requires a string argument.";
    }
    var ObjectClass = AV.Object._classMap[className];
    if (!ObjectClass) {
      ObjectClass = AV.Object.extend(className);
      AV.Object._classMap[className] = ObjectClass;
    }
    return ObjectClass;
  };

  /**
   * Creates an instance of a subclass of AV.Object for the given classname.
   */
  AV.Object._create = function(className, attributes, options) {
    var ObjectClass = AV.Object._getSubclass(className);
    return new ObjectClass(attributes, options);
  };

  // Set up a map of className to class so that we can create new instances of
  // AV Objects from JSON automatically.
  AV.Object._classMap = {};

  AV.Object._extend = AV._extend;

  /**
   * Creates a new model with defined attributes,
   * It's the same with
   * <pre>
   *   new AV.Object(attributes, options);
   *  </pre>
   * @param {Object} attributes The initial set of data to store in the object.
   * @param {Object} options A set of Backbone-like options for creating the
   *     object.  The only option currently supported is "collection".
   * @return {AV.Object}
   * @since v0.4.4
   * @see AV.Object
   * @see AV.Object.extend
   */
  AV.Object.new = function(attributes, options){
    return new AV.Object(attributes, options);
  };

  /**
   * Creates a new subclass of AV.Object for the given AV class name.
   *
   * <p>Every extension of a AV class will inherit from the most recent
   * previous extension of that class. When a AV.Object is automatically
   * created by parsing JSON, it will use the most recent extension of that
   * class.</p>
   *
   * <p>You should call either:<pre>
   *     var MyClass = AV.Object.extend("MyClass", {
   *         <i>Instance properties</i>
   *     }, {
   *         <i>Class properties</i>
   *     });</pre>
   * or, for Backbone compatibility:<pre>
   *     var MyClass = AV.Object.extend({
   *         className: "MyClass",
   *         <i>Other instance properties</i>
   *     }, {
   *         <i>Class properties</i>
   *     });</pre></p>
   *
   * @param {String} className The name of the AV class backing this model.
   * @param {Object} protoProps Instance properties to add to instances of the
   *     class returned from this method.
   * @param {Object} classProps Class properties to add the class returned from
   *     this method.
   * @return {Class} A new subclass of AV.Object.
   */
  AV.Object.extend = function(className, protoProps, classProps) {
    // Handle the case with only two args.
    if (!_.isString(className)) {
      if (className && _.has(className, "className")) {
        return AV.Object.extend(className.className, className, protoProps);
      } else {
        throw new Error(
            "AV.Object.extend's first argument should be the className.");
      }
    }

    // If someone tries to subclass "User", coerce it to the right type.
    if (className === "User") {
      className = "_User";
    }

    var NewClassObject = null;
    if (_.has(AV.Object._classMap, className)) {
      var OldClassObject = AV.Object._classMap[className];
      // This new subclass has been told to extend both from "this" and from
      // OldClassObject. This is multiple inheritance, which isn't supported.
      // For now, let's just pick one.
      NewClassObject = OldClassObject._extend(protoProps, classProps);
    } else {
      protoProps = protoProps || {};
      protoProps.className = className;
      NewClassObject = this._extend(protoProps, classProps);
    }
    // Extending a subclass should reuse the classname automatically.
    NewClassObject.extend = function(arg0) {
      if (_.isString(arg0) || (arg0 && _.has(arg0, "className"))) {
        return AV.Object.extend.apply(NewClassObject, arguments);
      }
      var newArguments = [className].concat(AV._.toArray(arguments));
      return AV.Object.extend.apply(NewClassObject, newArguments);
    };
    NewClassObject.new = function(attributes, options){
      return new NewClassObject(attributes, options);
    };
    AV.Object._classMap[className] = NewClassObject;
    return NewClassObject;
  };

  AV.Object._findUnsavedChildren = function(object, children, files) {
    AV._traverse(object, function(object) {
      if (object instanceof AV.Object) {
        object._refreshCache();
        if (object.dirty()) {
          children.push(object);
        }
        return;
      }

      if (object instanceof AV.File) {
        if (!object.url() && !object.id) {
          files.push(object);
        }
        return;
      }
    });
  };

  AV.Object._canBeSerializedAsValue = function(object) {
    var canBeSerializedAsValue = true;

    if (object instanceof AV.Object || object instanceof AV.File) {
      canBeSerializedAsValue = !!object.id;

    } else if (_.isArray(object)) {
      AV._arrayEach(object, function(child) {
        if (!AV.Object._canBeSerializedAsValue(child)) {
          canBeSerializedAsValue = false;
        }
      });

    } else if (_.isObject(object)) {
      AV._objectEach(object, function(child) {
        if (!AV.Object._canBeSerializedAsValue(child)) {
          canBeSerializedAsValue = false;
        }
      });
    }

    return canBeSerializedAsValue;
  };

  AV.Object._deepSaveAsync = function(object, model) {
    var unsavedChildren = [];
    var unsavedFiles = [];
    AV.Object._findUnsavedChildren(object, unsavedChildren, unsavedFiles);
    if(model) {
      unsavedChildren = _.filter(unsavedChildren, function(object) {
        return object != model;
      });
    }

    var promise = AV.Promise.as();
    _.each(unsavedFiles, function(file) {
      promise = promise.then(function() {
        return file.save();
      });
    });

    var objects = _.uniq(unsavedChildren);
    var remaining = _.uniq(objects);

    return promise.then(function() {
      return AV.Promise._continueWhile(function() {
        return remaining.length > 0;
      }, function() {

        // Gather up all the objects that can be saved in this batch.
        var batch = [];
        var newRemaining = [];
        AV._arrayEach(remaining, function(object) {
          // Limit batches to 20 objects.
          if (batch.length > 20) {
            newRemaining.push(object);
            return;
          }

          if (object._canBeSerialized()) {
            batch.push(object);
          } else {
            newRemaining.push(object);
          }
        });
        remaining = newRemaining;

        // If we can't save any objects, there must be a circular reference.
        if (batch.length === 0) {
          return AV.Promise.error(
            new AV.Error(AV.Error.OTHER_CAUSE,
                            "Tried to save a batch with a cycle."));
        }

        // Reserve a spot in every object's save queue.
        var readyToStart = AV.Promise.when(_.map(batch, function(object) {
          return object._allPreviousSaves || AV.Promise.as();
        }));
        var batchFinished = new AV.Promise();
        AV._arrayEach(batch, function(object) {
          object._allPreviousSaves = batchFinished;
        });

        // Save a single batch, whether previous saves succeeded or failed.
        return readyToStart._continueWith(function() {
          return AV._request("batch", null, null, "POST", {
            requests: _.map(batch, function(object) {
              var json = object._getSaveJSON();
              var method = "POST";

              var path = "/1.1/classes/" + object.className;
              if (object.id) {
                path = path + "/" + object.id;
                method = "PUT";
              }

              object._startSave();

              return {
                method: method,
                path: path,
                body: json
              };
            })

          }).then(function(response, status, xhr) {
            var error;
            AV._arrayEach(batch, function(object, i) {
              if (response[i].success) {
                object._finishSave(
                  object.parse(response[i].success, status, xhr));
              } else {
                error = error || response[i].error;
                object._cancelSave();
              }
            });
            if (error) {
              return AV.Promise.error(
                new AV.Error(error.code, error.error));
            }

          }).then(function(results) {
            batchFinished.resolve(results);
            return results;
          }, function(error) {
            batchFinished.reject(error);
            return AV.Promise.error(error);
          });
        });
      });
    }).then(function() {
      return object;
    });
  };

};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/object.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],19:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var _ = require('underscore');

module.exports = function(AV) {

  /**
   * @class
   * A AV.Op is an atomic operation that can be applied to a field in a
   * AV.Object. For example, calling <code>object.set("foo", "bar")</code>
   * is an example of a AV.Op.Set. Calling <code>object.unset("foo")</code>
   * is a AV.Op.Unset. These operations are stored in a AV.Object and
   * sent to the server as part of <code>object.save()</code> operations.
   * Instances of AV.Op should be immutable.
   *
   * You should not create subclasses of AV.Op or instantiate AV.Op
   * directly.
   */
  AV.Op = function() {
    this._initialize.apply(this, arguments);
  };

  AV.Op.prototype = {
    _initialize: function() {}
  };

  _.extend(AV.Op, {
    /**
     * To create a new Op, call AV.Op._extend();
     */
    _extend: AV._extend,

    // A map of __op string to decoder function.
    _opDecoderMap: {},

    /**
     * Registers a function to convert a json object with an __op field into an
     * instance of a subclass of AV.Op.
     */
    _registerDecoder: function(opName, decoder) {
      AV.Op._opDecoderMap[opName] = decoder;
    },

    /**
     * Converts a json object into an instance of a subclass of AV.Op.
     */
    _decode: function(json) {
      var decoder = AV.Op._opDecoderMap[json.__op];
      if (decoder) {
        return decoder(json);
      } else {
        return undefined;
      }
    }
  });

  /*
   * Add a handler for Batch ops.
   */
  AV.Op._registerDecoder("Batch", function(json) {
    var op = null;
    AV._arrayEach(json.ops, function(nextOp) {
      nextOp = AV.Op._decode(nextOp);
      op = nextOp._mergeWithPrevious(op);
    });
    return op;
  });

  /**
   * @class
   * A Set operation indicates that either the field was changed using
   * AV.Object.set, or it is a mutable container that was detected as being
   * changed.
   */
  AV.Op.Set = AV.Op._extend(/** @lends AV.Op.Set.prototype */ {
    _initialize: function(value) {
      this._value = value;
    },

    /**
     * Returns the new value of this field after the set.
     */
    value: function() {
      return this._value;
    },

    /**
     * Returns a JSON version of the operation suitable for sending to AV.
     * @return {Object}
     */
    toJSON: function() {
      return AV._encode(this.value());
    },

    _mergeWithPrevious: function(previous) {
      return this;
    },

    _estimate: function(oldValue) {
      return this.value();
    }
  });

  /**
   * A sentinel value that is returned by AV.Op.Unset._estimate to
   * indicate the field should be deleted. Basically, if you find _UNSET as a
   * value in your object, you should remove that key.
   */
  AV.Op._UNSET = {};

  /**
   * @class
   * An Unset operation indicates that this field has been deleted from the
   * object.
   */
  AV.Op.Unset = AV.Op._extend(/** @lends AV.Op.Unset.prototype */ {
    /**
     * Returns a JSON version of the operation suitable for sending to AV.
     * @return {Object}
     */
    toJSON: function() {
      return { __op: "Delete" };
    },

    _mergeWithPrevious: function(previous) {
      return this;
    },

    _estimate: function(oldValue) {
      return AV.Op._UNSET;
    }
  });

  AV.Op._registerDecoder("Delete", function(json) {
    return new AV.Op.Unset();
  });

  /**
   * @class
   * An Increment is an atomic operation where the numeric value for the field
   * will be increased by a given amount.
   */
  AV.Op.Increment = AV.Op._extend(
      /** @lends AV.Op.Increment.prototype */ {

    _initialize: function(amount) {
      this._amount = amount;
    },

    /**
     * Returns the amount to increment by.
     * @return {Number} the amount to increment by.
     */
    amount: function() {
      return this._amount;
    },

    /**
     * Returns a JSON version of the operation suitable for sending to AV.
     * @return {Object}
     */
    toJSON: function() {
      return { __op: "Increment", amount: this._amount };
    },

    _mergeWithPrevious: function(previous) {
      if (!previous) {
        return this;
      } else if (previous instanceof AV.Op.Unset) {
        return new AV.Op.Set(this.amount());
      } else if (previous instanceof AV.Op.Set) {
        return new AV.Op.Set(previous.value() + this.amount());
      } else if (previous instanceof AV.Op.Increment) {
        return new AV.Op.Increment(this.amount() + previous.amount());
      } else {
        throw "Op is invalid after previous op.";
      }
    },

    _estimate: function(oldValue) {
      if (!oldValue) {
        return this.amount();
      }
      return oldValue + this.amount();
    }
  });

  AV.Op._registerDecoder("Increment", function(json) {
    return new AV.Op.Increment(json.amount);
  });

  /**
   * @class
   * Add is an atomic operation where the given objects will be appended to the
   * array that is stored in this field.
   */
  AV.Op.Add = AV.Op._extend(/** @lends AV.Op.Add.prototype */ {
    _initialize: function(objects) {
      this._objects = objects;
    },

    /**
     * Returns the objects to be added to the array.
     * @return {Array} The objects to be added to the array.
     */
    objects: function() {
      return this._objects;
    },

    /**
     * Returns a JSON version of the operation suitable for sending to AV.
     * @return {Object}
     */
    toJSON: function() {
      return { __op: "Add", objects: AV._encode(this.objects()) };
    },

    _mergeWithPrevious: function(previous) {
      if (!previous) {
        return this;
      } else if (previous instanceof AV.Op.Unset) {
        return new AV.Op.Set(this.objects());
      } else if (previous instanceof AV.Op.Set) {
        return new AV.Op.Set(this._estimate(previous.value()));
      } else if (previous instanceof AV.Op.Add) {
        return new AV.Op.Add(previous.objects().concat(this.objects()));
      } else {
        throw "Op is invalid after previous op.";
      }
    },

    _estimate: function(oldValue) {
      if (!oldValue) {
        return _.clone(this.objects());
      } else {
        return oldValue.concat(this.objects());
      }
    }
  });

  AV.Op._registerDecoder("Add", function(json) {
    return new AV.Op.Add(AV._decode(undefined, json.objects));
  });

  /**
   * @class
   * AddUnique is an atomic operation where the given items will be appended to
   * the array that is stored in this field only if they were not already
   * present in the array.
   */
  AV.Op.AddUnique = AV.Op._extend(
      /** @lends AV.Op.AddUnique.prototype */ {

    _initialize: function(objects) {
      this._objects = _.uniq(objects);
    },

    /**
     * Returns the objects to be added to the array.
     * @return {Array} The objects to be added to the array.
     */
    objects: function() {
      return this._objects;
    },

    /**
     * Returns a JSON version of the operation suitable for sending to AV.
     * @return {Object}
     */
    toJSON: function() {
      return { __op: "AddUnique", objects: AV._encode(this.objects()) };
    },

    _mergeWithPrevious: function(previous) {
      if (!previous) {
        return this;
      } else if (previous instanceof AV.Op.Unset) {
        return new AV.Op.Set(this.objects());
      } else if (previous instanceof AV.Op.Set) {
        return new AV.Op.Set(this._estimate(previous.value()));
      } else if (previous instanceof AV.Op.AddUnique) {
        return new AV.Op.AddUnique(this._estimate(previous.objects()));
      } else {
        throw "Op is invalid after previous op.";
      }
    },

    _estimate: function(oldValue) {
      if (!oldValue) {
        return _.clone(this.objects());
      } else {
        // We can't just take the _.uniq(_.union(...)) of oldValue and
        // this.objects, because the uniqueness may not apply to oldValue
        // (especially if the oldValue was set via .set())
        var newValue = _.clone(oldValue);
        AV._arrayEach(this.objects(), function(obj) {
          if (obj instanceof AV.Object && obj.id) {
            var matchingObj = _.find(newValue, function(anObj) {
              return (anObj instanceof AV.Object) && (anObj.id === obj.id);
            });
            if (!matchingObj) {
              newValue.push(obj);
            } else {
              var index = _.indexOf(newValue, matchingObj);
              newValue[index] = obj;
            }
          } else if (!_.contains(newValue, obj)) {
            newValue.push(obj);
          }
        });
        return newValue;
      }
    }
  });

  AV.Op._registerDecoder("AddUnique", function(json) {
    return new AV.Op.AddUnique(AV._decode(undefined, json.objects));
  });

  /**
   * @class
   * Remove is an atomic operation where the given objects will be removed from
   * the array that is stored in this field.
   */
  AV.Op.Remove = AV.Op._extend(/** @lends AV.Op.Remove.prototype */ {
    _initialize: function(objects) {
      this._objects = _.uniq(objects);
    },

    /**
     * Returns the objects to be removed from the array.
     * @return {Array} The objects to be removed from the array.
     */
    objects: function() {
      return this._objects;
    },

    /**
     * Returns a JSON version of the operation suitable for sending to AV.
     * @return {Object}
     */
    toJSON: function() {
      return { __op: "Remove", objects: AV._encode(this.objects()) };
    },

    _mergeWithPrevious: function(previous) {
      if (!previous) {
        return this;
      } else if (previous instanceof AV.Op.Unset) {
        return previous;
      } else if (previous instanceof AV.Op.Set) {
        return new AV.Op.Set(this._estimate(previous.value()));
      } else if (previous instanceof AV.Op.Remove) {
        return new AV.Op.Remove(_.union(previous.objects(), this.objects()));
      } else {
        throw "Op is invalid after previous op.";
      }
    },

    _estimate: function(oldValue) {
      if (!oldValue) {
        return [];
      } else {
        var newValue = _.difference(oldValue, this.objects());
        // If there are saved AV Objects being removed, also remove them.
        AV._arrayEach(this.objects(), function(obj) {
          if (obj instanceof AV.Object && obj.id) {
            newValue = _.reject(newValue, function(other) {
              return (other instanceof AV.Object) && (other.id === obj.id);
            });
          }
        });
        return newValue;
      }
    }
  });

  AV.Op._registerDecoder("Remove", function(json) {
    return new AV.Op.Remove(AV._decode(undefined, json.objects));
  });

  /**
   * @class
   * A Relation operation indicates that the field is an instance of
   * AV.Relation, and objects are being added to, or removed from, that
   * relation.
   */
  AV.Op.Relation = AV.Op._extend(
      /** @lends AV.Op.Relation.prototype */ {

    _initialize: function(adds, removes) {
      this._targetClassName = null;

      var self = this;

      var pointerToId = function(object) {
        if (object instanceof AV.Object) {
          if (!object.id) {
            throw "You can't add an unsaved AV.Object to a relation.";
          }
          if (!self._targetClassName) {
            self._targetClassName = object.className;
          }
          if (self._targetClassName !== object.className) {
            throw "Tried to create a AV.Relation with 2 different types: " +
                  self._targetClassName + " and " + object.className + ".";
          }
          return object.id;
        }
        return object;
      };

      this.relationsToAdd = _.uniq(_.map(adds, pointerToId));
      this.relationsToRemove = _.uniq(_.map(removes, pointerToId));
    },

    /**
     * Returns an array of unfetched AV.Object that are being added to the
     * relation.
     * @return {Array}
     */
    added: function() {
      var self = this;
      return _.map(this.relationsToAdd, function(objectId) {
        var object = AV.Object._create(self._targetClassName);
        object.id = objectId;
        return object;
      });
    },

    /**
     * Returns an array of unfetched AV.Object that are being removed from
     * the relation.
     * @return {Array}
     */
    removed: function() {
      var self = this;
      return _.map(this.relationsToRemove, function(objectId) {
        var object = AV.Object._create(self._targetClassName);
        object.id = objectId;
        return object;
      });
    },

    /**
     * Returns a JSON version of the operation suitable for sending to AV.
     * @return {Object}
     */
    toJSON: function() {
      var adds = null;
      var removes = null;
      var self = this;
      var idToPointer = function(id) {
        return { __type: 'Pointer',
                 className: self._targetClassName,
                 objectId: id };
      };
      var pointers = null;
      if (this.relationsToAdd.length > 0) {
        pointers = _.map(this.relationsToAdd, idToPointer);
        adds = { "__op": "AddRelation", "objects": pointers };
      }

      if (this.relationsToRemove.length > 0) {
        pointers = _.map(this.relationsToRemove, idToPointer);
        removes = { "__op": "RemoveRelation", "objects": pointers };
      }

      if (adds && removes) {
        return { "__op": "Batch", "ops": [adds, removes]};
      }

      return adds || removes || {};
    },

    _mergeWithPrevious: function(previous) {
      if (!previous) {
        return this;
      } else if (previous instanceof AV.Op.Unset) {
        throw "You can't modify a relation after deleting it.";
      } else if (previous instanceof AV.Op.Relation) {
        if (previous._targetClassName &&
            previous._targetClassName !== this._targetClassName) {
          throw "Related object must be of class " + previous._targetClassName +
              ", but " + this._targetClassName + " was passed in.";
        }
        var newAdd = _.union(_.difference(previous.relationsToAdd,
                                          this.relationsToRemove),
                             this.relationsToAdd);
        var newRemove = _.union(_.difference(previous.relationsToRemove,
                                             this.relationsToAdd),
                                this.relationsToRemove);

        var newRelation = new AV.Op.Relation(newAdd, newRemove);
        newRelation._targetClassName = this._targetClassName;
        return newRelation;
      } else {
        throw "Op is invalid after previous op.";
      }
    },

    _estimate: function(oldValue, object, key) {
      if (!oldValue) {
        var relation = new AV.Relation(object, key);
        relation.targetClassName = this._targetClassName;
      } else if (oldValue instanceof AV.Relation) {
        if (this._targetClassName) {
          if (oldValue.targetClassName) {
            if (oldValue.targetClassName !== this._targetClassName) {
              throw "Related object must be a " + oldValue.targetClassName +
                  ", but a " + this._targetClassName + " was passed in.";
            }
          } else {
            oldValue.targetClassName = this._targetClassName;
          }
        }
        return oldValue;
      } else {
        throw "Op is invalid after previous op.";
      }
    }
  });

  AV.Op._registerDecoder("AddRelation", function(json) {
    return new AV.Op.Relation(AV._decode(undefined, json.objects), []);
  });
  AV.Op._registerDecoder("RemoveRelation", function(json) {
    return new AV.Op.Relation([], AV._decode(undefined, json.objects));
  });

};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/op.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],20:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var _ = require('underscore');

var Promise = module.exports = function Promise(fn) {
  /**
   * A Promise is returned by async methods as a hook to provide callbacks to be
   * called when the async task is fulfilled.
   *
   * <p>Typical usage would be like:<pre>
   *    query.find().then(function(results) {
   *      results[0].set("foo", "bar");
   *      return results[0].saveAsync();
   *    }).then(function(result) {
   *      console.log("Updated " + result.id);
   *    });
   * </pre></p>
   * <p>Another example:<pre>
   *    var promise = new AV.Promise(function(resolve, reject) {
   *      resolve(42);
   *    });
   *    promise.then(function(value){
   *      console.log(value);
   *    }).catch(function(error){
   *      console.error(error);
   *    });
   * </pre></p>
   * @param {Function} fn An optional function with two arguments resolve
   *                   and reject.The first argument fulfills the promise,
   *                   the second argument rejects it. We can call these
    *                  functions, once our operation is completed.
   * @see AV.Promise.prototype.then
   * @class
   */
    this._resolved = false;
    this._rejected = false;
    this._resolvedCallbacks = [];
    this._rejectedCallbacks = [];

    this.doResolve(fn);
};

var _isNullOrUndefined = function _isNullOrUndefined(x) {
  return _.isNull(x) || _.isUndefined(x);
};

var _isNode = false;

if (typeof(process) !== "undefined" &&
    process.versions &&
    process.versions.node) {
      _isNode = true;
}

_.extend(Promise, /** @lends AV.Promise */ {

  _isPromisesAPlusCompliant: !_isNode,
  _debugError: false,

  setPromisesAPlusCompliant: function(isCompliant) {
    Promise._isPromisesAPlusCompliant = isCompliant;
  },

  setDebugError: function(enable) {
    Promise._debugError = enable;
  },

  /**
   * Returns true iff the given object fulfils the Promise interface.
   * @return {Boolean}
   */
  is: function(promise) {
    return promise && promise.then && _.isFunction(promise.then);
  },

  /**
   * Returns a new promise that is resolved with a given value.
   * @return {AV.Promise} the new promise.
   */
  as: function() {
    var promise = new Promise();
    if (arguments[0] && _.isFunction(arguments[0].then)) {
      arguments[0].then(function(data) {
        promise.resolve.call(promise, data);
      }, function(err) {
        promise.reject.call(promise, err);
      });
    } else {
      promise.resolve.apply(promise, arguments);
    }
    return promise;
  },

  /**
   * Returns a new promise that is rejected with a given error.
   * @return {AV.Promise} the new promise.
   */
  error: function() {
    var promise = new Promise();
    promise.reject.apply(promise, arguments);
    return promise;
  },

  /**
   * Returns a new promise that is fulfilled when all of the input promises
   * are resolved. If any promise in the list fails, then the returned promise
   * will fail with the last error. If they all succeed, then the returned
   * promise will succeed, with the results being the results of all the input
   * promises. For example: <pre>
   *   var p1 = AV.Promise.as(1);
   *   var p2 = AV.Promise.as(2);
   *   var p3 = AV.Promise.as(3);
   *
   *   AV.Promise.when(p1, p2, p3).then(function(r1, r2, r3) {
   *     console.log(r1);  // prints 1
   *     console.log(r2);  // prints 2
   *     console.log(r3);  // prints 3
   *   });</pre>
   *
   * The input promises can also be specified as an array: <pre>
   *   var promises = [p1, p2, p3];
   *   AV.Promise.when(promises).then(function(r1, r2, r3) {
   *     console.log(r1);  // prints 1
   *     console.log(r2);  // prints 2
   *     console.log(r3);  // prints 3
   *   });
   * </pre>
   * @param {Array} promises a list of promises to wait for.
   * @return {AV.Promise} the new promise.
   */
  when: function(promises) {
    // Allow passing in Promises as separate arguments instead of an Array.
    var objects;
    if (promises && _isNullOrUndefined(promises.length)) {
      objects = arguments;
    } else {
      objects = promises;
    }
    var isAll = _.last(arguments);
    isAll = _.isBoolean(isAll) ? isAll : false;

    var total = objects.length;
    var hadError = false;
    var results = [];
    var errors = [];
    results.length = objects.length;
    errors.length = objects.length;

    if (total === 0) {
      if(isAll) {
        return Promise.as.call(this, results);
      } else {
        return Promise.as.apply(this, results);
      }
    }

    var promise = new Promise();

    var resolveOne = function(i) {
      total = total - 1;
      if(hadError && !promise._rejected && isAll) {
        promise.reject.call(promise, errors[i]);
        return;
      }

      if (total === 0) {
        if (hadError && !promise._rejected) {
          promise.reject.call(promise, errors);
        } else {
          if(isAll) {
            if(!promise._rejected) {
              promise.resolve.call(promise, results);
            } else {
              //It's rejected already, so we ignore it.
            }
          } else {
            promise.resolve.apply(promise, results);
          }
        }
      }
    };

    _.each(objects, function(object, i) {
      if (Promise.is(object)) {
        object.then(function(result) {
          results[i] = result;
          resolveOne(i);
        }, function(error) {
          errors[i] = error;
          hadError = true;
          resolveOne(i);
        });
      } else {
        results[i] = object;
        resolveOne(i);
      }
    });

    return promise;
  },

  /**
   * Returns a promise that resolves or rejects as soon as one
   * of the promises in the iterable resolves or rejects, with
   * the value or reason from that promise.Returns a new promise
   * that is fulfilled when one of the input promises.
   * For example: <pre>
   *   var p1 = AV.Promise.as(1);
   *   var p2 = AV.Promise.as(2);
   *   var p3 = AV.Promise.as(3);
   *
   *   AV.Promise.race(p1, p2, p3).then(function(result) {
   *     console.log(result);  // prints 1
   *   });</pre>
   *
   * The input promises can also be specified as an array: <pre>
   *   var promises = [p1, p2, p3];
   *   AV.Promise.when(promises).then(function(result) {
   *     console.log(result);  // prints 1
   *   });
   * </pre>
   * @param {Array} promises a list of promises to wait for.
   * @return {AV.Promise} the new promise.
   */
  race: function(promises) {
    // Allow passing in Promises as separate arguments instead of an Array.
    var objects;
    if (promises && _isNullOrUndefined(promises.length)) {
      objects = arguments;
    } else {
      objects = promises;
    }

    var total = objects.length;
    var hadError = false;
    var results = [];
    var errors = [];

    results.length = errors.length = objects.length;

    if (total === 0) {
      return Promise.as.call(this);
    }

    var promise = new Promise();

    var resolveOne = function(i) {
      if (!promise._resolved && !promise._rejected) {
        if (hadError) {
          promise.reject.call(promise, errors[i]);
        } else {
          promise.resolve.call(promise, results[i]);
        }
      }
    };

    _.each(objects, function(object, i) {
      if (Promise.is(object)) {
        object.then(function(result) {
          results[i] = result;
          resolveOne(i);
        }, function(error) {
          errors[i] = error;
          hadError = true;
          resolveOne(i);
        });
      } else {
        results[i] = object;
        resolveOne(i);
      }
    });

    return promise;
  },

  /**
   * Runs the given asyncFunction repeatedly, as long as the predicate
   * function returns a truthy value. Stops repeating if asyncFunction returns
   * a rejected promise.
   * @param {Function} predicate should return false when ready to stop.
   * @param {Function} asyncFunction should return a Promise.
   */
  _continueWhile: function(predicate, asyncFunction) {
    if (predicate()) {
      return asyncFunction().then(function() {
        return Promise._continueWhile(predicate, asyncFunction);
      });
    }
    return Promise.as();
  }
});

/**
 * Just like AV.Promise.when, but it calls resolveCallbck function
 * with one results array and calls rejectCallback function as soon as any one
 * of the input promises rejects.
 * @see AV.Promise.when
 */
Promise.all = function(promises) {
  return Promise.when(promises, true);
};

_.extend(Promise.prototype, /** @lends AV.Promise.prototype */ {

  /**
   * Marks this promise as fulfilled, firing any callbacks waiting on it.
   * @param {Object} result the result to pass to the callbacks.
   */
  resolve: function(result) {
    if (this._resolved || this._rejected) {
      throw "A promise was resolved even though it had already been " +
        (this._resolved ? "resolved" : "rejected") + ".";
    }
    this._resolved = true;
    this._result = arguments;
    var results = arguments;
    _.each(this._resolvedCallbacks, function(resolvedCallback) {
      resolvedCallback.apply(this, results);
    });
    this._resolvedCallbacks = [];
    this._rejectedCallbacks = [];
  },

  doResolve: function(fn){
    if (!fn) return;
    var done = false;
    var self = this;
    try {
      fn(function (value) {
        if (done) return;
        done = true;
        self.resolve.call(self, value);
      }, function (reason) {
           if (done) return;
           done = true;
           self.reject.call(self, reason);
      });
    } catch (ex) {
      if (done) return;
      done = true;
      self.reject.call(self, ex);
    }
  },

  /**
   * Marks this promise as fulfilled, firing any callbacks waiting on it.
   * @param {Object} error the error to pass to the callbacks.
   */
  reject: function(error) {
    if (this._resolved || this._rejected) {
      throw "A promise was rejected even though it had already been " +
        (this._resolved ? "resolved" : "rejected") + ".";
    }
    this._rejected = true;
    this._error = error;
    _.each(this._rejectedCallbacks, function(rejectedCallback) {
      rejectedCallback(error);
    });
    this._resolvedCallbacks = [];
    this._rejectedCallbacks = [];
  },

  /**
   * Adds callbacks to be called when this promise is fulfilled. Returns a new
   * Promise that will be fulfilled when the callback is complete. It allows
   * chaining. If the callback itself returns a Promise, then the one returned
   * by "then" will not be fulfilled until that one returned by the callback
   * is fulfilled.
   * @param {Function} resolvedCallback Function that is called when this
   * Promise is resolved. Once the callback is complete, then the Promise
   * returned by "then" will also be fulfilled.
   * @param {Function} rejectedCallback Function that is called when this
   * Promise is rejected with an error. Once the callback is complete, then
   * the promise returned by "then" with be resolved successfully. If
   * rejectedCallback is null, or it returns a rejected Promise, then the
   * Promise returned by "then" will be rejected with that error.
   * @return {AV.Promise} A new Promise that will be fulfilled after this
   * Promise is fulfilled and either callback has completed. If the callback
   * returned a Promise, then this Promise will not be fulfilled until that
   * one is.
   */
  then: function(resolvedCallback, rejectedCallback) {
    var promise = new Promise();

    var wrappedResolvedCallback = function() {
      var result = arguments;
      if (resolvedCallback) {
        if (Promise._isPromisesAPlusCompliant) {
          try {
            result = [resolvedCallback.apply(this, result)];
          } catch (e) {
            if(Promise._debugError && e) {
              console.error('Error occurred in promise resolve callback.', e.stack || e);
            }
            result = [Promise.error(e)];
          }
        } else {
          result = [resolvedCallback.apply(this, result)];
        }
      }
      if (result.length === 1 && Promise.is(result[0])) {
        result[0].then(function() {
          promise.resolve.apply(promise, arguments);
        }, function(error) {
          promise.reject(error);
        });
      } else {
        promise.resolve.apply(promise, result);
      }
    };

    var wrappedRejectedCallback = function(error) {
      var result = [];
      if (rejectedCallback) {
        if (Promise._isPromisesAPlusCompliant) {
          try {
            result = [rejectedCallback(error)];
          } catch (e) {
            if(Promise._debugError && e) {
              console.error('Error occurred in promise reject callback.', e.stack || e);
            }
            result = [Promise.error(e)];
          }
        } else {
          result = [rejectedCallback(error)];
        }
        if (result.length === 1 && Promise.is(result[0])) {
          result[0].then(function() {
            promise.resolve.apply(promise, arguments);
          }, function(error) {
            promise.reject(error);
          });
        } else {
          if (Promise._isPromisesAPlusCompliant) {
            promise.resolve.apply(promise, result);
          } else {
            promise.reject(result[0]);
          }
        }
      } else {
        promise.reject(error);
      }
    };

    var runLater = function(func) {
      func.call();
    };
    if (Promise._isPromisesAPlusCompliant) {
      if (typeof(window) !== 'undefined' && _.isFunction(window.setImmediate)) {
        runLater = function(func) {
          window.setImmediate(func);
        };
      } else if (typeof(process) !== 'undefined' && process.nextTick) {
        runLater = function(func) {
           process.nextTick(func);
        };
      } else if (typeof(setTimeout) !== 'undefined' && _.isFunction(setTimeout)) {
        runLater = function(func) {
          setTimeout(func, 0);
        };
      }
    }

    var self = this;
    if (this._resolved) {
      runLater(function() {
        wrappedResolvedCallback.apply(self, self._result);
      });
    } else if (this._rejected) {
      runLater(function() {
        wrappedRejectedCallback.apply(self, [self._error]);
      });
    } else {
      this._resolvedCallbacks.push(wrappedResolvedCallback);
      this._rejectedCallbacks.push(wrappedRejectedCallback);
    }

    return promise;
  },

  /**
   * Add handlers to be called when the Promise object is rejected.
   *
   * @param {Function} rejectedCallback Function that is called when this
   *                   Promise is rejected with an error.
   * @return {AV.Promise} A new Promise that will be fulfilled after this
   *                   Promise is fulfilled and either callback has completed. If the callback
   * returned a Promise, then this Promise will not be fulfilled until that
   *                   one is.
   * @function
   */
  catch: function(onRejected) {
    return this.then(undefined, onRejected);
  },

  /**
   * Add handlers to be called when the promise
   * is either resolved or rejected
   */
  always: function(callback) {
    return this.then(callback, callback);
  },

  /**
   * Add handlers to be called when the Promise object is resolved
   */
  done: function(callback) {
    return this.then(callback);
  },

  /**
   * Add handlers to be called when the Promise object is rejected
   */
  fail: function(callback) {
    return this.then(null, callback);
  },

  /**
   * Run the given callbacks after this promise is fulfilled.
   * @param optionsOrCallback {} A Backbone-style options callback, or a
   * callback function. If this is an options object and contains a "model"
   * attributes, that will be passed to error callbacks as the first argument.
   * @param model {} If truthy, this will be passed as the first result of
   * error callbacks. This is for Backbone-compatability.
   * @return {AV.Promise} A promise that will be resolved after the
   * callbacks are run, with the same result as this.
   */
  _thenRunCallbacks: function(optionsOrCallback, model) {
    var options;
    if (_.isFunction(optionsOrCallback)) {
      var callback = optionsOrCallback;
      options = {
        success: function(result) {
          callback(result, null);
        },
        error: function(error) {
          callback(null, error);
        }
      };
    } else {
      options = _.clone(optionsOrCallback);
    }
    options = options || {};

    return this.then(function(result) {
      if (options.success) {
        options.success.apply(this, arguments);
      } else if (model) {
        // When there's no callback, a sync event should be triggered.
        model.trigger('sync', model, result, options);
      }
      return Promise.as.apply(Promise, arguments);
    }, function(error) {
      if (options.error) {
        if (!_.isUndefined(model)) {
          options.error(model, error);
        } else {
          options.error(error);
        }
      } else if (model) {
        // When there's no error callback, an error event should be triggered.
        model.trigger('error', model, error, options);
      }
      // By explicitly returning a rejected Promise, this will work with
      // either jQuery or Promises/A semantics.
      return Promise.error(error);
    });
  },

  /**
   * Adds a callback function that should be called regardless of whether
   * this promise failed or succeeded. The callback will be given either the
   * array of results for its first argument, or the error as its second,
   * depending on whether this Promise was rejected or resolved. Returns a
   * new Promise, like "then" would.
   * @param {Function} continuation the callback.
   */
  _continueWith: function(continuation) {
    return this.then(function() {
      return continuation(arguments, null);
    }, function(error) {
      return continuation(null, error);
    });
  }

});

/**
 * Alias of AV.Promise.prototype.always
 * @function
 * @see AV.Promise#always
 */
Promise.prototype.finally = Promise.prototype.always;

/**
 * Alias of AV.Promise.prototype.done
 * @function
 * @see AV.Promise#done
 */
Promise.prototype.try = Promise.prototype.done;

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/promise.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],21:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = function(AV) {
  AV.Installation = AV.Object.extend("_Installation");

  /**
   * Contains functions to deal with Push in AV
   * @name AV.Push
   * @namespace
   */
  AV.Push = AV.Push || {};

  /**
   * Sends a push notification.
   * @param {Object} data -  The data of the push notification.  Valid fields
   * are:
   *   <ol>
   *     <li>channels - An Array of channels to push to.</li>
   *     <li>push_time - A Date object for when to send the push.</li>
   *     <li>expiration_time -  A Date object for when to expire
   *         the push.</li>
   *     <li>expiration_interval - The seconds from now to expire the push.</li>
   *     <li>where - A AV.Query over AV.Installation that is used to match
   *         a set of installations to push to.</li>
   *     <li>cql - A CQL statement over AV.Installation that is used to match
   *         a set of installations to push to.</li>
   *     <li>data - The data to send as part of the push</li>
   *   <ol>
   * @param {Object} options An object that has an optional success function,
   * that takes no arguments and will be called on a successful push, and
   * an error function that takes a AV.Error and will be called if the push
   * failed.
   */
  AV.Push.send = function(data, options) {
    if (data.where) {
      data.where = data.where.toJSON().where;
    }

    if(data.where && data.cql){
      throw "Both where and cql can't be set";
    }

    if (data.push_time) {
      data.push_time = data.push_time.toJSON();
    }

    if (data.expiration_time) {
      data.expiration_time = data.expiration_time.toJSON();
    }

    if (data.expiration_time && data.expiration_time_interval) {
      throw "Both expiration_time and expiration_time_interval can't be set";
    }

    var request = AV._request('push', null, null, 'POST', data);
    return request._thenRunCallbacks(options);
  };
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/push.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38}],22:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

// AV.Query is a way to create a list of AV.Objects.
module.exports = function(AV) {
  /**
   * Creates a new avoscloud AV.Query for the given AV.Object subclass.
   * @param objectClass -
   *   An instance of a subclass of AV.Object, or a AV className string.
   * @class
   *
   * <p>AV.Query defines a query that is used to fetch AV.Objects. The
   * most common use case is finding all objects that match a query through the
   * <code>find</code> method. For example, this sample code fetches all objects
   * of class <code>MyClass</code>. It calls a different function depending on
   * whether the fetch succeeded or not.
   *
   * <pre>
   * var query = new AV.Query(MyClass);
   * query.find({
   *   success: function(results) {
   *     // results is an array of AV.Object.
   *   },
   *
   *   error: function(error) {
   *     // error is an instance of AV.Error.
   *   }
   * });</pre></p>
   *
   * <p>A AV.Query can also be used to retrieve a single object whose id is
   * known, through the get method. For example, this sample code fetches an
   * object of class <code>MyClass</code> and id <code>myId</code>. It calls a
   * different function depending on whether the fetch succeeded or not.
   *
   * <pre>
   * var query = new AV.Query(MyClass);
   * query.get(myId, {
   *   success: function(object) {
   *     // object is an instance of AV.Object.
   *   },
   *
   *   error: function(object, error) {
   *     // error is an instance of AV.Error.
   *   }
   * });</pre></p>
   *
   * <p>A AV.Query can also be used to count the number of objects that match
   * the query without retrieving all of those objects. For example, this
   * sample code counts the number of objects of the class <code>MyClass</code>
   * <pre>
   * var query = new AV.Query(MyClass);
   * query.count({
   *   success: function(number) {
   *     // There are number instances of MyClass.
   *   },
   *
   *   error: function(error) {
   *     // error is an instance of AV.Error.
   *   }
   * });</pre></p>
   */
  AV.Query = function(objectClass) {
    if (_.isString(objectClass)) {
      objectClass = AV.Object._getSubclass(objectClass);
    }

    this.objectClass = objectClass;

    this.className = objectClass.prototype.className;

    this._where = {};
    this._include = [];
    this._limit = -1; // negative limit means, do not send a limit
    this._skip = 0;
    this._extraOptions = {};
  };

  /**
   * Constructs a AV.Query that is the OR of the passed in queries.  For
   * example:
   * <pre>var compoundQuery = AV.Query.or(query1, query2, query3);</pre>
   *
   * will create a compoundQuery that is an or of the query1, query2, and
   * query3.
   * @param {...AV.Query} var_args The list of queries to OR.
   * @return {AV.Query} The query that is the OR of the passed in queries.
   */
  AV.Query.or = function() {
    var queries = _.toArray(arguments);
    var className = null;
    AV._arrayEach(queries, function(q) {
      if (_.isNull(className)) {
        className = q.className;
      }

      if (className !== q.className) {
        throw "All queries must be for the same class";
      }
    });
    var query = new AV.Query(className);
    query._orQuery(queries);
    return query;
  };

  /**
   * Constructs a AV.Query that is the AND of the passed in queries.  For
   * example:
   * <pre>var compoundQuery = AV.Query.and(query1, query2, query3);</pre>
   *
   * will create a compoundQuery that is an 'and' of the query1, query2, and
   * query3.
   * @param {...AV.Query} var_args The list of queries to AND.
   * @return {AV.Query} The query that is the AND of the passed in queries.
   */
  AV.Query.and = function() {
    var queries = _.toArray(arguments);
    var className = null;
    AV._arrayEach(queries, function(q) {
      if (_.isNull(className)) {
        className = q.className;
      }

      if (className !== q.className) {
        throw "All queries must be for the same class";
      }
    });
    var query = new AV.Query(className);
    query._andQuery(queries);
    return query;
  };

  /**
   * Retrieves a list of AVObjects that satisfy the CQL.
   * CQL syntax please see <a href='https://cn.avoscloud.com/docs/cql_guide.html'>CQL Guide.</a>
   * Either options.success or options.error is called when the find
   * completes.
   *
   * @param {String} cql,  A CQL string, see <a href='https://cn.avoscloud.com/docs/cql_guide.html'>CQL Guide.</a>
   * @param {Array} pvalues, An array contains placeholder values.
   * @param {Object} options A Backbone-style options object,it's optional.
   * @return {AV.Promise} A promise that is resolved with the results when
   * the query completes,it's optional.
   */
  AV.Query.doCloudQuery = function(cql, pvalues, options) {
    var params = { cql: cql };
    if(_.isArray(pvalues)){
      params.pvalues = pvalues;
    } else {
      options = pvalues;
    }

    var request = AV._request("cloudQuery", null, null, 'GET', params);
    return request.then(function(response) {
      //query to process results.
      var query = new AV.Query(response.className);
      var results = _.map(response.results, function(json) {
        var obj = query._newObject(response);
        obj._finishFetch(query._processResult(json), true);
          return obj;
      });
      return {
        results: results,
        count:  response.count,
        className: response.className
      };
    })._thenRunCallbacks(options);
  };

  AV.Query._extend = AV._extend;

  AV.Query.prototype = {
     //hook to iterate result. Added by dennis<xzhuang@avoscloud.com>.
     _processResult: function(obj){
        return obj;
    },

    /**
     * Constructs a AV.Object whose id is already known by fetching data from
     * the server.  Either options.success or options.error is called when the
     * find completes.
     *
     * @param {} objectId The id of the object to be fetched.
     * @param {Object} options A Backbone-style options object.
     */
    get: function(objectId, options) {
      if(!objectId) {
        var errorObject = new AV.Error(AV.Error.OBJECT_NOT_FOUND,
                                          "Object not found.");
        return AV.Promise.error(errorObject);
      }

      var self = this;
      self.equalTo('objectId', objectId);

      return self.first().then(function(response) {
        if (!AV._.isEmpty(response)) {
          return response;
        }

        var errorObject = new AV.Error(AV.Error.OBJECT_NOT_FOUND,
                                          "Object not found.");
        return AV.Promise.error(errorObject);

      })._thenRunCallbacks(options, null);
    },

    /**
     * Returns a JSON representation of this query.
     * @return {Object}
     */
    toJSON: function() {
      var params = {
        where: this._where
      };

      if (this._include.length > 0) {
        params.include = this._include.join(",");
      }
      if (this._select) {
        params.keys = this._select.join(",");
      }
      if (this._limit >= 0) {
        params.limit = this._limit;
      }
      if (this._skip > 0) {
        params.skip = this._skip;
      }
      if (this._order !== undefined) {
        params.order = this._order;
      }

      AV._objectEach(this._extraOptions, function(v, k) {
        params[k] = v;
      });

      return params;
    },

    _newObject: function(response){
      var obj;
      if (response && response.className) {
        obj = new AV.Object(response.className);
      } else {
        obj = new this.objectClass();
      }
      return obj;
    },
    _createRequest: function(params){
      return AV._request("classes", this.className, null, "GET",
                                   params || this.toJSON());
    },

    /**
     * Retrieves a list of AVObjects that satisfy this query.
     * Either options.success or options.error is called when the find
     * completes.
     *
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is resolved with the results when
     * the query completes.
     */
    find: function(options) {
      var self = this;

      var request = this._createRequest();

      return request.then(function(response) {
        return _.map(response.results, function(json) {
          var obj = self._newObject(response);
          obj._finishFetch(self._processResult(json), true);
          return obj;
        });
      })._thenRunCallbacks(options);
    },

   /**
    * Delete objects retrieved by this query.
    * @param {Object} options Standard options object with success and error
    *     callbacks.
    * @return {AV.Promise} A promise that is fulfilled when the save
    *     completes.
    */
     destroyAll: function(options){
       var self = this;
       return self.find().then(function(objects){
           return AV.Object.destroyAll(objects);
       })._thenRunCallbacks(options);
     },

    /**
     * Counts the number of objects that match this query.
     * Either options.success or options.error is called when the count
     * completes.
     *
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is resolved with the count when
     * the query completes.
     */
    count: function(options) {
      var params = this.toJSON();
      params.limit = 0;
      params.count = 1;
      var request = this._createRequest(params);

      return request.then(function(response) {
        return response.count;
      })._thenRunCallbacks(options);
    },

    /**
     * Retrieves at most one AV.Object that satisfies this query.
     *
     * Either options.success or options.error is called when it completes.
     * success is passed the object if there is one. otherwise, undefined.
     *
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is resolved with the object when
     * the query completes.
     */
    first: function(options) {
      var self = this;

      var params = this.toJSON();
      params.limit = 1;
      var request = this._createRequest(params);

      return request.then(function(response) {
        return _.map(response.results, function(json) {
          var obj = self._newObject();
          obj._finishFetch(self._processResult(json), true);
          return obj;
        })[0];
      })._thenRunCallbacks(options);
    },

    /**
     * Returns a new instance of AV.Collection backed by this query.
     * @return {AV.Collection}
     */
    collection: function(items, options) {
      options = options || {};
      return new AV.Collection(items, _.extend(options, {
        model: this._objectClass || this.objectClass,
        query: this
      }));
    },

    /**
     * Sets the number of results to skip before returning any results.
     * This is useful for pagination.
     * Default is to skip zero results.
     * @param {Number} n the number of results to skip.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    skip: function(n) {
      this._skip = n;
      return this;
    },

    /**
     * Sets the limit of the number of results to return. The default limit is
     * 100, with a maximum of 1000 results being returned at a time.
     * @param {Number} n the number of results to limit to.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    limit: function(n) {
      this._limit = n;
      return this;
    },

    /**
     * Add a constraint to the query that requires a particular key's value to
     * be equal to the provided value.
     * @param {String} key The key to check.
     * @param value The value that the AV.Object must contain.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    equalTo: function(key, value) {
      this._where[key] = AV._encode(value);
      return this;
    },

    /**
     * Helper for condition queries
     */
    _addCondition: function(key, condition, value) {
      // Check if we already have a condition
      if (!this._where[key]) {
        this._where[key] = {};
      }
      this._where[key][condition] = AV._encode(value);
      return this;
    },

    /**
     * Add a constraint to the query that requires a particular
     * <strong>array</strong> key's length to be equal to the provided value.
     * @param {String} key The array key to check.
     * @param value The length value.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    sizeEqualTo: function(key, value) {
      this._addCondition(key, "$size", value);
    },

    /**
     * Add a constraint to the query that requires a particular key's value to
     * be not equal to the provided value.
     * @param {String} key The key to check.
     * @param value The value that must not be equalled.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    notEqualTo: function(key, value) {
      this._addCondition(key, "$ne", value);
      return this;
    },

    /**
     * Add a constraint to the query that requires a particular key's value to
     * be less than the provided value.
     * @param {String} key The key to check.
     * @param value The value that provides an upper bound.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    lessThan: function(key, value) {
      this._addCondition(key, "$lt", value);
      return this;
    },

    /**
     * Add a constraint to the query that requires a particular key's value to
     * be greater than the provided value.
     * @param {String} key The key to check.
     * @param value The value that provides an lower bound.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    greaterThan: function(key, value) {
      this._addCondition(key, "$gt", value);
      return this;
    },

    /**
     * Add a constraint to the query that requires a particular key's value to
     * be less than or equal to the provided value.
     * @param {String} key The key to check.
     * @param value The value that provides an upper bound.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    lessThanOrEqualTo: function(key, value) {
      this._addCondition(key, "$lte", value);
      return this;
    },

    /**
     * Add a constraint to the query that requires a particular key's value to
     * be greater than or equal to the provided value.
     * @param {String} key The key to check.
     * @param value The value that provides an lower bound.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    greaterThanOrEqualTo: function(key, value) {
      this._addCondition(key, "$gte", value);
      return this;
    },

    /**
     * Add a constraint to the query that requires a particular key's value to
     * be contained in the provided list of values.
     * @param {String} key The key to check.
     * @param {Array} values The values that will match.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    containedIn: function(key, values) {
      this._addCondition(key, "$in", values);
      return this;
    },

    /**
     * Add a constraint to the query that requires a particular key's value to
     * not be contained in the provided list of values.
     * @param {String} key The key to check.
     * @param {Array} values The values that will not match.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    notContainedIn: function(key, values) {
      this._addCondition(key, "$nin", values);
      return this;
    },

    /**
     * Add a constraint to the query that requires a particular key's value to
     * contain each one of the provided list of values.
     * @param {String} key The key to check.  This key's value must be an array.
     * @param {Array} values The values that will match.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    containsAll: function(key, values) {
      this._addCondition(key, "$all", values);
      return this;
    },


    /**
     * Add a constraint for finding objects that contain the given key.
     * @param {String} key The key that should exist.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    exists: function(key) {
      this._addCondition(key, "$exists", true);
      return this;
    },

    /**
     * Add a constraint for finding objects that do not contain a given key.
     * @param {String} key The key that should not exist
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    doesNotExist: function(key) {
      this._addCondition(key, "$exists", false);
      return this;
    },

    /**
     * Add a regular expression constraint for finding string values that match
     * the provided regular expression.
     * This may be slow for large datasets.
     * @param {String} key The key that the string to match is stored in.
     * @param {RegExp} regex The regular expression pattern to match.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    matches: function(key, regex, modifiers) {
      this._addCondition(key, "$regex", regex);
      if (!modifiers) { modifiers = ""; }
      // Javascript regex options support mig as inline options but store them
      // as properties of the object. We support mi & should migrate them to
      // modifiers
      if (regex.ignoreCase) { modifiers += 'i'; }
      if (regex.multiline) { modifiers += 'm'; }

      if (modifiers && modifiers.length) {
        this._addCondition(key, "$options", modifiers);
      }
      return this;
    },

    /**
     * Add a constraint that requires that a key's value matches a AV.Query
     * constraint.
     * @param {String} key The key that the contains the object to match the
     *                     query.
     * @param {AV.Query} query The query that should match.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    matchesQuery: function(key, query) {
      var queryJSON = query.toJSON();
      queryJSON.className = query.className;
      this._addCondition(key, "$inQuery", queryJSON);
      return this;
    },

   /**
     * Add a constraint that requires that a key's value not matches a
     * AV.Query constraint.
     * @param {String} key The key that the contains the object to match the
     *                     query.
     * @param {AV.Query} query The query that should not match.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    doesNotMatchQuery: function(key, query) {
      var queryJSON = query.toJSON();
      queryJSON.className = query.className;
      this._addCondition(key, "$notInQuery", queryJSON);
      return this;
    },


    /**
     * Add a constraint that requires that a key's value matches a value in
     * an object returned by a different AV.Query.
     * @param {String} key The key that contains the value that is being
     *                     matched.
     * @param {String} queryKey The key in the objects returned by the query to
     *                          match against.
     * @param {AV.Query} query The query to run.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    matchesKeyInQuery: function(key, queryKey, query) {
      var queryJSON = query.toJSON();
      queryJSON.className = query.className;
      this._addCondition(key, "$select",
                         { key: queryKey, query: queryJSON });
      return this;
    },

    /**
     * Add a constraint that requires that a key's value not match a value in
     * an object returned by a different AV.Query.
     * @param {String} key The key that contains the value that is being
     *                     excluded.
     * @param {String} queryKey The key in the objects returned by the query to
     *                          match against.
     * @param {AV.Query} query The query to run.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    doesNotMatchKeyInQuery: function(key, queryKey, query) {
      var queryJSON = query.toJSON();
      queryJSON.className = query.className;
      this._addCondition(key, "$dontSelect",
                         { key: queryKey, query: queryJSON });
      return this;
    },

    /**
     * Add constraint that at least one of the passed in queries matches.
     * @param {Array} queries
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    _orQuery: function(queries) {
      var queryJSON = _.map(queries, function(q) {
        return q.toJSON().where;
      });

      this._where.$or = queryJSON;
      return this;
    },

    /**
     * Add constraint that both of the passed in queries matches.
     * @param {Array} queries
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    _andQuery: function(queries) {
      var queryJSON = _.map(queries, function(q) {
        return q.toJSON().where;
      });

      this._where.$and = queryJSON;
      return this;
    },


    /**
     * Converts a string into a regex that matches it.
     * Surrounding with \Q .. \E does this, we just need to escape \E's in
     * the text separately.
     */
    _quote: function(s) {
      return "\\Q" + s.replace("\\E", "\\E\\\\E\\Q") + "\\E";
    },

    /**
     * Add a constraint for finding string values that contain a provided
     * string.  This may be slow for large datasets.
     * @param {String} key The key that the string to match is stored in.
     * @param {String} substring The substring that the value must contain.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    contains: function(key, value) {
      this._addCondition(key, "$regex", this._quote(value));
      return this;
    },

    /**
     * Add a constraint for finding string values that start with a provided
     * string.  This query will use the backend index, so it will be fast even
     * for large datasets.
     * @param {String} key The key that the string to match is stored in.
     * @param {String} prefix The substring that the value must start with.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    startsWith: function(key, value) {
      this._addCondition(key, "$regex", "^" + this._quote(value));
      return this;
    },

    /**
     * Add a constraint for finding string values that end with a provided
     * string.  This will be slow for large datasets.
     * @param {String} key The key that the string to match is stored in.
     * @param {String} suffix The substring that the value must end with.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    endsWith: function(key, value) {
      this._addCondition(key, "$regex", this._quote(value) + "$");
      return this;
    },

    /**
     * Sorts the results in ascending order by the given key.
     *
     * @param {String} key The key to order by.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    ascending: function(key) {
      this._order = key;
      return this;
    },

  /**
   * Also sorts the results in ascending order by the given key. The previous sort keys have
   * precedence over this key.
   *
   * @param {String} key The key to order by
   * @return {AV.Query} Returns the query so you can chain this call.
   */
   addAscending: function(key){
     if(this._order)
       this._order +=  ','  + key;
    else
       this._order = key;
    return this;
   },

    /**
     * Sorts the results in descending order by the given key.
     *
     * @param {String} key The key to order by.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    descending: function(key) {
      this._order = "-" + key;
      return this;
    },

     /**
   * Also sorts the results in descending order by the given key. The previous sort keys have
   * precedence over this key.
   *
   * @param {String} key The key to order by
   * @return {AV.Query} Returns the query so you can chain this call.
   */
   addDescending: function(key){
     if(this._order)
       this._order += ',-' + key;
     else
       this._order = '-' + key;
     return key;
   },

    /**
     * Add a proximity based constraint for finding objects with key point
     * values near the point given.
     * @param {String} key The key that the AV.GeoPoint is stored in.
     * @param {AV.GeoPoint} point The reference AV.GeoPoint that is used.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    near: function(key, point) {
      if (!(point instanceof AV.GeoPoint)) {
        // Try to cast it to a GeoPoint, so that near("loc", [20,30]) works.
        point = new AV.GeoPoint(point);
      }
      this._addCondition(key, "$nearSphere", point);
      return this;
    },

    /**
     * Add a proximity based constraint for finding objects with key point
     * values near the point given and within the maximum distance given.
     * @param {String} key The key that the AV.GeoPoint is stored in.
     * @param {AV.GeoPoint} point The reference AV.GeoPoint that is used.
     * @param maxDistance Maximum distance (in radians) of results to return.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    withinRadians: function(key, point, distance) {
      this.near(key, point);
      this._addCondition(key, "$maxDistance", distance);
      return this;
    },

    /**
     * Add a proximity based constraint for finding objects with key point
     * values near the point given and within the maximum distance given.
     * Radius of earth used is 3958.8 miles.
     * @param {String} key The key that the AV.GeoPoint is stored in.
     * @param {AV.GeoPoint} point The reference AV.GeoPoint that is used.
     * @param {Number} maxDistance Maximum distance (in miles) of results to
     *     return.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    withinMiles: function(key, point, distance) {
      return this.withinRadians(key, point, distance / 3958.8);
    },

    /**
     * Add a proximity based constraint for finding objects with key point
     * values near the point given and within the maximum distance given.
     * Radius of earth used is 6371.0 kilometers.
     * @param {String} key The key that the AV.GeoPoint is stored in.
     * @param {AV.GeoPoint} point The reference AV.GeoPoint that is used.
     * @param {Number} maxDistance Maximum distance (in kilometers) of results
     *     to return.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    withinKilometers: function(key, point, distance) {
      return this.withinRadians(key, point, distance / 6371.0);
    },

    /**
     * Add a constraint to the query that requires a particular key's
     * coordinates be contained within a given rectangular geographic bounding
     * box.
     * @param {String} key The key to be constrained.
     * @param {AV.GeoPoint} southwest
     *     The lower-left inclusive corner of the box.
     * @param {AV.GeoPoint} northeast
     *     The upper-right inclusive corner of the box.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    withinGeoBox: function(key, southwest, northeast) {
      if (!(southwest instanceof AV.GeoPoint)) {
        southwest = new AV.GeoPoint(southwest);
      }
      if (!(northeast instanceof AV.GeoPoint)) {
        northeast = new AV.GeoPoint(northeast);
      }
      this._addCondition(key, '$within', { '$box': [southwest, northeast] });
      return this;
    },

    /**
     * Include nested AV.Objects for the provided key.  You can use dot
     * notation to specify which fields in the included object are also fetch.
     * @param {String} key The name of the key to include.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    include: function() {
      var self = this;
      AV._arrayEach(arguments, function(key) {
        if (_.isArray(key)) {
          self._include = self._include.concat(key);
        } else {
          self._include.push(key);
        }
      });
      return this;
    },

    /**
     * Restrict the fields of the returned AV.Objects to include only the
     * provided keys.  If this is called multiple times, then all of the keys
     * specified in each of the calls will be included.
     * @param {Array} keys The names of the keys to include.
     * @return {AV.Query} Returns the query, so you can chain this call.
     */
    select: function() {
      var self = this;
      this._select = this._select || [];
      AV._arrayEach(arguments, function(key) {
        if (_.isArray(key)) {
          self._select = self._select.concat(key);
        } else {
          self._select.push(key);
        }
      });
      return this;
    },

    /**
     * Iterates over each result of a query, calling a callback for each one. If
     * the callback returns a promise, the iteration will not continue until
     * that promise has been fulfilled. If the callback returns a rejected
     * promise, then iteration will stop with that error. The items are
     * processed in an unspecified order. The query may not have any sort order,
     * and may not use limit or skip.
     * @param callback {Function} Callback that will be called with each result
     *     of the query.
     * @param options {Object} An optional Backbone-like options object with
     *     success and error callbacks that will be invoked once the iteration
     *     has finished.
     * @return {AV.Promise} A promise that will be fulfilled once the
     *     iteration has completed.
     */
    each: function(callback, options) {
      options = options || {};

      if (this._order || this._skip || (this._limit >= 0)) {
        var error =
          "Cannot iterate on a query with sort, skip, or limit.";
        return AV.Promise.error(error)._thenRunCallbacks(options);
      }

      var promise = new AV.Promise();

      var query = new AV.Query(this.objectClass);
      // We can override the batch size from the options.
      // This is undocumented, but useful for testing.
      query._limit = options.batchSize || 100;
      query._where = _.clone(this._where);
      query._include = _.clone(this._include);

      query.ascending('objectId');

      var finished = false;
      return AV.Promise._continueWhile(function() {
        return !finished;

      }, function() {
        return query.find().then(function(results) {
          var callbacksDone = AV.Promise.as();
          AV._.each(results, function(result) {
            callbacksDone = callbacksDone.then(function() {
              return callback(result);
            });
          });

          return callbacksDone.then(function() {
            if (results.length >= query._limit) {
              query.greaterThan("objectId", results[results.length - 1].id);
            } else {
              finished = true;
            }
          });
        });
      })._thenRunCallbacks(options);
    }
  };

   AV.FriendShipQuery = AV.Query._extend({
     _objectClass: AV.User,
     _newObject: function(){
      return new AV.User();
    },
     _processResult: function(json){
       if(json && json[this._friendshipTag]) {
         var user = json[this._friendshipTag];
         if(user.__type === 'Pointer' && user.className === '_User'){
           delete user.__type;
           delete user.className;
          }
          return user;
       } else {
         return null;
       }
    },
   });
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/query.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],23:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';
var _ = require('underscore');

module.exports = function(AV) {
  /**
   * Creates a new Relation for the given parent object and key. This
   * constructor should rarely be used directly, but rather created by
   * AV.Object.relation.
   * @param {AV.Object} parent The parent of this relation.
   * @param {String} key The key for this relation on the parent.
   * @see AV.Object#relation
   * @class
   *
   * <p>
   * A class that is used to access all of the children of a many-to-many
   * relationship.  Each instance of AV.Relation is associated with a
   * particular parent object and key.
   * </p>
   */
  AV.Relation = function(parent, key) {
    if (! _.isString(key)) {
      throw new TypeError('key must be a string');
    }
    this.parent = parent;
    this.key = key;
    this.targetClassName = null;
  };

  /**
   * Creates a query that can be used to query the parent objects in this relation.
   * @param {String} parentClass The parent class or name.
   * @param {String} relationKey The relation field key in parent.
   * @param {AV.Object} child The child object.
   * @return {AV.Query}
   */
  AV.Relation.reverseQuery = function(parentClass, relationKey, child){
    var query = new AV.Query(parentClass);
    query.equalTo(relationKey, child._toPointer());
    return query;
  };

  AV.Relation.prototype = {
    /**
     * Makes sure that this relation has the right parent and key.
     */
    _ensureParentAndKey: function(parent, key) {
      this.parent = this.parent || parent;
      this.key = this.key || key;
      if (this.parent !== parent) {
        throw "Internal Error. Relation retrieved from two different Objects.";
      }
      if (this.key !== key) {
        throw "Internal Error. Relation retrieved from two different keys.";
      }
    },

    /**
     * Adds a AV.Object or an array of AV.Objects to the relation.
     * @param {} objects The item or items to add.
     */
    add: function(objects) {
      if (!_.isArray(objects)) {
        objects = [objects];
      }

      var change = new AV.Op.Relation(objects, []);
      this.parent.set(this.key, change);
      this.targetClassName = change._targetClassName;
    },

    /**
     * Removes a AV.Object or an array of AV.Objects from this relation.
     * @param {} objects The item or items to remove.
     */
    remove: function(objects) {
      if (!_.isArray(objects)) {
        objects = [objects];
      }

      var change = new AV.Op.Relation([], objects);
      this.parent.set(this.key, change);
      this.targetClassName = change._targetClassName;
    },

    /**
     * Returns a JSON version of the object suitable for saving to disk.
     * @return {Object}
     */
    toJSON: function() {
      return { "__type": "Relation", "className": this.targetClassName };
    },

    /**
     * Returns a AV.Query that is limited to objects in this
     * relation.
     * @return {AV.Query}
     */
    query: function() {
      var targetClass;
      var query;
      if (!this.targetClassName) {
        targetClass = AV.Object._getSubclass(this.parent.className);
        query = new AV.Query(targetClass);
        query._extraOptions.redirectClassNameForKey = this.key;
      } else {
        targetClass = AV.Object._getSubclass(this.targetClassName);
        query = new AV.Query(targetClass);
      }
      query._addCondition("$relatedTo", "object", this.parent._toPointer());
      query._addCondition("$relatedTo", "key", this.key);

      return query;
    }
  };
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/relation.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],24:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

module.exports = function(AV) {
  /**
   * Represents a Role on the AV server. Roles represent groupings of
   * Users for the purposes of granting permissions (e.g. specifying an ACL
   * for an Object). Roles are specified by their sets of child users and
   * child roles, all of which are granted any permissions that the parent
   * role has.
   *
   * <p>Roles must have a name (which cannot be changed after creation of the
   * role), and must specify an ACL.</p>
   * @class
   * A AV.Role is a local representation of a role persisted to the AV
   * cloud.
   */
  AV.Role = AV.Object.extend("_Role", /** @lends AV.Role.prototype */ {
    // Instance Methods

    /**
     * Constructs a new AVRole with the given name and ACL.
     *
     * @param {String} name The name of the Role to create.
     * @param {AV.ACL} [acl] The ACL for this role. if absent, the default ACL
     *    `{'*': { read: true }}` will be used.
     */
    constructor: function(name, acl) {
      if (_.isString(name)) {
        AV.Object.prototype.constructor.call(this, null, null);
        this.setName(name);
      } else {
        AV.Object.prototype.constructor.call(this, name, acl);
      }
      if (acl === undefined) {
        var defaultAcl = new AV.ACL();
        defaultAcl.setPublicReadAccess(true);
        if(!this.getACL()) {
          this.setACL(defaultAcl);
        }
      } else if (!(acl instanceof AV.ACL)) {
        throw new TypeError('acl must be an instance of AV.ACL');
      } else {
        this.setACL(acl);
      }
    },

    /**
     * Gets the name of the role.  You can alternatively call role.get("name")
     *
     * @return {String} the name of the role.
     */
    getName: function() {
      return this.get("name");
    },

    /**
     * Sets the name for a role. This value must be set before the role has
     * been saved to the server, and cannot be set once the role has been
     * saved.
     *
     * <p>
     *   A role's name can only contain alphanumeric characters, _, -, and
     *   spaces.
     * </p>
     *
     * <p>This is equivalent to calling role.set("name", name)</p>
     *
     * @param {String} name The name of the role.
     * @param {Object} options Standard options object with success and error
     *     callbacks.
     */
    setName: function(name, options) {
      return this.set("name", name, options);
    },

    /**
     * Gets the AV.Relation for the AV.Users that are direct
     * children of this role. These users are granted any privileges that this
     * role has been granted (e.g. read or write access through ACLs). You can
     * add or remove users from the role through this relation.
     *
     * <p>This is equivalent to calling role.relation("users")</p>
     *
     * @return {AV.Relation} the relation for the users belonging to this
     *     role.
     */
    getUsers: function() {
      return this.relation("users");
    },

    /**
     * Gets the AV.Relation for the AV.Roles that are direct
     * children of this role. These roles' users are granted any privileges that
     * this role has been granted (e.g. read or write access through ACLs). You
     * can add or remove child roles from this role through this relation.
     *
     * <p>This is equivalent to calling role.relation("roles")</p>
     *
     * @return {AV.Relation} the relation for the roles belonging to this
     *     role.
     */
    getRoles: function() {
      return this.relation("roles");
    },

    /**
     * @ignore
     */
    validate: function(attrs, options) {
      if ("name" in attrs && attrs.name !== this.getName()) {
        var newName = attrs.name;
        if (this.id && this.id !== attrs.objectId) {
          // Check to see if the objectId being set matches this.id.
          // This happens during a fetch -- the id is set before calling fetch.
          // Let the name be set in this case.
          return new AV.Error(AV.Error.OTHER_CAUSE,
              "A role's name can only be set before it has been saved.");
        }
        if (!_.isString(newName)) {
          return new AV.Error(AV.Error.OTHER_CAUSE,
              "A role's name must be a String.");
        }
        if (!(/^[0-9a-zA-Z\-_ ]+$/).test(newName)) {
          return new AV.Error(AV.Error.OTHER_CAUSE,
              "A role's name can only contain alphanumeric characters, _," +
              " -, and spaces.");
        }
      }
      if (AV.Object.prototype.validate) {
        return AV.Object.prototype.validate.call(this, attrs, options);
      }
      return false;
    }
  });
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/role.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],25:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

/*global _: false*/
module.exports = function(AV) {
  /**
   * Routers map faux-URLs to actions, and fire events when routes are
   * matched. Creating a new one sets its `routes` hash, if not set statically.
   * @class
   *
   * <p>A fork of Backbone.Router, provided for your convenience.
   * For more information, see the
   * <a href="http://documentcloud.github.com/backbone/#Router">Backbone
   * documentation</a>.</p>
   * <p><strong><em>Available in the client SDK only.</em></strong></p>
   */
  AV.Router = function(options) {
    console.warn("AV.Router is deprecated, please don't use it anymore.");
    options = options || {};
    if (options.routes) {
      this.routes = options.routes;
    }
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var namedParam    = /:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-\[\]{}()+?.,\\\^\$\|#\s]/g;

  // Set up all inheritable **AV.Router** properties and methods.
  _.extend(AV.Router.prototype, AV.Events,
           /** @lends AV.Router.prototype */ {

    /**
     * Initialize is an empty function by default. Override it with your own
     * initialization logic.
     */
    initialize: function(){},

    /**
     * Manually bind a single named route to a callback. For example:
     *
     * <pre>this.route('search/:query/p:num', 'search', function(query, num) {
     *       ...
     *     });</pre>
     */
    route: function(route, name, callback) {
      AV.history = AV.history || new AV.History();
      if (!_.isRegExp(route)) {
        route = this._routeToRegExp(route);
      }
      if (!callback) {
        callback = this[name];
      }
      AV.history.route(route, _.bind(function(fragment) {
        var args = this._extractParameters(route, fragment);
        if (callback) {
          callback.apply(this, args);
        }
        this.trigger.apply(this, ['route:' + name].concat(args));
        AV.history.trigger('route', this, name, args);
      }, this));
      return this;
    },

    /**
     * Whenever you reach a point in your application that you'd
     * like to save as a URL, call navigate in order to update the
     * URL. If you wish to also call the route function, set the
     * trigger option to true. To update the URL without creating
     * an entry in the browser's history, set the replace option
     * to true.
     */
    navigate: function(fragment, options) {
      AV.history.navigate(fragment, options);
    },

    // Bind all defined routes to `AV.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) {
        return;
      }
      var routes = [];
      for (var route in this.routes) {
        if (this.routes.hasOwnProperty(route)) {
          routes.unshift([route, this.routes[route]]);
        }
      }
      for (var i = 0, l = routes.length; i < l; i++) {
        this.route(routes[i][0], routes[i][1], this[routes[i][1]]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(namedParam, '([^\/]+)')
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted parameters.
    _extractParameters: function(route, fragment) {
      return route.exec(fragment).slice(1);
    }
  });

  /**
   * @function
   * @param {Object} instanceProps Instance properties for the router.
   * @param {Object} classProps Class properies for the router.
   * @return {Class} A new subclass of <code>AV.Router</code>.
   */
  AV.Router.extend = AV._extend;
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/router.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],26:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

module.exports = function(AV) {
  /**
   * A builder to generate sort string for app searching.For example:
   * <pre><code>
   *   var builder = new AV.SearchSortBuilder();
   *   builder.ascending('key1').descending('key2','max');
   *   var query = new AV.SearchQuery('Player');
   *   query.sortBy(builder);
   *   query.find().then ...
   * </code></pre>
   * @class
   * @since 0.5.1
   */
  AV.SearchSortBuilder = function() {
    this._sortFields = [];
  };

  AV.SearchSortBuilder.prototype = {
    _addField: function(key, order, mode, missing) {
      var field = {};
      field[key] = {
        order: order || 'asc',
        mode: mode ||'avg',
        missing: '_' + (missing || 'last')
      };
      this._sortFields.push(field);
      return this;
    },


    /**
     * Sorts the results in ascending order by the given key and options.
     *
     * @param {String} key The key to order by.
     * @param {String} mode The sort mode, default is 'avg', you can choose
     *                  'max' or 'min' too.
     * @param {String} missing The missing key behaviour, default is 'last',
     *                  you can choose 'first' too.
     * @return {AV.SearchSortBuilder} Returns the builder, so you can chain this call.
     */
    ascending: function(key, mode, missing) {
      return this._addField(key, 'asc', mode, missing);
    },

    /**
     * Sorts the results in descending order by the given key and options.
     *
     * @param {String} key The key to order by.
     * @param {String} mode The sort mode, default is 'avg', you can choose
     *                  'max' or 'min' too.
     * @param {String} missing The missing key behaviour, default is 'last',
     *                  you can choose 'first' too.
     * @return {AV.SearchSortBuilder} Returns the builder, so you can chain this call.
     */
    descending: function(key, mode, missing) {
      return this._addField(key, 'desc', mode, missing);
    },

    /**
     * Add a proximity based constraint for finding objects with key point
     * values near the point given.
     * @param {String} key The key that the AV.GeoPoint is stored in.
     * @param {AV.GeoPoint} point The reference AV.GeoPoint that is used.
     * @param {Object} options The other options such as mode,order, unit etc.
     * @return {AV.SearchSortBuilder} Returns the builder, so you can chain this call.
     */
    whereNear: function(key, point, options) {
      options = options || {};
      var field = {};
      var geo = {
        lat: point.latitude,
        lon: point.longitude
      };
      var m = {
        order: options.order || 'asc',
        mode: options.mode || 'avg',
        unit: options.unit || 'km'
      };
      m[key] = geo;
      field['_geo_distance'] = m;

      this._sortFields.push(field);
      return this;
    },

    /**
     * Build a sort string by configuration.
     * @return {String} the sort string.
     */
    build: function() {
      return JSON.stringify(AV._encode(this._sortFields));
    }
  };

  /**
   * App searching query.Use just like AV.Query:
   * <pre><code>
   *   var query = new AV.SearchQuery('Player');
   *   query.queryString('*');
   *   query.find().then(function(results) {
   *     console.log('Found %d objects', query.hits());
   *     //Process results
   *   });
   *
   * </code></pre>
   * Visite <a href='https://leancloud.cn/docs/app_search_guide.html'>App Searching Guide</a>
   * for more details.
   * @class
   * @since 0.5.1
   *
   */
  AV.SearchQuery = AV.Query._extend(/** @lends AV.SearchQuery.prototype */{
     _sid: null,
     _hits:  0,
     _queryString: null,
     _highlights: null,
     _sortBuilder: null,
    _createRequest: function(params){
      return AV._request("search/select", null, null, "GET",
                                   params || this.toJSON());
    },

    /**
     * Sets the sid of app searching query.Default is null.
     * @param {String} sid  Scroll id for searching.
     * @return {AV.SearchQuery} Returns the query, so you can chain this call.
     */
    sid: function(sid) {
      this._sid = sid;
      return this;
    },

    /**
     * Sets the query string of app searching.
     * @param {String} q  The query string.
     * @return {AV.SearchQuery} Returns the query, so you can chain this call.
     */
    queryString: function(q) {
      this._queryString = q;
      return this;
    },


    /**
     * Sets the highlight fields. Such as
     * <pre><code>
     *   query.highlights('title');
     *   //or pass an array.
     *   query.highlights(['title', 'content'])
     * </code></pre>
     * @param {Array} highlights a list of fields.
     * @return {AV.SearchQuery} Returns the query, so you can chain this call.
     */
    highlights: function(highlights) {
      var objects;
      if (highlights && _.isString(highlights)) {
        objects = arguments;
      } else {
        objects = highlights;
      }
      this._highlights = objects;
      return this;
    },

    /**
     * Sets the sort builder for this query.
     * @see AV.SearchSortBuilder
     * @param { AV.SearchSortBuilder} builder The sort builder.
     * @return {AV.SearchQuery} Returns the query, so you can chain this call.
     *
     */
    sortBy: function(builder) {
      this._sortBuilder = builder;
      return this;
    },

    /**
     * Returns the number of objects that match this query.
     * @return {Number}
     */
    hits: function() {
       if (!this._hits) {
        this._hits = 0;
      }
      return this._hits;
    },

    _processResult: function(json){
       delete json['className'];
       delete json['_app_url'];
       delete json['_deeplink'];
       return json;
    },

    /**
     * Returns true when there are more documents can be retrieved by this
     * query instance, you can call find function to get more results.
     * @see AV.SearchQuery#find
     * @return {Boolean}
     */
    hasMore: function() {
      return !this._hitEnd;
    },

    /**
     * Reset current query instance state(such as sid, hits etc) except params
     * for a new searching. After resetting, hasMore() will return true.
     */
    reset: function() {
      this._hitEnd = false;
      this._sid = null;
      this._hits = 0;
    },

    /**
     * Retrieves a list of AVObjects that satisfy this query.
     * Either options.success or options.error is called when the find
     * completes.
     *
     * @see AV.Query#find
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is resolved with the results when
     * the query completes.
     */
    find: function(options) {
      var self = this;

      var request = this._createRequest();

      return request.then(function(response) {
        //update sid for next querying.
        if(response.sid) {
          self._oldSid = self._sid;
          self._sid = response.sid;
        } else {
          self._sid = null;
          self._hitEnd = true;
        }
        self._hits = response.hits || 0;

        return _.map(response.results, function(json) {
          if(json.className) {
            response.className = json.className;
          }
          var obj = self._newObject(response);
          obj.appURL = json['_app_url'];
          obj._finishFetch(self._processResult(json), true);
          return obj;
        });
      })._thenRunCallbacks(options);
    },

    toJSON: function(){
      var params = AV.SearchQuery.__super__.toJSON.call(this);
      delete params.where;
      if(this.className) {
        params.clazz = this.className;
      }
      if(this._sid) {
        params.sid = this._sid;
      }
      if(!this._queryString) {
        throw 'Please set query string.';
      } else {
        params.q = this._queryString;
      }
      if(this._highlights) {
        params.highlights = this._highlights.join(',');
      }
      if(this._sortBuilder && params.order) {
        throw 'sort and order can not be set at same time.';
      }
      if(this._sortBuilder) {
        params.sort = this._sortBuilder.build();
      }

      return params;
    }
  });
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/search.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],27:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

module.exports = function(AV) {
  /**
   * Contains functions to deal with Status in AVOS Cloud.
   * @name AV.Status
   * @namespace
   */
  AV.Status = function(imageUrl, message) {
    this.data = {};
    this.inboxType = 'default';
    this.query = null;
    if(imageUrl && typeof imageUrl === 'object') {
        this.data = imageUrl;
    } else {
      if(imageUrl){
        this.data.image = imageUrl;
      }
      if(message){
        this.data.message = message;
      }
    }
    return this;
  };

  AV.Status.prototype = {
    /**
     * Gets the value of an attribute in status data.
     * @param {String} attr The string name of an attribute.
     */
    get: function(attr){
      return this.data[attr];
    },
    /**
     * Sets a hash of model attributes on the status data.
     * @param {String} key The key to set.
     * @param {} value The value to give it.
     */
    set: function(key, value){
      this.data[key] = value;
      return this;
    },
    /**
     * Destroy this status,then it will not be avaiable in other user's inboxes.
     * @param {Object} options An optional Backbone-like options object with
     *     success and error callbacks that will be invoked once the iteration
     *     has finished.
     * @return {AV.Promise} A promise that is fulfilled when the destroy
     *     completes.
     */
    destroy: function(options){
      if(!this.id)
        return AV.Promise.error('The status id is not exists.')._thenRunCallbacks(options);
      var request = AV._request("statuses", null, this.id, 'DELETE');
      return request._thenRunCallbacks(options);
    },
    /**
      * Cast the AV.Status object to an AV.Object pointer.
      * @return {AV.Object} A AV.Object pointer.
      */
    toObject: function(){
      if(!this.id)
          return null;
      return AV.Object.createWithoutData('_Status', this.id);
    },
    _getDataJSON: function() {
      var json = AV._.clone(this.data);
      return AV._encode(json);
    },
   /**
    * Send  a status by a AV.Query object.
    * <p>For example,send a status to male users:<br/><pre>
    *     var status = new AVStatus('image url', 'a message');
    *     status.query = new AV.Query('_User');
    *     status.query.equalTo('gender', 'male');
    *     status.send().then(function(){
    *              //send status successfully.
    *      }, function(err){
    *             //an error threw.
    *             console.dir(err);
    *      });
    * </pre></p>
    * @since 0.3.0
    * @param {Object} options An optional Backbone-like options object with
    *     success and error callbacks that will be invoked once the iteration
    *     has finished.
    * @return {AV.Promise} A promise that is fulfilled when the send
    *     completes.
    */
    send: function(options){
      if(!AV.User.current()){
        throw 'Please signin an user.';
      }
      if(!this.query){
        return AV.Status.sendStatusToFollowers(this, options);
      }

      var query = this.query.toJSON();
      query.className = this.query.className;
      var data = {};
      data.query = query;
      this.data = this.data || {};
      var currUser =  AV.Object.createWithoutData('_User', AV.User.current().id)._toPointer();
      this.data.source =  this.data.source || currUser;
      data.data = this._getDataJSON();
      data.inboxType = this.inboxType || 'default';

      var request = AV._request('statuses', null, null, 'POST', data);
      var self = this;
      return request.then(function(response){
        self.id = response.objectId;
        self.createdAt = AV._parseDate(response.createdAt);
        return self;
      })._thenRunCallbacks(options);
    },

    _finishFetch: function(serverData){
        this.id = serverData.objectId;
        this.createdAt = AV._parseDate(serverData.createdAt);
        this.updatedAt = AV._parseDate(serverData.updatedAt);
        this.messageId = serverData.messageId;
        delete serverData.messageId;
        delete serverData.objectId;
        delete serverData.createdAt;
        delete serverData.updatedAt;
        this.data = AV._decode(undefined, serverData);
    }
  };

  /**
   * Send  a status to current signined user's followers.For example:
   * <p><pre>
   *     var status = new AVStatus('image url', 'a message');
   *     AV.Status.sendStatusToFollowers(status).then(function(){
   *              //send status successfully.
   *      }, function(err){
   *             //an error threw.
   *             console.dir(err);
   *      });
   * </pre></p>
   * @since 0.3.0
   * @param {AV.Status} status  A status object to be send to followers.
   * @param {Object} options An optional Backbone-like options object with
   *     success and error callbacks that will be invoked once the iteration
   *     has finished.
   * @return {AV.Promise} A promise that is fulfilled when the send
   *     completes.
   */
  AV.Status.sendStatusToFollowers = function(status, options) {
    if(!AV.User.current()){
      throw 'Please signin an user.';
    }
    var query = {};
    query.className = '_Follower';
    query.keys = 'follower';
    var currUser =  AV.Object.createWithoutData('_User', AV.User.current().id). _toPointer();
    query.where = {user: currUser};
    var data = {};
    data.query = query;
    status.data = status.data || {};
    status.data.source =  status.data.source || currUser;
    data.data = status._getDataJSON();
    data.inboxType = status.inboxType || 'default';

    var request = AV._request('statuses', null, null, 'POST', data);
    return request.then(function(response){
      status.id = response.objectId;
      status.createdAt = AV._parseDate(response.createdAt);
      return status;
    })._thenRunCallbacks(options);
  };

  /**
   * <p>Send  a status from current signined user to other user's private status inbox.</p>
   * <p>For example,send a private status to user '52e84e47e4b0f8de283b079b':<br/>
   * <pre>
   *    var status = new AVStatus('image url', 'a message');
   *     AV.Status.sendPrivateStatus(status, '52e84e47e4b0f8de283b079b').then(function(){
   *              //send status successfully.
   *      }, function(err){
   *             //an error threw.
   *             console.dir(err);
   *      });
   * </pre></p>
   * @since 0.3.0
   * @param {AV.Status} status  A status object to be send to followers.
   * @param {} target The target user or user's objectId.
   * @param {Object} options An optional Backbone-like options object with
   *     success and error callbacks that will be invoked once the iteration
   *     has finished.
   * @return {AV.Promise} A promise that is fulfilled when the send
   *     completes.
   */
  AV.Status.sendPrivateStatus = function(status, target, options) {
    if(!AV.User.current()){
      throw 'Please signin an user.';
    }
    if(!target){
          throw "Invalid target user.";
    }
    var userObjectId = _.isString(target) ? target: target.id;
    if(!userObjectId){
        throw "Invalid target user.";
    }

    var query = {};
    query.className = '_User';
    var currUser =  AV.Object.createWithoutData('_User', AV.User.current().id). _toPointer();
    query.where = {objectId: userObjectId};
    var data = {};
    data.query = query;
    status.data = status.data || {};
    status.data.source =  status.data.source || currUser;
    data.data = status._getDataJSON();
    data.inboxType = 'private';
    status.inboxType = 'private';

    var request = AV._request('statuses', null, null, 'POST', data);
    return request.then(function(response){
      status.id = response.objectId;
      status.createdAt = AV._parseDate(response.createdAt);
      return status;
    })._thenRunCallbacks(options);
  };

  /**
   * Count unread statuses in someone's inbox.For example:<br/>
   * <p><pre>
   *  AV.Status.countUnreadStatuses(AV.User.current()).then(function(response){
   *    console.log(response.unread); //unread statuses number.
   *    console.log(response.total);  //total statuses number.
   *  });
   * </pre></p>
   * @since 0.3.0
   * @param {Object} source The status source.
   * @return {AV.Query} The query object for status.
   * @return {AV.Promise} A promise that is fulfilled when the count
   *     completes.
   */
  AV.Status.countUnreadStatuses = function(owner){
    if(!AV.User.current() && owner == null){
      throw 'Please signin an user or pass the owner objectId.';
    }
    owner = owner || AV.User.current();
    var options = !_.isString(arguments[1]) ? arguments[1] : arguments[2];
    var inboxType =  !_.isString(arguments[1]) ? 'default' : arguments[1];
    var params = {};
    params.inboxType = AV._encode(inboxType);
    params.owner = AV._encode(owner);
    var request = AV._request('subscribe/statuses/count', null, null, 'GET', params);
    return request._thenRunCallbacks(options);
  };

  /**
   * Create a status query to find someone's published statuses.For example:<br/>
   * <p><pre>
   *   //Find current user's published statuses.
   *   var query = AV.Status.statusQuery(AV.User.current());
   *   query.find().then(function(statuses){
   *      //process statuses
   *   });
   * </pre></p>
   * @since 0.3.0
   * @param {Object} source The status source.
   * @return {AV.Query} The query object for status.
   */
  AV.Status.statusQuery = function(source){
    var query = new AV.Query('_Status');
    if(source){
      query.equalTo('source', source);
    }
    return query;
  };

   /**
    * <p>AV.InboxQuery defines a query that is used to fetch somebody's inbox statuses.</p>
    * @see AV.Status#inboxQuery
    * @class
    */
   AV.InboxQuery = AV.Query._extend(/** @lends AV.InboxQuery.prototype */{
     _objectClass: AV.Status,
     _sinceId: 0,
     _maxId:  0,
     _inboxType: 'default',
     _owner: null,
     _newObject: function(){
      return new AV.Status();
    },
    _createRequest: function(params){
      return AV._request("subscribe/statuses", null, null, "GET",
                                   params || this.toJSON());
    },


    /**
     * Sets the messageId of results to skip before returning any results.
     * This is useful for pagination.
     * Default is zero.
     * @param {Number} n the mesage id.
     * @return {AV.InboxQuery} Returns the query, so you can chain this call.
     */
    sinceId: function(id){
      this._sinceId = id;
      return this;
    },
    /**
     * Sets the maximal messageId of results。
     * This is useful for pagination.
     * Default is zero that is no limition.
     * @param {Number} n the mesage id.
     * @return {AV.InboxQuery} Returns the query, so you can chain this call.
     */
    maxId: function(id){
      this._maxId = id;
      return this;
    },
    /**
     * Sets the owner of the querying inbox.
     * @param {Object} owner The inbox owner.
     * @return {AV.InboxQuery} Returns the query, so you can chain this call.
     */
    owner: function(owner){
      this._owner = owner;
      return this;
    },
    /**
     * Sets the querying inbox type.default is 'default'.
     * @param {Object} owner The inbox type.
     * @return {AV.InboxQuery} Returns the query, so you can chain this call.
     */
    inboxType: function(type){
      this._inboxType = type;
      return this;
    },
    toJSON: function(){
      var params = AV.InboxQuery.__super__.toJSON.call(this);
      params.owner = AV._encode(this._owner);
      params.inboxType = AV._encode(this._inboxType);
      params.sinceId = AV._encode(this._sinceId);
      params.maxId = AV._encode(this._maxId);
      return params;
    }
   });

  /**
   * Create a inbox status query to find someone's inbox statuses.For example:<br/>
   * <p><pre>
   *   //Find current user's default inbox statuses.
   *   var query = AV.Status.inboxQuery(AV.User.current());
   *   //find the statuses after the last message id
   *   query.sinceId(lastMessageId);
   *   query.find().then(function(statuses){
   *      //process statuses
   *   });
   * </pre></p>
   * @since 0.3.0
   * @param {Object} owner The inbox's owner
   * @param {String} inboxType The inbox type,'default' by default.
   * @return {AV.InboxQuery} The inbox query object.
   * @see AV.InboxQuery
   */
  AV.Status.inboxQuery = function(owner, inboxType){
    var query = new AV.InboxQuery(AV.Status);
    if(owner){
      query._owner = owner;
    }
    if(inboxType){
      query._inboxType = inboxType;
    }
    return query;
  };

};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/status.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],28:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

module.exports = function(AV) {
  /**
   * @class
   *
   * <p>A AV.User object is a local representation of a user persisted to the
   * AV cloud. This class is a subclass of a AV.Object, and retains the
   * same functionality of a AV.Object, but also extends it with various
   * user specific methods, like authentication, signing up, and validation of
   * uniqueness.</p>
   */
  AV.User = AV.Object.extend("_User", /** @lends AV.User.prototype */ {
    // Instance Variables
    _isCurrentUser: false,


    // Instance Methods

    /**
     * Internal method to handle special fields in a _User response.
     */
    _mergeMagicFields: function(attrs) {
      if (attrs.sessionToken) {
        this._sessionToken = attrs.sessionToken;
        delete attrs.sessionToken;
      }
      AV.User.__super__._mergeMagicFields.call(this, attrs);
    },

    /**
     * Removes null values from authData (which exist temporarily for
     * unlinking)
     */
    _cleanupAuthData: function() {
      if (!this.isCurrent()) {
        return;
      }
      var authData = this.get('authData');
      if (!authData) {
        return;
      }
      AV._objectEach(this.get('authData'), function(value, key) {
        if (!authData[key]) {
          delete authData[key];
        }
      });
    },

    /**
     * Synchronizes authData for all providers.
     */
    _synchronizeAllAuthData: function() {
      var authData = this.get('authData');
      if (!authData) {
        return;
      }

      var self = this;
      AV._objectEach(this.get('authData'), function(value, key) {
        self._synchronizeAuthData(key);
      });
    },

    /**
     * Synchronizes auth data for a provider (e.g. puts the access token in the
     * right place to be used by the Facebook SDK).
     */
    _synchronizeAuthData: function(provider) {
      if (!this.isCurrent()) {
        return;
      }
      var authType;
      if (_.isString(provider)) {
        authType = provider;
        provider = AV.User._authProviders[authType];
      } else {
        authType = provider.getAuthType();
      }
      var authData = this.get('authData');
      if (!authData || !provider) {
        return;
      }
      var success = provider.restoreAuthentication(authData[authType]);
      if (!success) {
        this._unlinkFrom(provider);
      }
    },

    _handleSaveResult: function(makeCurrent) {
      // Clean up and synchronize the authData object, removing any unset values
      if (makeCurrent) {
        this._isCurrentUser = true;
      }
      this._cleanupAuthData();
      this._synchronizeAllAuthData();
      // Don't keep the password around.
      delete this._serverData.password;
      this._rebuildEstimatedDataForKey("password");
      this._refreshCache();
      if (makeCurrent || this.isCurrent()) {
        // Some old version of leanengine-node-sdk will overwrite
        // AV.User._saveCurrentUser which returns no Promise.
        // So we need a Promise wrapper.
        return AV.Promise.as(AV.User._saveCurrentUser(this));
      } else {
        return AV.Promise.as();
      }
    },

    /**
     * Unlike in the Android/iOS SDKs, logInWith is unnecessary, since you can
     * call linkWith on the user (even if it doesn't exist yet on the server).
     */
    _linkWith: function(provider, options) {
      var authType;
      if (_.isString(provider)) {
        authType = provider;
        provider = AV.User._authProviders[provider];
      } else {
        authType = provider.getAuthType();
      }
      if (_.has(options, 'authData')) {
        var authData = this.get('authData') || {};
        authData[authType] = options.authData;
        this.set('authData', authData);
        return this.save({'authData': authData}, filterOutCallbacks(options))
          .then(function(model) {
            return model._handleSaveResult(true).then(function() {
              return model;
            });
          })._thenRunCallbacks(options);
      } else {
        var self = this;
        var promise = new AV.Promise();
        provider.authenticate({
          success: function(provider, result) {
            self._linkWith(provider, {
              authData: result,
              success: options.success,
              error: options.error
            }).then(function() {
              promise.resolve(self);
            });
          },
          error: function(provider, error) {
            if (options.error) {
              options.error(self, error);
            }
            promise.reject(error);
          }
        });
        return promise;
      }
    },

    /**
     * Unlinks a user from a service.
     */
    _unlinkFrom: function(provider, options) {
      var authType;
      if (_.isString(provider)) {
        authType = provider;
        provider = AV.User._authProviders[provider];
      } else {
        authType = provider.getAuthType();
      }
      var newOptions = _.clone(options);
      var self = this;
      newOptions.authData = null;
      newOptions.success = function(model) {
        self._synchronizeAuthData(provider);
        if (options.success) {
          options.success.apply(this, arguments);
        }
      };
      return this._linkWith(provider, newOptions);
    },

    /**
     * Checks whether a user is linked to a service.
     */
    _isLinked: function(provider) {
      var authType;
      if (_.isString(provider)) {
        authType = provider;
      } else {
        authType = provider.getAuthType();
      }
      var authData = this.get('authData') || {};
      return !!authData[authType];
    },

    /**
     * Deauthenticates all providers.
     */
    _logOutWithAll: function() {
      var authData = this.get('authData');
      if (!authData) {
        return;
      }
      var self = this;
      AV._objectEach(this.get('authData'), function(value, key) {
        self._logOutWith(key);
      });
    },

    /**
     * Deauthenticates a single provider (e.g. removing access tokens from the
     * Facebook SDK).
     */
    _logOutWith: function(provider) {
      if (!this.isCurrent()) {
        return;
      }
      if (_.isString(provider)) {
        provider = AV.User._authProviders[provider];
      }
      if (provider && provider.deauthenticate) {
        provider.deauthenticate();
      }
    },

    /**
     * Signs up a new user. You should call this instead of save for
     * new AV.Users. This will create a new AV.User on the server, and
     * also persist the session on disk so that you can access the user using
     * <code>current</code>.
     *
     * <p>A username and password must be set before calling signUp.</p>
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {Object} attrs Extra fields to set on the new user, or null.
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled when the signup
     *     finishes.
     * @see AV.User.signUp
     */
    signUp: function(attrs, options) {
      var error;
      options = options || {};

      var username = (attrs && attrs.username) || this.get("username");
      if (!username || (username === "")) {
        error = new AV.Error(
            AV.Error.OTHER_CAUSE,
            "Cannot sign up user with an empty name.");
        if (options && options.error) {
          options.error(this, error);
        }
        return AV.Promise.error(error);
      }

      var password = (attrs && attrs.password) || this.get("password");
      if (!password || (password === "")) {
        error = new AV.Error(
            AV.Error.OTHER_CAUSE,
            "Cannot sign up user with an empty password.");
        if (options && options.error) {
          options.error(this, error);
        }
        return AV.Promise.error(error);
      }

      return this.save(attrs, filterOutCallbacks(options)).then(function(model) {
        return model._handleSaveResult(true).then(function() {
          return model;
        });
      })._thenRunCallbacks(options, this);
    },

    /**
     * Signs up a new user with mobile phone and sms code.
     * You should call this instead of save for
     * new AV.Users. This will create a new AV.User on the server, and
     * also persist the session on disk so that you can access the user using
     * <code>current</code>.
     *
     * <p>A username and password must be set before calling signUp.</p>
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {Object} attrs Extra fields to set on the new user, or null.
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled when the signup
     *     finishes.
     * @see AV.User.signUpOrlogInWithMobilePhone
     * @see AV.Cloud.requestSmsCode
     */
    signUpOrlogInWithMobilePhone: function(attrs, options) {
      var error;
      options = options || {};

      var mobilePhoneNumber = (attrs && attrs.mobilePhoneNumber) ||
                              this.get("mobilePhoneNumber");
      if (!mobilePhoneNumber || (mobilePhoneNumber === "")) {
        error = new AV.Error(
            AV.Error.OTHER_CAUSE,
            "Cannot sign up or login user by mobilePhoneNumber " +
            "with an empty mobilePhoneNumber.");
        if (options && options.error) {
          options.error(this, error);
        }
        return AV.Promise.error(error);
      }

      var smsCode = (attrs && attrs.smsCode) || this.get("smsCode");
      if (!smsCode || (smsCode === "")) {
        error = new AV.Error(
            AV.Error.OTHER_CAUSE,
             "Cannot sign up or login user by mobilePhoneNumber  " +
             "with an empty smsCode.");
        if (options && options.error) {
          options.error(this, error);
        }
        return AV.Promise.error(error);
      }

      var newOptions = filterOutCallbacks(options);
      newOptions._makeRequest = function(route, className, id, method, json) {
        return AV._request('usersByMobilePhone', null, null, "POST", json);
      };
      return this.save(attrs, newOptions).then(function(model) {
        delete model.attributes.smsCode;
        delete model._serverData.smsCode;
        return model._handleSaveResult(true).then(function() {
          return model;
        });
      })._thenRunCallbacks(options);
    },

    /**
     * Logs in a AV.User. On success, this saves the session to localStorage,
     * so you can retrieve the currently logged in user using
     * <code>current</code>.
     *
     * <p>A username and password must be set before calling logIn.</p>
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {Object} options A Backbone-style options object.
     * @see AV.User.logIn
     * @return {AV.Promise} A promise that is fulfilled with the user when
     *     the login is complete.
     */
    logIn: function(options) {
      var model = this;
      var request = AV._request("login", null, null, "GET", this.toJSON());
      return request.then(function(resp, status, xhr) {
        var serverAttrs = model.parse(resp, status, xhr);
        model._finishFetch(serverAttrs);
        return model._handleSaveResult(true).then(function() {
          if(!serverAttrs.smsCode)
            delete model.attributes['smsCode'];
          return model;
        });
      })._thenRunCallbacks(options, this);
    },

    /**
     * @see AV.Object#save
     */
    save: function(arg1, arg2, arg3) {
      var i, attrs, current, options, saved;
      if (_.isObject(arg1) || _.isNull(arg1) || _.isUndefined(arg1)) {
        attrs = arg1;
        options = arg2;
      } else {
        attrs = {};
        attrs[arg1] = arg2;
        options = arg3;
      }
      options = options || {};

      return AV.Object.prototype.save
        .call(this, attrs, filterOutCallbacks(options))
        .then(function(model) {
          return model._handleSaveResult(false).then(function() {
            return model;
          });
        })._thenRunCallbacks(options);
    },

    /**
     * Follow a user
     * @since 0.3.0
     * @param {} target The target user or user's objectId to follow.
     * @param {Object} options An optional Backbone-like options object with
     *     success and error callbacks that will be invoked once the iteration
     *     has finished.
     */
    follow: function(target, options){
      if(!this.id){
          throw "Please signin.";
      }
      if(!target){
          throw "Invalid target user.";
      }
      var userObjectId = _.isString(target) ? target: target.id;
      if(!userObjectId){
          throw "Invalid target user.";
      }
      var route = 'users/' + this.id + '/friendship/' + userObjectId;
      var request = AV._request(route, null, null, 'POST', null);
      return request._thenRunCallbacks(options);
    },

    /**
     * Unfollow a user.
     * @since 0.3.0
     * @param {} target The target user or user's objectId to unfollow.
     * @param options {Object} An optional Backbone-like options object with
     *     success and error callbacks that will be invoked once the iteration
     *     has finished.
     */
    unfollow: function(target, options){
      if(!this.id){
          throw "Please signin.";
      }
      if(!target){
          throw "Invalid target user.";
      }
      var userObjectId = _.isString(target) ? target: target.id;
      if(!userObjectId){
          throw "Invalid target user.";
      }
      var route = 'users/' + this.id + '/friendship/' + userObjectId;
      var request = AV._request(route, null, null, 'DELETE', null);
      return request._thenRunCallbacks(options);
    },

    /**
     *Create a follower query to query the user's followers.
     * @since 0.3.0
     * @see AV.User#followerQuery
     */
    followerQuery: function() {
        return AV.User.followerQuery(this.id);
    },

    /**
     *Create a followee query to query the user's followees.
     * @since 0.3.0
     * @see AV.User#followeeQuery
     */
    followeeQuery: function() {
        return AV.User.followeeQuery(this.id);
    },

    /**
     * @see AV.Object#fetch
     */
    fetch: function(options) {
      return AV.Object.prototype.fetch.call(this, filterOutCallbacks(options))
        .then(function(model) {
          return model._handleSaveResult(false).then(function() {
            return model;
          });
        })._thenRunCallbacks(options);
    },

    /**
     * Update user's new password safely based on old password.
     * @param {String} oldPassword, the old password.
     * @param {String} newPassword, the new password.
     * @param {Object} An optional Backbone-like options object with
     *     success and error callbacks that will be invoked once the iteration
     *     has finished.
     */
    updatePassword: function(oldPassword, newPassword, options) {
      var route = 'users/' + this.id + '/updatePassword';
      var params = {
        old_password: oldPassword,
        new_password: newPassword
      };
      var request = AV._request(route, null, null, 'PUT', params);
      return request._thenRunCallbacks(options, this);
    },

    /**
     * Returns true if <code>current</code> would return this user.
     * @see AV.User#current
     */
    isCurrent: function() {
      return this._isCurrentUser;
    },

    /**
     * Returns get("username").
     * @return {String}
     * @see AV.Object#get
     */
    getUsername: function() {
      return this.get("username");
    },

    /**
     * Returns get("mobilePhoneNumber").
     * @return {String}
     * @see AV.Object#get
     */
    getMobilePhoneNumber: function(){
      return this.get("mobilePhoneNumber");
    },

    /**
     * Calls set("mobilePhoneNumber", phoneNumber, options) and returns the result.
     * @param {String} mobilePhoneNumber
     * @param {Object} options A Backbone-style options object.
     * @return {Boolean}
     * @see AV.Object.set
     */
    setMobilePhoneNumber: function(phone, options) {
      return this.set("mobilePhoneNumber", phone, options);
    },

    /**
     * Calls set("username", username, options) and returns the result.
     * @param {String} username
     * @param {Object} options A Backbone-style options object.
     * @return {Boolean}
     * @see AV.Object.set
     */
    setUsername: function(username, options) {
      return this.set("username", username, options);
    },

    /**
     * Calls set("password", password, options) and returns the result.
     * @param {String} password
     * @param {Object} options A Backbone-style options object.
     * @return {Boolean}
     * @see AV.Object.set
     */
    setPassword: function(password, options) {
      return this.set("password", password, options);
    },

    /**
     * Returns get("email").
     * @return {String}
     * @see AV.Object#get
     */
    getEmail: function() {
      return this.get("email");
    },

    /**
     * Calls set("email", email, options) and returns the result.
     * @param {String} email
     * @param {Object} options A Backbone-style options object.
     * @return {Boolean}
     * @see AV.Object.set
     */
    setEmail: function(email, options) {
      return this.set("email", email, options);
    },

    /**
     * Checks whether this user is the current user and has been authenticated.
     * @return (Boolean) whether this user is the current user and is logged in.
     */
    authenticated: function() {
      return !!this._sessionToken &&
          (AV.User.current() && AV.User.current().id === this.id);
    }

  }, /** @lends AV.User */ {
    // Class Variables

    // The currently logged-in user.
    _currentUser: null,

    // Whether currentUser is known to match the serialized version on disk.
    // This is useful for saving a localstorage check if you try to load
    // _currentUser frequently while there is none stored.
    _currentUserMatchesDisk: false,

    // The localStorage key suffix that the current user is stored under.
    _CURRENT_USER_KEY: "currentUser",

    // The mapping of auth provider names to actual providers
    _authProviders: {},


    // Class Methods

    /**
     * Signs up a new user with a username (or email) and password.
     * This will create a new AV.User on the server, and also persist the
     * session in localStorage so that you can access the user using
     * {@link #current}.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {String} username The username (or email) to sign up with.
     * @param {String} password The password to sign up with.
     * @param {Object} attrs Extra fields to set on the new user.
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled with the user when
     *     the signup completes.
     * @see AV.User#signUp
     */
    signUp: function(username, password, attrs, options) {
      attrs = attrs || {};
      attrs.username = username;
      attrs.password = password;
      var user = AV.Object._create("_User");
      return user.signUp(attrs, options);
    },

    /**
     * Logs in a user with a username (or email) and password. On success, this
     * saves the session to disk, so you can retrieve the currently logged in
     * user using <code>current</code>.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {String} username The username (or email) to log in with.
     * @param {String} password The password to log in with.
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled with the user when
     *     the login completes.
     * @see AV.User#logIn
     */
    logIn: function(username, password, options) {
      var user = AV.Object._create("_User");
      user._finishFetch({ username: username, password: password });
      return user.logIn(options);
    },

    /**
     * Logs in a user with a session token. On success, this saves the session
     * to disk, so you can retrieve the currently logged in user using
     * <code>current</code>.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {String} sessionToken The sessionToken to log in with.
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled with the user when
     *     the login completes.
     */
    become: function(sessionToken, options) {
      options = options || {};

      var user = AV.Object._create("_User");
      return AV._request(
          "users",
          "me",
          null,
          "GET",
          {
            useMasterKey: options.useMasterKey,
            session_token: sessionToken
          }
      ).then(function(resp, status, xhr) {
          var serverAttrs = user.parse(resp, status, xhr);
          user._finishFetch(serverAttrs);
          return user._handleSaveResult(true).then(function() {
            return user;
          });
      })._thenRunCallbacks(options, user);
    },

    /**
     * Logs in a user with a mobile phone number and sms code sent by
     * AV.User.requestLoginSmsCode.On success, this
     * saves the session to disk, so you can retrieve the currently logged in
     * user using <code>current</code>.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {String} mobilePhone The user's mobilePhoneNumber
     * @param {String} smsCode The sms code sent by AV.User.requestLoginSmsCode
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled with the user when
     *     the login completes.
     * @see AV.User#logIn
     */
   logInWithMobilePhoneSmsCode: function(mobilePhone, smsCode, options){
      var user = AV.Object._create("_User");
      user._finishFetch({ mobilePhoneNumber: mobilePhone, smsCode: smsCode });
      return user.logIn(options);
   },

    /**
     * Sign up or logs in a user with a mobilePhoneNumber and smsCode.
     * On success, this saves the session to disk, so you can retrieve the currently
     * logged in user using <code>current</code>.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {String} mobilePhoneNumber The user's mobilePhoneNumber.
     * @param {String} smsCode The sms code sent by AV.Cloud.requestSmsCode
     * @param {Object} attributes  The user's other attributes such as username etc.
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled with the user when
     *     the login completes.
     * @see AV.User#signUpOrlogInWithMobilePhone
     * @see AV.Cloud.requestSmsCode
     */
    signUpOrlogInWithMobilePhone: function(mobilePhoneNumber, smsCode, attrs, options) {
      attrs = attrs || {};
      attrs.mobilePhoneNumber = mobilePhoneNumber;
      attrs.smsCode = smsCode;
      var user = AV.Object._create("_User");
      return user.signUpOrlogInWithMobilePhone(attrs, options);
    },


    /**
     * Logs in a user with a mobile phone number and password. On success, this
     * saves the session to disk, so you can retrieve the currently logged in
     * user using <code>current</code>.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {String} mobilePhone The user's mobilePhoneNumber
     * @param {String} password The password to log in with.
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled with the user when
     *     the login completes.
     * @see AV.User#logIn
     */
   logInWithMobilePhone: function(mobilePhone, password, options){
      var user = AV.Object._create("_User");
      user._finishFetch({ mobilePhoneNumber: mobilePhone, password: password });
      return user.logIn(options);
   },

    /**
     * Logs out the currently logged in user session. This will remove the
     * session from disk, log out of linked services, and future calls to
     * <code>current</code> will return <code>null</code>.
     */
    logOut: function() {
      if (AV.User._currentUser !== null) {
        AV.User._currentUser._logOutWithAll();
        AV.User._currentUser._isCurrentUser = false;
      }
      AV.User._currentUserMatchesDisk = true;
      AV.User._currentUser = null;
      return AV.localStorage.removeItemAsync(
          AV._getAVPath(AV.User._CURRENT_USER_KEY));
    },

    /**
     *Create a follower query for special user to query the user's followers.
     * @param userObjectId {String} The user object id.
     * @since 0.3.0
     */
    followerQuery: function(userObjectId) {
        if(!userObjectId || !_.isString(userObjectId)) {
          throw "Invalid user object id.";
        }
        var query = new AV.FriendShipQuery('_Follower');
        query._friendshipTag ='follower';
        query.equalTo('user', AV.Object.createWithoutData('_User', userObjectId));
        return query;
    },

    /**
     *Create a followee query for special user to query the user's followees.
     * @param userObjectId {String} The user object id.
     * @since 0.3.0
     */
    followeeQuery: function(userObjectId) {
        if(!userObjectId || !_.isString(userObjectId)) {
          throw "Invalid user object id.";
        }
        var query = new AV.FriendShipQuery('_Followee');
        query._friendshipTag ='followee';
        query.equalTo('user', AV.Object.createWithoutData('_User', userObjectId));
        return query;
    },

    /**
     * Requests a password reset email to be sent to the specified email address
     * associated with the user account. This email allows the user to securely
     * reset their password on the AV site.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {String} email The email address associated with the user that
     *     forgot their password.
     * @param {Object} options A Backbone-style options object.
     */
    requestPasswordReset: function(email, options) {
      var json = { email: email };
      var request = AV._request("requestPasswordReset", null, null, "POST",
                                   json);
      return request._thenRunCallbacks(options);
    },

    /**
     * Requests a verify email to be sent to the specified email address
     * associated with the user account. This email allows the user to securely
     * verify their email address on the AV site.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {String} email The email address associated with the user that
     *     doesn't verify their email address.
     * @param {Object} options A Backbone-style options object.
     */
    requestEmailVerify: function(email, options) {
      var json = { email: email };
      var request = AV._request("requestEmailVerify", null, null, "POST",
                                   json);
      return request._thenRunCallbacks(options);
    },

   /**
    * @Deprecated typo error, please use requestEmailVerify
    */
    requestEmailVerfiy: function(email, options) {
      var json = { email: email };
      var request = AV._request("requestEmailVerify", null, null, "POST",
                                   json);
      return request._thenRunCallbacks(options);
    },

    /**
     * Requests a verify sms code to be sent to the specified mobile phone
     * number associated with the user account. This sms code allows the user to
     * verify their mobile phone number by calling AV.User.verifyMobilePhone
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {String} mobilePhone The mobile phone number  associated with the
     *                  user that doesn't verify their mobile phone number.
     * @param {Object} options A Backbone-style options object.
     */
    requestMobilePhoneVerify: function(mobilePhone, options){
      var json = { mobilePhoneNumber: mobilePhone };
      var request = AV._request("requestMobilePhoneVerify", null, null, "POST",
                                   json);
      return request._thenRunCallbacks(options);
    },


    /**
     * Requests a reset password sms code to be sent to the specified mobile phone
     * number associated with the user account. This sms code allows the user to
     * reset their account's password by calling AV.User.resetPasswordBySmsCode
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {String} mobilePhone The mobile phone number  associated with the
     *                  user that doesn't verify their mobile phone number.
     * @param {Object} options A Backbone-style options object.
     */
    requestPasswordResetBySmsCode: function(mobilePhone, options){
      var json = { mobilePhoneNumber: mobilePhone };
      var request = AV._request("requestPasswordResetBySmsCode", null, null, "POST",
                                   json);
      return request._thenRunCallbacks(options);
    },

    /**
     * Makes a call to reset user's account password by sms code and new password.
    * The sms code is sent by AV.User.requestPasswordResetBySmsCode.
     * @param {String} code The sms code sent by AV.User.Cloud.requestSmsCode
     * @param {String} password The new password.
     * @param {Object} options A Backbone-style options object
     * @return {AV.Promise} A promise that will be resolved with the result
     * of the function.
     */
    resetPasswordBySmsCode: function(code, password, options){
      var json = { password: password};
      var request = AV._request("resetPasswordBySmsCode", null, code, "PUT",
                                json);
      return request._thenRunCallbacks(options);
    },

    /**
     * Makes a call to verify sms code that sent by AV.User.Cloud.requestSmsCode
     * If verify successfully,the user mobilePhoneVerified attribute will be true.
     * @param {String} code The sms code sent by AV.User.Cloud.requestSmsCode
     * @param {Object} options A Backbone-style options object
     * @return {AV.Promise} A promise that will be resolved with the result
     * of the function.
     */
    verifyMobilePhone: function(code, options){
      var request = AV._request("verifyMobilePhone", null, code, "POST",
                                null);
      return request._thenRunCallbacks(options);
    },

    /**
     * Requests a logIn sms code to be sent to the specified mobile phone
     * number associated with the user account. This sms code allows the user to
     * login by AV.User.logInWithMobilePhoneSmsCode function.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @param {String} mobilePhone The mobile phone number  associated with the
     *           user that want to login by AV.User.logInWithMobilePhoneSmsCode
     * @param {Object} options A Backbone-style options object.
     */
    requestLoginSmsCode: function(mobilePhone, options){
      var json = { mobilePhoneNumber: mobilePhone };
      var request = AV._request("requestLoginSmsCode", null, null, "POST",
                                   json);
      return request._thenRunCallbacks(options);
    },

    /**
     * Retrieves the currently logged in AVUser with a valid session,
     * either from memory or localStorage, if necessary.
     * @return {AV.Promise} resolved with the currently logged in AV.User.
     */
    currentAsync: function() {
      if (AV.User._currentUser) {
        return AV.Promise.as(AV.User._currentUser);
      }

      if (AV.User._currentUserMatchesDisk) {

        return AV.Promise.as(AV.User._currentUser);
      }


      return AV.localStorage.getItemAsync(
        AV._getAVPath(AV.User._CURRENT_USER_KEY)
      ).then(function(userData) {
        if (!userData) {
          return null;
        }

        // Load the user from local storage.
        AV.User._currentUserMatchesDisk = true;

        AV.User._currentUser = AV.Object._create("_User");
        AV.User._currentUser._isCurrentUser = true;

        var json = JSON.parse(userData);
        AV.User._currentUser.id = json._id;
        delete json._id;
        AV.User._currentUser._sessionToken = json._sessionToken;
        delete json._sessionToken;
        AV.User._currentUser._finishFetch(json);
        //AV.User._currentUser.set(json);

        AV.User._currentUser._synchronizeAllAuthData();
        AV.User._currentUser._refreshCache();
        AV.User._currentUser._opSetQueue = [{}];
        return AV.User._currentUser;
      });
    },

    /**
     * Retrieves the currently logged in AVUser with a valid session,
     * either from memory or localStorage, if necessary.
     * @return {AV.Object} The currently logged in AV.User.
     */
    current: function() {
      if (AV.User._currentUser) {
        return AV.User._currentUser;
      }

      if (AV.User._currentUserMatchesDisk) {

        return AV.User._currentUser;
      }

      // Load the user from local storage.
      AV.User._currentUserMatchesDisk = true;

      var userData = AV.localStorage.getItem(AV._getAVPath(
          AV.User._CURRENT_USER_KEY));
      if (!userData) {

        return null;
      }
      AV.User._currentUser = AV.Object._create("_User");
      AV.User._currentUser._isCurrentUser = true;

      var json = JSON.parse(userData);
      AV.User._currentUser.id = json._id;
      delete json._id;
      AV.User._currentUser._sessionToken = json._sessionToken;
      delete json._sessionToken;
      AV.User._currentUser._finishFetch(json);
      //AV.User._currentUser.set(json);

      AV.User._currentUser._synchronizeAllAuthData();
      AV.User._currentUser._refreshCache();
      AV.User._currentUser._opSetQueue = [{}];
      return AV.User._currentUser;
    },

    /**
     * Persists a user as currentUser to localStorage, and into the singleton.
     */
    _saveCurrentUser: function(user) {
      var promise;
      if (AV.User._currentUser !== user) {
        promise = AV.User.logOut();
      }
      else {
        promise = AV.Promise.as();
      }
      return promise.then(function() {
        user._isCurrentUser = true;
        AV.User._currentUser = user;

        var json = user.toJSON();
        json._id = user.id;
        json._sessionToken = user._sessionToken;
        return AV.localStorage.setItemAsync(
          AV._getAVPath(AV.User._CURRENT_USER_KEY),
          JSON.stringify(json)
        ).then(function() {
          AV.User._currentUserMatchesDisk = true;
        });
      });
    },

    _registerAuthenticationProvider: function(provider) {
      AV.User._authProviders[provider.getAuthType()] = provider;
      // Synchronize the current user with the auth provider.
      if (AV.User.current()) {
        AV.User.current()._synchronizeAuthData(provider.getAuthType());
      }
    },

    _logInWith: function(provider, options) {
      var user = AV.Object._create("_User");
      return user._linkWith(provider, options);
    }

  });
};

function filterOutCallbacks(options) {
  var newOptions = _.clone(options) || {};
  delete newOptions.success;
  delete newOptions.error;
  return newOptions;
}

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/user.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],29:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

/*global _: false, $: false, localStorage: false, process: true,
  XMLHttpRequest: false, XDomainRequest: false, exports: false,
  require: false */
module.exports = function(AV) {
  /**
   * Contains all AV API classes and functions.
   * @name AV
   * @namespace
   *
   * Contains all AV API classes and functions.
   */

  // If jQuery or Zepto has been included, grab a reference to it.
  if (typeof($) !== "undefined") {
    AV.$ = $;
  }

  // Helpers
  // -------

  // Shared empty constructor function to aid in prototype-chain creation.
  var EmptyConstructor = function() {};


  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var inherits = function(parent, protoProps, staticProps) {
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && protoProps.hasOwnProperty('constructor')) {
      child = protoProps.constructor;
    } else {
      /** @ignore */
      child = function(){ parent.apply(this, arguments); };
    }

    // Inherit class (static) properties from parent.
    AV._.extend(child, parent);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    EmptyConstructor.prototype = parent.prototype;
    child.prototype = new EmptyConstructor();

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) {
      AV._.extend(child.prototype, protoProps);
    }

    // Add static properties to the constructor function, if supplied.
    if (staticProps) {
      AV._.extend(child, staticProps);
    }

    // Correctly set child's `prototype.constructor`.
    child.prototype.constructor = child;

    // Set a convenience property in case the parent's prototype is
    // needed later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set the server for AV to talk to.
  AV.serverURL = "https://api.leancloud.cn";

  // Check whether we are running in Node.js.
  if (typeof(process) !== "undefined" &&
      process.versions &&
      process.versions.node) {
    AV._isNode = true;
  }

  /**
   * Call this method first to set up your authentication tokens for AV.
   * You can get your keys from the Data Browser on avoscloud.com.
   * @param {String} applicationId Your AV Application ID.
   * @param {String} applicationKey Your AV JavaScript Key.
   * @param {String} masterKey (optional) Your AVOSCloud Master Key. (Node.js only!).
   */
  AV.initialize = function(applicationId, applicationKey, masterKey) {
    if (masterKey) {
      throw new Error("AV.initialize() was passed a Master Key, which is only " +
        "allowed from within Node.js.");
    }
    AV._initialize(applicationId, applicationKey,masterKey);
  };

  /**
   * Call this method first to set up authentication tokens for AV.
   * This method is for AV's own private use.
   * @param {String} applicationId Your AV Application ID.
   * @param {String} applicationKey Your AV Application Key
   */
   AV._initialize = function(applicationId, applicationKey, masterKey) {
    if (AV.applicationId !== undefined &&
        applicationId !== AV.applicationId  &&
        applicationKey !== AV.applicationKey &&
        masterKey !== AV.masterKey) {
      console.warn('AVOSCloud SDK is already initialized, please don\'t reinitialize it.');
    }
    AV.applicationId = applicationId;
    AV.applicationKey = applicationKey;
    AV.masterKey = masterKey;
    AV._useMasterKey = false;
  };


  /**
   * Call this method to set production environment variable.
   * @param {Boolean} production True is production environment,and
   *  it's true by default.
   */
  AV.setProduction = function(production){
    if(!AV._isNullOrUndefined(production)) {
      //make sure it's a number
      production = production ? 1 : 0;
    }
    //default is 1
    AV.applicationProduction = AV._isNullOrUndefined(production) ? 1: production;
  };

  // If we're running in node.js, allow using the master key.
  if (AV._isNode) {
    AV.initialize = AV._initialize;

    AV.Cloud = AV.Cloud || {};
    /**
     * Switches the AVOSCloud SDK to using the Master key.  The Master key grants
     * priveleged access to the data in AVOSCloud and can be used to bypass ACLs and
     * other restrictions that are applied to the client SDKs.
     * <p><strong><em>Available in Cloud Code and Node.js only.</em></strong>
     * </p>
     */
    AV.Cloud.useMasterKey = function() {
      AV._useMasterKey = true;
    };
  }


   /**
    *Use china avoscloud API service:https://cn.avoscloud.com
    */
   AV.useAVCloudCN = function(){
    AV.serverURL = "https://leancloud.cn";
   };

   /**
    *Use USA avoscloud API service:https://us.avoscloud.com
    */
   AV.useAVCloudUS = function(){
    AV.serverURL = "https://us-api.leancloud.cn";
   };

  /**
   * Returns prefix for localStorage keys used by this instance of AV.
   * @param {String} path The relative suffix to append to it.
   *     null or undefined is treated as the empty string.
   * @return {String} The full key name.
   */
  AV._getAVPath = function(path) {
    if (!AV.applicationId) {
      throw "You need to call AV.initialize before using AV.";
    }
    if (!path) {
      path = "";
    }
    if (!AV._.isString(path)) {
      throw "Tried to get a localStorage path that wasn't a String.";
    }
    if (path[0] === "/") {
      path = path.substring(1);
    }
    return "AV/" + AV.applicationId + "/" + path;
  };

  /**
   * Returns the unique string for this app on this machine.
   * Gets reset when localStorage is cleared.
   */
  AV._installationId = null;
  AV._getInstallationId = function() {
    // See if it's cached in RAM.
    if (AV._installationId) {
      return AV.Promise.as(AV._installationId);
    }

    // Try to get it from localStorage.
    var path = AV._getAVPath("installationId");
    return AV.localStorage.getItemAsync(path).then(function(_installationId){
      AV._installationId = _installationId;
      if (!AV._installationId) {
        // It wasn't in localStorage, so create a new one.
        var hexOctet = function() {
          return Math.floor((1+Math.random())*0x10000).toString(16).substring(1);
        };
        AV._installationId = (
          hexOctet() + hexOctet() + "-" +
          hexOctet() + "-" +
          hexOctet() + "-" +
          hexOctet() + "-" +
          hexOctet() + hexOctet() + hexOctet());
        return AV.localStorage.setItemAsync(path, AV._installationId);
      }
      else {
        return _installationId;
      }
    });
  };

  AV._parseDate = function(iso8601) {
    var regexp = new RegExp(
      "^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})" + "T" +
      "([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})" +
      "(.([0-9]+))?" + "Z$");
    var match = regexp.exec(iso8601);
    if (!match) {
      return null;
    }

    var year = match[1] || 0;
    var month = (match[2] || 1) - 1;
    var day = match[3] || 0;
    var hour = match[4] || 0;
    var minute = match[5] || 0;
    var second = match[6] || 0;
    var milli = match[8] || 0;

    return new Date(Date.UTC(year, month, day, hour, minute, second, milli));
  };

  AV._ajaxIE8 = function(method, url, data) {
    var promise = new AV.Promise();
    var xdr = new XDomainRequest();
    xdr.onload = function() {
      var response;
      try {
        response = JSON.parse(xdr.responseText);
      } catch (e) {
        promise.reject(e);
      }
      if (response) {
        promise.resolve(response);
      }
    };
    xdr.onerror = xdr.ontimeout = function() {
      // Let's fake a real error message.
      var fakeResponse = {
        responseText: JSON.stringify({
          code: AV.Error.X_DOMAIN_REQUEST,
          error: "IE's XDomainRequest does not supply error info."
        })
      };
      promise.reject(xdr);
    };
    xdr.onprogress = function() {};
    xdr.open(method, url);
    xdr.send(data);
    return promise;
  };

   AV._useXDomainRequest = function() {
       if (typeof(XDomainRequest) !== "undefined") {
           // We're in IE 8+.
           if ('withCredentials' in new XMLHttpRequest()) {
               // We're in IE 10+.
               return false;
           }
           return true;
       }
       return false;
   };

  AV._ajax = function(method, url, data, success, error) {
    var options = {
      success: success,
      error: error
    };

    if (AV._useXDomainRequest()) {
      return AV._ajaxIE8(method, url, data)._thenRunCallbacks(options);
    }

    var promise = new AV.Promise();
    var handled = false;

    var xhr = new AV.XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4) {
        if (handled) {
          return;
        }
        handled = true;

        if (xhr.status >= 200 && xhr.status < 300) {
          var response;
          try {
            response = JSON.parse(xhr.responseText);
          } catch (e) {
            promise.reject(e);
          }
          if (response) {
            promise.resolve(response, xhr.status, xhr);
          }
        } else {
          promise.reject(xhr);
        }
      }
    };
    xhr.open(method, url, true);
    xhr.setRequestHeader("Content-Type", "text/plain");  // avoid pre-flight.
    if (AV._isNode) {
      // Add a special user agent just for request from node.js.
      xhr.setRequestHeader("User-Agent",
                           "AV/" + AV.VERSION +
                           " (NodeJS " + process.versions.node + ")");
    }
    xhr.send(data);
    return promise._thenRunCallbacks(options);
  };

  // A self-propagating extend function.
  AV._extend = function(protoProps, classProps) {
    var child = inherits(this, protoProps, classProps);
    child.extend = this.extend;
    return child;
  };

  /**
   * route is classes, users, login, etc.
   * objectId is null if there is no associated objectId.
   * method is the http method for the REST API.
   * dataObject is the payload as an object, or null if there is none.
   * @ignore
   */
  AV._request = function(route, className, objectId, method, dataObject) {
    if (!AV.applicationId) {
      throw "You must specify your applicationId using AV.initialize";
    }

    if (!AV.applicationKey && !AV.masterKey) {
      throw "You must specify a key using AV.initialize";
    }


    if (route !== "batch" &&
        route !== "classes" &&
        route !== "files" &&
        route !== "date" &&
        route !== "functions" &&
        route !== "login" &&
        route !== "push" &&
        route !== "search/select" &&
        route !== "requestPasswordReset" &&
        route !== "requestEmailVerify" &&
        route !== "requestPasswordResetBySmsCode" &&
        route !== "resetPasswordBySmsCode" &&
        route !== "requestMobilePhoneVerify" &&
        route !== "requestLoginSmsCode" &&
        route !== "verifyMobilePhone" &&
        route !== "requestSmsCode" &&
        route !== "verifySmsCode" &&
        route !== "users" &&
        route !== "usersByMobilePhone" &&
        route !== "cloudQuery" &&
        route !== "qiniu" &&
        route !== "statuses" &&
        route !== "bigquery" &&
        route !== 'search/select' &&
        route !== 'subscribe/statuses/count' &&
        route !== 'subscribe/statuses' &&
        !(/users\/[^\/]+\/updatePassword/.test(route)) &&
        !(/users\/[^\/]+\/friendship\/[^\/]+/.test(route))) {
      throw "Bad route: '" + route + "'.";
    }

    var url = AV.serverURL;
    if (url.charAt(url.length - 1) !== "/") {
      url += "/";
    }
    url += "1.1/" + route;
    if (className) {
      url += "/" + className;
    }
    if (objectId) {
      url += "/" + objectId;
    }
    if ((route ==='users' || route === 'classes') && dataObject && dataObject._fetchWhenSave){
      delete dataObject._fetchWhenSave;
      url += '?new=true';
    }

    dataObject = AV._.clone(dataObject || {});
    if (method !== "POST") {
      dataObject._method = method;
      method = "POST";
    }

    dataObject._ApplicationId = AV.applicationId;
    dataObject._ApplicationKey = AV.applicationKey;
    if(!AV._isNullOrUndefined(AV.applicationProduction)) {
      dataObject._ApplicationProduction = AV.applicationProduction;
    }
    if(AV._useMasterKey)
        dataObject._MasterKey = AV.masterKey;
    dataObject._ClientVersion = AV.VERSION;
    // Pass the session token on every request.
    return AV.User.currentAsync().then(function(currentUser) {
      if (currentUser && currentUser._sessionToken) {
        dataObject._SessionToken = currentUser._sessionToken;
      }
      return AV._getInstallationId();
    }).then(function(_InstallationId) {
      dataObject._InstallationId = _InstallationId;
      
      var data = JSON.stringify(dataObject);
      return AV._ajax(method, url, data).then(null, function(response) {
        // Transform the error into an instance of AV.Error by trying to parse
        // the error string as JSON.
        var error;
        if (response && response.responseText) {
          try {
            var errorJSON = JSON.parse(response.responseText);
            if (errorJSON) {
              error = new AV.Error(errorJSON.code, errorJSON.error);
            }
          } catch (e) {
            // If we fail to parse the error text, that's okay.
          }
        }
        error = error || new AV.Error(-1, response.responseText);
        // By explicitly returning a rejected Promise, this will work with
        // either jQuery or Promises/A semantics.
        return AV.Promise.error(error);
      });
    });
  };

  // Helper function to get a value from a Backbone object as a property
  // or as a function.
  AV._getValue = function(object, prop) {
    if (!(object && object[prop])) {
      return null;
    }
    return AV._.isFunction(object[prop]) ? object[prop]() : object[prop];
  };

  /**
   * Converts a value in a AV Object into the appropriate representation.
   * This is the JS equivalent of Java's AV.maybeReferenceAndEncode(Object)
   * if seenObjects is falsey. Otherwise any AV.Objects not in
   * seenObjects will be fully embedded rather than encoded
   * as a pointer.  This array will be used to prevent going into an infinite
   * loop because we have circular references.  If <seenObjects>
   * is set, then none of the AV Objects that are serialized can be dirty.
   */
  AV._encode = function(value, seenObjects, disallowObjects) {
    var _ = AV._;
    if (value instanceof AV.Object) {
      if (disallowObjects) {
        throw "AV.Objects not allowed here";
      }
      if (!seenObjects || _.include(seenObjects, value) || !value._hasData) {
        return value._toPointer();
      }
      if (!value.dirty()) {
        seenObjects = seenObjects.concat(value);
        return AV._encode(value._toFullJSON(seenObjects),
                             seenObjects,
                             disallowObjects);
      }
      throw "Tried to save an object with a pointer to a new, unsaved object.";
    }
    if (value instanceof AV.ACL) {
      return value.toJSON();
    }
    if (_.isDate(value)) {
      return { "__type": "Date", "iso": value.toJSON() };
    }
    if (value instanceof AV.GeoPoint) {
      return value.toJSON();
    }
    if (_.isArray(value)) {
      return _.map(value, function(x) {
        return AV._encode(x, seenObjects, disallowObjects);
      });
    }
    if (_.isRegExp(value)) {
      return value.source;
    }
    if (value instanceof AV.Relation) {
      return value.toJSON();
    }
    if (value instanceof AV.Op) {
      return value.toJSON();
    }
    if (value instanceof AV.File) {
      if (!value.url() && !value.id) {
        throw "Tried to save an object containing an unsaved file.";
      }
      return {
        __type: "File",
        id:  value.id,
        name: value.name(),
        url: value.url()
      };
    }
    if (_.isObject(value)) {
      var output = {};
      AV._objectEach(value, function(v, k) {
        output[k] = AV._encode(v, seenObjects, disallowObjects);
      });
      return output;
    }
    return value;
  };

  /**
   * The inverse function of AV._encode.
   * TODO: make decode not mutate value.
   */
  AV._decode = function(key, value) {
    var _ = AV._;
    if (!_.isObject(value)) {
      return value;
    }
    if (_.isArray(value)) {
      AV._arrayEach(value, function(v, k) {
        value[k] = AV._decode(k, v);
      });
      return value;
    }
    if (value instanceof AV.Object) {
      return value;
    }
    if (value instanceof AV.File) {
      return value;
    }
    if (value instanceof AV.Op) {
      return value;
    }
    if (value.__op) {
      return AV.Op._decode(value);
    }
    if (value.__type === "Pointer") {
      var className = value.className;
      var pointer = AV.Object._create(className);
      if(value.createdAt){
          delete value.__type;
          delete value.className;
          pointer._finishFetch(value, true);
      }else{
          pointer._finishFetch({ objectId: value.objectId }, false);
      }
      return pointer;
    }
    if (value.__type === "Object") {
      // It's an Object included in a query result.
      var className = value.className;
      delete value.__type;
      delete value.className;
      var object = AV.Object._create(className);
      object._finishFetch(value, true);
      return object;
    }
    if (value.__type === "Date") {
      return AV._parseDate(value.iso);
    }
    if (value.__type === "GeoPoint") {
      return new AV.GeoPoint({
        latitude: value.latitude,
        longitude: value.longitude
      });
    }
    if (key === "ACL") {
      if (value instanceof AV.ACL) {
        return value;
      }
      return new AV.ACL(value);
    }
    if (value.__type === "Relation") {
      var relation = new AV.Relation(null, key);
      relation.targetClassName = value.className;
      return relation;
    }
    if (value.__type === "File") {
      var file = new AV.File(value.name);
      file._metaData = value.metaData || {};
      file._url = value.url;
      file.id = value.objectId;
      return file;
    }
    AV._objectEach(value, function(v, k) {
      value[k] = AV._decode(k, v);
    });
    return value;
  };

  AV._arrayEach = AV._.each;

  /**
   * Does a deep traversal of every item in object, calling func on every one.
   * @param {Object} object The object or array to traverse deeply.
   * @param {Function} func The function to call for every item. It will
   *     be passed the item as an argument. If it returns a truthy value, that
   *     value will replace the item in its parent container.
   * @returns {} the result of calling func on the top-level object itself.
   */
  AV._traverse = function(object, func, seen) {
    if (object instanceof AV.Object) {
      seen = seen || [];
      if (AV._.indexOf(seen, object) >= 0) {
        // We've already visited this object in this call.
        return;
      }
      seen.push(object);
      AV._traverse(object.attributes, func, seen);
      return func(object);
    }
    if (object instanceof AV.Relation || object instanceof AV.File) {
      // Nothing needs to be done, but we don't want to recurse into the
      // object's parent infinitely, so we catch this case.
      return func(object);
    }
    if (AV._.isArray(object)) {
      AV._.each(object, function(child, index) {
        var newChild = AV._traverse(child, func, seen);
        if (newChild) {
          object[index] = newChild;
        }
      });
      return func(object);
    }
    if (AV._.isObject(object)) {
      AV._each(object, function(child, key) {
        var newChild = AV._traverse(child, func, seen);
        if (newChild) {
          object[key] = newChild;
        }
      });
      return func(object);
    }
    return func(object);
  };

  /**
   * This is like _.each, except:
   * * it doesn't work for so-called array-like objects,
   * * it does work for dictionaries with a "length" attribute.
   */
  AV._objectEach = AV._each = function(obj, callback) {
    var _ = AV._;
    if (_.isObject(obj)) {
      _.each(_.keys(obj), function(key) {
        callback(obj[key], key);
      });
    } else {
      _.each(obj, callback);
    }
  };

  // Helper function to check null or undefined.
  AV._isNullOrUndefined = function(x) {
    return AV._.isNull(x) || AV._.isUndefined(x);
  };
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/utils.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],30:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

module.exports = "js1.0.0-rc3";

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/version.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38}],31:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

var _ = require('underscore');

/*global _: false, document: false */
module.exports = function(AV) {
  /**
   * Creating a AV.View creates its initial element outside of the DOM,
   * if an existing element is not provided...
   * @class
   *
   * <p>A fork of Backbone.View, provided for your convenience.  If you use this
   * class, you must also include jQuery, or another library that provides a
   * jQuery-compatible $ function.  For more information, see the
   * <a href="http://documentcloud.github.com/backbone/#View">Backbone
   * documentation</a>.</p>
   * <p><strong><em>Available in the client SDK only.</em></strong></p>
   */
  AV.View = function(options) {
    console.warn("AV.View is deprecated, please don't use it anymore.");
    this.cid = _.uniqueId('view');
    this._configure(options || {});
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var eventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.

  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes',
                     'className', 'tagName'];

  // Set up all inheritable **AV.View** properties and methods.
  _.extend(AV.View.prototype, AV.Events,
           /** @lends AV.View.prototype */ {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    /**
     * jQuery delegate for element lookup, scoped to DOM elements within the
     * current view. This should be prefered to global lookups where possible.
     */
    $: function(selector) {
      return this.$el.find(selector);
    },

    /**
     * Initialize is an empty function by default. Override it with your own
     * initialization logic.
     */
    initialize: function(){},

    /**
     * The core function that your view should override, in order
     * to populate its element (`this.el`), with the appropriate HTML. The
     * convention is for **render** to always return `this`.
     */
    render: function() {
      return this;
    },

    /**
     * Remove this view from the DOM. Note that the view isn't present in the
     * DOM by default, so calling this method may be a no-op.
     */
    remove: function() {
      this.$el.remove();
      return this;
    },

    /**
     * For small amounts of DOM Elements, where a full-blown template isn't
     * needed, use **make** to manufacture elements, one at a time.
     * <pre>
     *     var el = this.make('li', {'class': 'row'},
     *                        this.model.escape('title'));</pre>
     */
    make: function(tagName, attributes, content) {
      var el = document.createElement(tagName);
      if (attributes) {
        AV.$(el).attr(attributes);
      }
      if (content) {
        AV.$(el).html(content);
      }
      return el;
    },

    /**
     * Changes the view's element (`this.el` property), including event
     * re-delegation.
     */
    setElement: function(element, delegate) {
      this.$el = AV.$(element);
      this.el = this.$el[0];
      if (delegate !== false) {
        this.delegateEvents();
      }
      return this;
    },

    /**
     * Set callbacks.  <code>this.events</code> is a hash of
     * <pre>
     * *{"event selector": "callback"}*
     *
     *     {
     *       'mousedown .title':  'edit',
     *       'click .button':     'save'
     *       'click .open':       function(e) { ... }
     *     }
     * </pre>
     * pairs. Callbacks will be bound to the view, with `this` set properly.
     * Uses event delegation for efficiency.
     * Omitting the selector binds the event to `this.el`.
     * This only works for delegate-able events: not `focus`, `blur`, and
     * not `change`, `submit`, and `reset` in Internet Explorer.
     */
    delegateEvents: function(events) {
      events = events || AV._getValue(this, 'events');
      if (!events) {
        return;
      }
      this.undelegateEvents();
      var self = this;
      AV._objectEach(events, function(method, key) {
        if (!_.isFunction(method)) {
          method = self[events[key]];
        }
        if (!method) {
          throw new Error('Event "' + events[key] + '" does not exist');
        }
        var match = key.match(eventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, self);
        eventName += '.delegateEvents' + self.cid;
        if (selector === '') {
          self.$el.bind(eventName, method);
        } else {
          self.$el.delegate(selector, eventName, method);
        }
      });
    },

    /**
     * Clears all callbacks previously bound to the view with `delegateEvents`.
     * You usually don't need to use this, but may wish to if you have multiple
     * Backbone views attached to the same DOM element.
     */
    undelegateEvents: function() {
      this.$el.unbind('.delegateEvents' + this.cid);
    },

    /**
     * Performs the initial configuration of a View with a set of options.
     * Keys with special meaning *(model, collection, id, className)*, are
     * attached directly to the view.
     */
    _configure: function(options) {
      if (this.options) {
        options = _.extend({}, this.options, options);
      }
      var self = this;
      _.each(viewOptions, function(attr) {
        if (options[attr]) {
          self[attr] = options[attr];
        }
      });
      this.options = options;
    },

    /**
     * Ensure that the View has a DOM element to render into.
     * If `this.el` is a string, pass it through `$()`, take the first
     * matching element, and re-assign it to `el`. Otherwise, create
     * an element from the `id`, `className` and `tagName` properties.
     */
    _ensureElement: function() {
      if (!this.el) {
        var attrs = AV._getValue(this, 'attributes') || {};
        if (this.id) {
          attrs.id = this.id;
        }
        if (this.className) {
          attrs['class'] = this.className;
        }
        this.setElement(this.make(this.tagName, attrs), false);
      } else {
        this.setElement(this.el, false);
      }
    }

  });

  /**
   * @function
   * @param {Object} instanceProps Instance properties for the view.
   * @param {Object} classProps Class properies for the view.
   * @return {Class} A new subclass of <code>AV.View</code>.
   */
  AV.View.extend = AV._extend;

};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/lib/view.js","/../../node_modules/avoscloud-sdk/lib")
},{"buffer":35,"oMfpAn":38,"underscore":33}],32:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
(function(root) {
  var localStorageMemory = {};
  var cache = {};

  /**
   * number of stored items.
   */
  localStorageMemory.length = 0;

  /**
   * returns item for passed key, or null
   *
   * @para {String} key
   *       name of item to be returned
   * @returns {String|null}
   */
  localStorageMemory.getItem = function(key) {
    return cache[key] || null;
  };

  /**
   * sets item for key to passed value, as String
   *
   * @para {String} key
   *       name of item to be set
   * @para {String} value
   *       value, will always be turned into a String
   * @returns {undefined}
   */
  localStorageMemory.setItem = function(key, value) {
    if (typeof value === 'undefined') {
      localStorageMemory.removeItem(key);
    } else {
      cache[key] = '' + value;
      localStorageMemory.length++;
    }
  };

  /**
   * removes item for passed key
   *
   * @para {String} key
   *       name of item to be removed
   * @returns {undefined}
   */
  localStorageMemory.removeItem = function(key) {
    delete cache[key];
    localStorageMemory.length--;
  };

  /**
   * returns name of key at passed index
   *
   * @para {Number} index
   *       Position for key to be returned (starts at 0)
   * @returns {String|null}
   */
  localStorageMemory.key = function(index) {
    return Object.keys(cache)[index] || null;
  };

  /**
   * removes all stored items and sets length to 0
   *
   * @returns {undefined}
   */
  localStorageMemory.clear = function() {
    cache = {};
    localStorageMemory.length = 0;
  };

  if (typeof exports === 'object') {
    module.exports = localStorageMemory;
  } else {
    root.localStorageMemory = localStorageMemory;
  }
})(this);



}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/node_modules/localstorage-memory/lib/localstorage-memory.js","/../../node_modules/avoscloud-sdk/node_modules/localstorage-memory/lib")
},{"buffer":35,"oMfpAn":38}],33:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/avoscloud-sdk/node_modules/underscore/underscore.js","/../../node_modules/avoscloud-sdk/node_modules/underscore")
},{"buffer":35,"oMfpAn":38}],34:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/gulp-browserify/node_modules/browserify/node_modules/browser-resolve/empty.js","/../../node_modules/gulp-browserify/node_modules/browserify/node_modules/browser-resolve")
},{"buffer":35,"oMfpAn":38}],35:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = Buffer
exports.INSPECT_MAX_BYTES = 50
Buffer.poolSize = 8192

/**
 * If `Buffer._useTypedArrays`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (compatible down to IE6)
 */
Buffer._useTypedArrays = (function () {
  // Detect if browser supports Typed Arrays. Supported browsers are IE 10+, Firefox 4+,
  // Chrome 7+, Safari 5.1+, Opera 11.6+, iOS 4.2+. If the browser does not support adding
  // properties to `Uint8Array` instances, then that's the same as no `Uint8Array` support
  // because we need to be able to add all the node Buffer API methods. This is an issue
  // in Firefox 4-29. Now fixed: https://bugzilla.mozilla.org/show_bug.cgi?id=695438
  try {
    var buf = new ArrayBuffer(0)
    var arr = new Uint8Array(buf)
    arr.foo = function () { return 42 }
    return 42 === arr.foo() &&
        typeof arr.subarray === 'function' // Chrome 9-10 lack `subarray`
  } catch (e) {
    return false
  }
})()

/**
 * Class: Buffer
 * =============
 *
 * The Buffer constructor returns instances of `Uint8Array` that are augmented
 * with function properties for all the node `Buffer` API functions. We use
 * `Uint8Array` so that square bracket notation works as expected -- it returns
 * a single octet.
 *
 * By augmenting the instances, we can avoid modifying the `Uint8Array`
 * prototype.
 */
function Buffer (subject, encoding, noZero) {
  if (!(this instanceof Buffer))
    return new Buffer(subject, encoding, noZero)

  var type = typeof subject

  // Workaround: node's base64 implementation allows for non-padded strings
  // while base64-js does not.
  if (encoding === 'base64' && type === 'string') {
    subject = stringtrim(subject)
    while (subject.length % 4 !== 0) {
      subject = subject + '='
    }
  }

  // Find the length
  var length
  if (type === 'number')
    length = coerce(subject)
  else if (type === 'string')
    length = Buffer.byteLength(subject, encoding)
  else if (type === 'object')
    length = coerce(subject.length) // assume that object is array-like
  else
    throw new Error('First argument needs to be a number, array or string.')

  var buf
  if (Buffer._useTypedArrays) {
    // Preferred: Return an augmented `Uint8Array` instance for best performance
    buf = Buffer._augment(new Uint8Array(length))
  } else {
    // Fallback: Return THIS instance of Buffer (created by `new`)
    buf = this
    buf.length = length
    buf._isBuffer = true
  }

  var i
  if (Buffer._useTypedArrays && typeof subject.byteLength === 'number') {
    // Speed optimization -- use set if we're copying from a typed array
    buf._set(subject)
  } else if (isArrayish(subject)) {
    // Treat array-ish objects as a byte array
    for (i = 0; i < length; i++) {
      if (Buffer.isBuffer(subject))
        buf[i] = subject.readUInt8(i)
      else
        buf[i] = subject[i]
    }
  } else if (type === 'string') {
    buf.write(subject, 0, encoding)
  } else if (type === 'number' && !Buffer._useTypedArrays && !noZero) {
    for (i = 0; i < length; i++) {
      buf[i] = 0
    }
  }

  return buf
}

// STATIC METHODS
// ==============

Buffer.isEncoding = function (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'raw':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.isBuffer = function (b) {
  return !!(b !== null && b !== undefined && b._isBuffer)
}

Buffer.byteLength = function (str, encoding) {
  var ret
  str = str + ''
  switch (encoding || 'utf8') {
    case 'hex':
      ret = str.length / 2
      break
    case 'utf8':
    case 'utf-8':
      ret = utf8ToBytes(str).length
      break
    case 'ascii':
    case 'binary':
    case 'raw':
      ret = str.length
      break
    case 'base64':
      ret = base64ToBytes(str).length
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = str.length * 2
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.concat = function (list, totalLength) {
  assert(isArray(list), 'Usage: Buffer.concat(list, [totalLength])\n' +
      'list should be an Array.')

  if (list.length === 0) {
    return new Buffer(0)
  } else if (list.length === 1) {
    return list[0]
  }

  var i
  if (typeof totalLength !== 'number') {
    totalLength = 0
    for (i = 0; i < list.length; i++) {
      totalLength += list[i].length
    }
  }

  var buf = new Buffer(totalLength)
  var pos = 0
  for (i = 0; i < list.length; i++) {
    var item = list[i]
    item.copy(buf, pos)
    pos += item.length
  }
  return buf
}

// BUFFER INSTANCE METHODS
// =======================

function _hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  assert(strLen % 2 === 0, 'Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; i++) {
    var byte = parseInt(string.substr(i * 2, 2), 16)
    assert(!isNaN(byte), 'Invalid hex string')
    buf[offset + i] = byte
  }
  Buffer._charsWritten = i * 2
  return i
}

function _utf8Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf8ToBytes(string), buf, offset, length)
  return charsWritten
}

function _asciiWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(asciiToBytes(string), buf, offset, length)
  return charsWritten
}

function _binaryWrite (buf, string, offset, length) {
  return _asciiWrite(buf, string, offset, length)
}

function _base64Write (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(base64ToBytes(string), buf, offset, length)
  return charsWritten
}

function _utf16leWrite (buf, string, offset, length) {
  var charsWritten = Buffer._charsWritten =
    blitBuffer(utf16leToBytes(string), buf, offset, length)
  return charsWritten
}

Buffer.prototype.write = function (string, offset, length, encoding) {
  // Support both (string, offset, length, encoding)
  // and the legacy (string, encoding, offset, length)
  if (isFinite(offset)) {
    if (!isFinite(length)) {
      encoding = length
      length = undefined
    }
  } else {  // legacy
    var swap = encoding
    encoding = offset
    offset = length
    length = swap
  }

  offset = Number(offset) || 0
  var remaining = this.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }
  encoding = String(encoding || 'utf8').toLowerCase()

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexWrite(this, string, offset, length)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Write(this, string, offset, length)
      break
    case 'ascii':
      ret = _asciiWrite(this, string, offset, length)
      break
    case 'binary':
      ret = _binaryWrite(this, string, offset, length)
      break
    case 'base64':
      ret = _base64Write(this, string, offset, length)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leWrite(this, string, offset, length)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toString = function (encoding, start, end) {
  var self = this

  encoding = String(encoding || 'utf8').toLowerCase()
  start = Number(start) || 0
  end = (end !== undefined)
    ? Number(end)
    : end = self.length

  // Fastpath empty strings
  if (end === start)
    return ''

  var ret
  switch (encoding) {
    case 'hex':
      ret = _hexSlice(self, start, end)
      break
    case 'utf8':
    case 'utf-8':
      ret = _utf8Slice(self, start, end)
      break
    case 'ascii':
      ret = _asciiSlice(self, start, end)
      break
    case 'binary':
      ret = _binarySlice(self, start, end)
      break
    case 'base64':
      ret = _base64Slice(self, start, end)
      break
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      ret = _utf16leSlice(self, start, end)
      break
    default:
      throw new Error('Unknown encoding')
  }
  return ret
}

Buffer.prototype.toJSON = function () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function (target, target_start, start, end) {
  var source = this

  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (!target_start) target_start = 0

  // Copy 0 bytes; we're done
  if (end === start) return
  if (target.length === 0 || source.length === 0) return

  // Fatal error conditions
  assert(end >= start, 'sourceEnd < sourceStart')
  assert(target_start >= 0 && target_start < target.length,
      'targetStart out of bounds')
  assert(start >= 0 && start < source.length, 'sourceStart out of bounds')
  assert(end >= 0 && end <= source.length, 'sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length)
    end = this.length
  if (target.length - target_start < end - start)
    end = target.length - target_start + start

  var len = end - start

  if (len < 100 || !Buffer._useTypedArrays) {
    for (var i = 0; i < len; i++)
      target[i + target_start] = this[i + start]
  } else {
    target._set(this.subarray(start, start + len), target_start)
  }
}

function _base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function _utf8Slice (buf, start, end) {
  var res = ''
  var tmp = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++) {
    if (buf[i] <= 0x7F) {
      res += decodeUtf8Char(tmp) + String.fromCharCode(buf[i])
      tmp = ''
    } else {
      tmp += '%' + buf[i].toString(16)
    }
  }

  return res + decodeUtf8Char(tmp)
}

function _asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; i++)
    ret += String.fromCharCode(buf[i])
  return ret
}

function _binarySlice (buf, start, end) {
  return _asciiSlice(buf, start, end)
}

function _hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; i++) {
    out += toHex(buf[i])
  }
  return out
}

function _utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i+1] * 256)
  }
  return res
}

Buffer.prototype.slice = function (start, end) {
  var len = this.length
  start = clamp(start, len, 0)
  end = clamp(end, len, len)

  if (Buffer._useTypedArrays) {
    return Buffer._augment(this.subarray(start, end))
  } else {
    var sliceLen = end - start
    var newBuf = new Buffer(sliceLen, undefined, true)
    for (var i = 0; i < sliceLen; i++) {
      newBuf[i] = this[i + start]
    }
    return newBuf
  }
}

// `get` will be removed in Node 0.13+
Buffer.prototype.get = function (offset) {
  console.log('.get() is deprecated. Access using array indexes instead.')
  return this.readUInt8(offset)
}

// `set` will be removed in Node 0.13+
Buffer.prototype.set = function (v, offset) {
  console.log('.set() is deprecated. Access using array indexes instead.')
  return this.writeUInt8(v, offset)
}

Buffer.prototype.readUInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  return this[offset]
}

function _readUInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    val = buf[offset]
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
  } else {
    val = buf[offset] << 8
    if (offset + 1 < len)
      val |= buf[offset + 1]
  }
  return val
}

Buffer.prototype.readUInt16LE = function (offset, noAssert) {
  return _readUInt16(this, offset, true, noAssert)
}

Buffer.prototype.readUInt16BE = function (offset, noAssert) {
  return _readUInt16(this, offset, false, noAssert)
}

function _readUInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val
  if (littleEndian) {
    if (offset + 2 < len)
      val = buf[offset + 2] << 16
    if (offset + 1 < len)
      val |= buf[offset + 1] << 8
    val |= buf[offset]
    if (offset + 3 < len)
      val = val + (buf[offset + 3] << 24 >>> 0)
  } else {
    if (offset + 1 < len)
      val = buf[offset + 1] << 16
    if (offset + 2 < len)
      val |= buf[offset + 2] << 8
    if (offset + 3 < len)
      val |= buf[offset + 3]
    val = val + (buf[offset] << 24 >>> 0)
  }
  return val
}

Buffer.prototype.readUInt32LE = function (offset, noAssert) {
  return _readUInt32(this, offset, true, noAssert)
}

Buffer.prototype.readUInt32BE = function (offset, noAssert) {
  return _readUInt32(this, offset, false, noAssert)
}

Buffer.prototype.readInt8 = function (offset, noAssert) {
  if (!noAssert) {
    assert(offset !== undefined && offset !== null,
        'missing offset')
    assert(offset < this.length, 'Trying to read beyond buffer length')
  }

  if (offset >= this.length)
    return

  var neg = this[offset] & 0x80
  if (neg)
    return (0xff - this[offset] + 1) * -1
  else
    return this[offset]
}

function _readInt16 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt16(buf, offset, littleEndian, true)
  var neg = val & 0x8000
  if (neg)
    return (0xffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt16LE = function (offset, noAssert) {
  return _readInt16(this, offset, true, noAssert)
}

Buffer.prototype.readInt16BE = function (offset, noAssert) {
  return _readInt16(this, offset, false, noAssert)
}

function _readInt32 (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  var len = buf.length
  if (offset >= len)
    return

  var val = _readUInt32(buf, offset, littleEndian, true)
  var neg = val & 0x80000000
  if (neg)
    return (0xffffffff - val + 1) * -1
  else
    return val
}

Buffer.prototype.readInt32LE = function (offset, noAssert) {
  return _readInt32(this, offset, true, noAssert)
}

Buffer.prototype.readInt32BE = function (offset, noAssert) {
  return _readInt32(this, offset, false, noAssert)
}

function _readFloat (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 3 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 23, 4)
}

Buffer.prototype.readFloatLE = function (offset, noAssert) {
  return _readFloat(this, offset, true, noAssert)
}

Buffer.prototype.readFloatBE = function (offset, noAssert) {
  return _readFloat(this, offset, false, noAssert)
}

function _readDouble (buf, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset + 7 < buf.length, 'Trying to read beyond buffer length')
  }

  return ieee754.read(buf, offset, littleEndian, 52, 8)
}

Buffer.prototype.readDoubleLE = function (offset, noAssert) {
  return _readDouble(this, offset, true, noAssert)
}

Buffer.prototype.readDoubleBE = function (offset, noAssert) {
  return _readDouble(this, offset, false, noAssert)
}

Buffer.prototype.writeUInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'trying to write beyond buffer length')
    verifuint(value, 0xff)
  }

  if (offset >= this.length) return

  this[offset] = value
}

function _writeUInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 2); i < j; i++) {
    buf[offset + i] =
        (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
            (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt16BE = function (value, offset, noAssert) {
  _writeUInt16(this, value, offset, false, noAssert)
}

function _writeUInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'trying to write beyond buffer length')
    verifuint(value, 0xffffffff)
  }

  var len = buf.length
  if (offset >= len)
    return

  for (var i = 0, j = Math.min(len - offset, 4); i < j; i++) {
    buf[offset + i] =
        (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeUInt32BE = function (value, offset, noAssert) {
  _writeUInt32(this, value, offset, false, noAssert)
}

Buffer.prototype.writeInt8 = function (value, offset, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset < this.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7f, -0x80)
  }

  if (offset >= this.length)
    return

  if (value >= 0)
    this.writeUInt8(value, offset, noAssert)
  else
    this.writeUInt8(0xff + value + 1, offset, noAssert)
}

function _writeInt16 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 1 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fff, -0x8000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt16(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt16(buf, 0xffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt16LE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt16BE = function (value, offset, noAssert) {
  _writeInt16(this, value, offset, false, noAssert)
}

function _writeInt32 (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifsint(value, 0x7fffffff, -0x80000000)
  }

  var len = buf.length
  if (offset >= len)
    return

  if (value >= 0)
    _writeUInt32(buf, value, offset, littleEndian, noAssert)
  else
    _writeUInt32(buf, 0xffffffff + value + 1, offset, littleEndian, noAssert)
}

Buffer.prototype.writeInt32LE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, true, noAssert)
}

Buffer.prototype.writeInt32BE = function (value, offset, noAssert) {
  _writeInt32(this, value, offset, false, noAssert)
}

function _writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 3 < buf.length, 'Trying to write beyond buffer length')
    verifIEEE754(value, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 23, 4)
}

Buffer.prototype.writeFloatLE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function (value, offset, noAssert) {
  _writeFloat(this, value, offset, false, noAssert)
}

function _writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    assert(value !== undefined && value !== null, 'missing value')
    assert(typeof littleEndian === 'boolean', 'missing or invalid endian')
    assert(offset !== undefined && offset !== null, 'missing offset')
    assert(offset + 7 < buf.length,
        'Trying to write beyond buffer length')
    verifIEEE754(value, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }

  var len = buf.length
  if (offset >= len)
    return

  ieee754.write(buf, value, offset, littleEndian, 52, 8)
}

Buffer.prototype.writeDoubleLE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function (value, offset, noAssert) {
  _writeDouble(this, value, offset, false, noAssert)
}

// fill(value, start=0, end=buffer.length)
Buffer.prototype.fill = function (value, start, end) {
  if (!value) value = 0
  if (!start) start = 0
  if (!end) end = this.length

  if (typeof value === 'string') {
    value = value.charCodeAt(0)
  }

  assert(typeof value === 'number' && !isNaN(value), 'value is not a number')
  assert(end >= start, 'end < start')

  // Fill 0 bytes; we're done
  if (end === start) return
  if (this.length === 0) return

  assert(start >= 0 && start < this.length, 'start out of bounds')
  assert(end >= 0 && end <= this.length, 'end out of bounds')

  for (var i = start; i < end; i++) {
    this[i] = value
  }
}

Buffer.prototype.inspect = function () {
  var out = []
  var len = this.length
  for (var i = 0; i < len; i++) {
    out[i] = toHex(this[i])
    if (i === exports.INSPECT_MAX_BYTES) {
      out[i + 1] = '...'
      break
    }
  }
  return '<Buffer ' + out.join(' ') + '>'
}

/**
 * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.
 * Added in Node 0.12. Only available in browsers that support ArrayBuffer.
 */
Buffer.prototype.toArrayBuffer = function () {
  if (typeof Uint8Array !== 'undefined') {
    if (Buffer._useTypedArrays) {
      return (new Buffer(this)).buffer
    } else {
      var buf = new Uint8Array(this.length)
      for (var i = 0, len = buf.length; i < len; i += 1)
        buf[i] = this[i]
      return buf.buffer
    }
  } else {
    throw new Error('Buffer.toArrayBuffer not supported in this browser')
  }
}

// HELPER FUNCTIONS
// ================

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

var BP = Buffer.prototype

/**
 * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods
 */
Buffer._augment = function (arr) {
  arr._isBuffer = true

  // save reference to original Uint8Array get/set methods before overwriting
  arr._get = arr.get
  arr._set = arr.set

  // deprecated, will be removed in node 0.13+
  arr.get = BP.get
  arr.set = BP.set

  arr.write = BP.write
  arr.toString = BP.toString
  arr.toLocaleString = BP.toString
  arr.toJSON = BP.toJSON
  arr.copy = BP.copy
  arr.slice = BP.slice
  arr.readUInt8 = BP.readUInt8
  arr.readUInt16LE = BP.readUInt16LE
  arr.readUInt16BE = BP.readUInt16BE
  arr.readUInt32LE = BP.readUInt32LE
  arr.readUInt32BE = BP.readUInt32BE
  arr.readInt8 = BP.readInt8
  arr.readInt16LE = BP.readInt16LE
  arr.readInt16BE = BP.readInt16BE
  arr.readInt32LE = BP.readInt32LE
  arr.readInt32BE = BP.readInt32BE
  arr.readFloatLE = BP.readFloatLE
  arr.readFloatBE = BP.readFloatBE
  arr.readDoubleLE = BP.readDoubleLE
  arr.readDoubleBE = BP.readDoubleBE
  arr.writeUInt8 = BP.writeUInt8
  arr.writeUInt16LE = BP.writeUInt16LE
  arr.writeUInt16BE = BP.writeUInt16BE
  arr.writeUInt32LE = BP.writeUInt32LE
  arr.writeUInt32BE = BP.writeUInt32BE
  arr.writeInt8 = BP.writeInt8
  arr.writeInt16LE = BP.writeInt16LE
  arr.writeInt16BE = BP.writeInt16BE
  arr.writeInt32LE = BP.writeInt32LE
  arr.writeInt32BE = BP.writeInt32BE
  arr.writeFloatLE = BP.writeFloatLE
  arr.writeFloatBE = BP.writeFloatBE
  arr.writeDoubleLE = BP.writeDoubleLE
  arr.writeDoubleBE = BP.writeDoubleBE
  arr.fill = BP.fill
  arr.inspect = BP.inspect
  arr.toArrayBuffer = BP.toArrayBuffer

  return arr
}

// slice(start, end)
function clamp (index, len, defaultValue) {
  if (typeof index !== 'number') return defaultValue
  index = ~~index;  // Coerce to integer.
  if (index >= len) return len
  if (index >= 0) return index
  index += len
  if (index >= 0) return index
  return 0
}

function coerce (length) {
  // Coerce length to a number (possibly NaN), round up
  // in case it's fractional (e.g. 123.456) then do a
  // double negate to coerce a NaN to 0. Easy, right?
  length = ~~Math.ceil(+length)
  return length < 0 ? 0 : length
}

function isArray (subject) {
  return (Array.isArray || function (subject) {
    return Object.prototype.toString.call(subject) === '[object Array]'
  })(subject)
}

function isArrayish (subject) {
  return isArray(subject) || Buffer.isBuffer(subject) ||
      subject && typeof subject === 'object' &&
      typeof subject.length === 'number'
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    var b = str.charCodeAt(i)
    if (b <= 0x7F)
      byteArray.push(str.charCodeAt(i))
    else {
      var start = i
      if (b >= 0xD800 && b <= 0xDFFF) i++
      var h = encodeURIComponent(str.slice(start, i+1)).substr(1).split('%')
      for (var j = 0; j < h.length; j++)
        byteArray.push(parseInt(h[j], 16))
    }
  }
  return byteArray
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; i++) {
    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(str)
}

function blitBuffer (src, dst, offset, length) {
  var pos
  for (var i = 0; i < length; i++) {
    if ((i + offset >= dst.length) || (i >= src.length))
      break
    dst[i + offset] = src[i]
  }
  return i
}

function decodeUtf8Char (str) {
  try {
    return decodeURIComponent(str)
  } catch (err) {
    return String.fromCharCode(0xFFFD) // UTF 8 invalid char
  }
}

/*
 * We have to make sure that the value is a valid integer. This means that it
 * is non-negative. It has no fractional component and that it does not
 * exceed the maximum allowed value.
 */
function verifuint (value, max) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value >= 0, 'specified a negative value for writing an unsigned value')
  assert(value <= max, 'value is larger than maximum value for type')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifsint (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
  assert(Math.floor(value) === value, 'value has a fractional component')
}

function verifIEEE754 (value, max, min) {
  assert(typeof value === 'number', 'cannot write a non-number as a number')
  assert(value <= max, 'value larger than maximum allowed value')
  assert(value >= min, 'value smaller than minimum allowed value')
}

function assert (test, message) {
  if (!test) throw new Error(message || 'Failed assertion')
}

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/index.js","/../../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer")
},{"base64-js":36,"buffer":35,"ieee754":37,"oMfpAn":38}],36:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

;(function (exports) {
	'use strict';

  var Arr = (typeof Uint8Array !== 'undefined')
    ? Uint8Array
    : Array

	var PLUS   = '+'.charCodeAt(0)
	var SLASH  = '/'.charCodeAt(0)
	var NUMBER = '0'.charCodeAt(0)
	var LOWER  = 'a'.charCodeAt(0)
	var UPPER  = 'A'.charCodeAt(0)
	var PLUS_URL_SAFE = '-'.charCodeAt(0)
	var SLASH_URL_SAFE = '_'.charCodeAt(0)

	function decode (elt) {
		var code = elt.charCodeAt(0)
		if (code === PLUS ||
		    code === PLUS_URL_SAFE)
			return 62 // '+'
		if (code === SLASH ||
		    code === SLASH_URL_SAFE)
			return 63 // '/'
		if (code < NUMBER)
			return -1 //no match
		if (code < NUMBER + 10)
			return code - NUMBER + 26 + 26
		if (code < UPPER + 26)
			return code - UPPER
		if (code < LOWER + 26)
			return code - LOWER + 26
	}

	function b64ToByteArray (b64) {
		var i, j, l, tmp, placeHolders, arr

		if (b64.length % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}

		// the number of equal signs (place holders)
		// if there are two placeholders, than the two characters before it
		// represent one byte
		// if there is only one, then the three characters before it represent 2 bytes
		// this is just a cheap hack to not do indexOf twice
		var len = b64.length
		placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0

		// base64 is 4/3 + up to two characters of the original data
		arr = new Arr(b64.length * 3 / 4 - placeHolders)

		// if there are placeholders, only get up to the last complete 4 chars
		l = placeHolders > 0 ? b64.length - 4 : b64.length

		var L = 0

		function push (v) {
			arr[L++] = v
		}

		for (i = 0, j = 0; i < l; i += 4, j += 3) {
			tmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))
			push((tmp & 0xFF0000) >> 16)
			push((tmp & 0xFF00) >> 8)
			push(tmp & 0xFF)
		}

		if (placeHolders === 2) {
			tmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)
			push(tmp & 0xFF)
		} else if (placeHolders === 1) {
			tmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)
			push((tmp >> 8) & 0xFF)
			push(tmp & 0xFF)
		}

		return arr
	}

	function uint8ToBase64 (uint8) {
		var i,
			extraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes
			output = "",
			temp, length

		function encode (num) {
			return lookup.charAt(num)
		}

		function tripletToBase64 (num) {
			return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)
		}

		// go through the array every three bytes, we'll deal with trailing stuff later
		for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
			temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
			output += tripletToBase64(temp)
		}

		// pad the end with zeros, but make sure to not forget the extra bytes
		switch (extraBytes) {
			case 1:
				temp = uint8[uint8.length - 1]
				output += encode(temp >> 2)
				output += encode((temp << 4) & 0x3F)
				output += '=='
				break
			case 2:
				temp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])
				output += encode(temp >> 10)
				output += encode((temp >> 4) & 0x3F)
				output += encode((temp << 2) & 0x3F)
				output += '='
				break
		}

		return output
	}

	exports.toByteArray = b64ToByteArray
	exports.fromByteArray = uint8ToBase64
}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib/b64.js","/../../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/base64-js/lib")
},{"buffer":35,"oMfpAn":38}],37:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/ieee754/index.js","/../../node_modules/gulp-browserify/node_modules/browserify/node_modules/buffer/node_modules/ieee754")
},{"buffer":35,"oMfpAn":38}],38:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
// shim for using process in browser

var process = module.exports = {};

process.nextTick = (function () {
    var canSetImmediate = typeof window !== 'undefined'
    && window.setImmediate;
    var canPost = typeof window !== 'undefined'
    && window.postMessage && window.addEventListener
    ;

    if (canSetImmediate) {
        return function (f) { return window.setImmediate(f) };
    }

    if (canPost) {
        var queue = [];
        window.addEventListener('message', function (ev) {
            var source = ev.source;
            if ((source === window || source === null) && ev.data === 'process-tick') {
                ev.stopPropagation();
                if (queue.length > 0) {
                    var fn = queue.shift();
                    fn();
                }
            }
        }, true);

        return function nextTick(fn) {
            queue.push(fn);
            window.postMessage('process-tick', '*');
        };
    }

    return function nextTick(fn) {
        setTimeout(fn, 0);
    };
})();

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
}

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};

}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/../../node_modules/gulp-browserify/node_modules/browserify/node_modules/process/browser.js","/../../node_modules/gulp-browserify/node_modules/browserify/node_modules/process")
},{"buffer":35,"oMfpAn":38}],39:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
//================================================================================
// CustomAppp is a utility class for apps empowered for CustomAppp
// Author: Xujie Song
// Copyright: SK8 PTY LTD
// V0.9.6
//================================================================================

"use strict";

/**
 * SH is the fundamental module for CustomAppp Library. All subclasses or methods will start with this function.
 * @module SH
 * @author Xujie Song
 * @copyright SK8 PTY LTD 2015
 * @see {@link https://leancloud.cn/docs/leanengine_guide-node.html LeanEngine Reference}
 */
var SH = function() {}
SH.APP_ID = process.env.LC_APP_ID || "appidappidapppidappid";
SH.APP_KEY = process.env.LC_APP_KEY || "appkeyappkeyappkeyappkey";

/**
 * Initialize AV Module <br>
 * @module AV
 * @example var AV = require('avoscloud-sdk').AV; 
 * //instead of 
 * //var AV = require('leanengine'); <br>  
 * //Reason being Node module 'leanengine' uses Express 4 and body-parser, which does not work well with browserify <br>
 * @see {@link https://leancloud.cn/docs/leanengine_guide-node.html LeanEngine Reference}
 */
var AV = require("avoscloud-sdk").AV;
AV.initialize(SH.APP_ID, SH.APP_KEY);

require('./src/SH.js')(SH, AV);
require('./src/SH.Error.js')(SH, AV);
require('./src/SH.User.js')(SH);

global.SH = SH;
global.AV = SH.AV;
}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/fake_3452839a.js","/")
},{"./src/SH.Error.js":40,"./src/SH.User.js":41,"./src/SH.js":42,"avoscloud-sdk":2,"buffer":35,"oMfpAn":38}],40:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

/**
 * Utility Error Function, declare system errors here
 * @func SH.Error
 * @author Xujie Song
 * @copyright SK8 PTY LTD 2015
 * @param {Int} Error The error code
 * @return {String} Error description
 */
module.exports = function(SH) {
    SH.Error = function (Error) {
        var ErrorCode = " Error: " + ("000" + Error).slice(-4);
        switch (Error) {
            case 0:
                // A user (SHUser) object is required before saving an SHAddress object
                var message = "This is a sample Error message."
                return message + ErrorCode;
                break;
            default:
                // Error code not found
                var message = "Error cound not found."
                return message + ErrorCode;
                break;
        }
    }
}
}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/SH.Error.js","/src")
},{"buffer":35,"oMfpAn":38}],41:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

/**
 * Class for all User object used in Shelf system
 * @class SH.User
 * @memberof! <global>
 * @author Xujie Song
 * @copyright SK8 PTY LTD 2015
 * @extends {AV.User}
 * @see {@link https://leancloud.cn/docs/js_guide.html#用户 AV.User}
 * @property {SH.Address} address The pointer of the default address of this _User
 * @property {Object} [authData] AuthData of this _User
 * @property {String} username Username of this _User
 * @property {String} password Password of this _User
 */
var ClassName = "_User";
module.exports = function (SH, Verification) {
    /**
     * Recommended way to
     * Initialize a new instance of the Class
     * @func SH.User.prototype.new
     * @param {Object} [data] An json object that contains the data
     * @example var user = SH.User.new({"id": "abcd"});
     */
    SH.User = SH.AV.Object.extend(ClassName, {
        //Instance variables
        //Instance functions
    }, {
        //Static variables
        //Static functions
    });
    if (Verification != undefined) {
        SH.AV.Cloud.beforeSave(ClassName, Verification.beforeSave(SH));
        SH.AV.Cloud.afterSave(ClassName, Verification.afterSave(SH));
        SH.AV.Cloud.afterUpdate(ClassName, Verification.afterUpdate(SH));
        SH.AV.Cloud.beforeDelete(ClassName, Verification.beforeDelete(SH));
        SH.AV.Cloud.afterDelete(ClassName, Verification.afterDelete(SH));
    }
    Object.defineProperty(SH.User.prototype, "authData", {
        get: function () {
            return this.get("authData");
        },
        set: function (value) {
            this.set("authData", value);
        }
    });
    Object.defineProperty(SH.User.prototype, "email", {
        get: function () {
            return this.get("email");
        },
        set: function (value) {
            this.set("email", value);
        }
    });
    Object.defineProperty(SH.User.prototype, "password", {
        get: function () {
            return this.get("password");
        },
        set: function (value) {
            this.set("password", value);
        }
    });
    Object.defineProperty(SH.User.prototype, "username", {
        get: function () {
            return this.get("username");
        },
        set: function (value) {
            this.set("username", value);
        }
    });
    /**
     * isUser method check if two user objects are equivalent to each other
     * @param {SH.User} user Target user to compare
     * @return {Boolean} boolean True if two users are the equivalent, false otherwise
     */
    SH.User.prototype.isUser = function (user) {
        if (user != undefined) {
            return this.id == user.id;
        } else {
            return false;
        }
    }
    /**
     * Check if the user has verified his/her email
     * @func SH.User.prototype.hasVerifiedEmail
     * @example if (user.hasVerifiedEmail()) {
         *      //User had verified his/her email
         * } else {
         *      //User had not verified his/her email
         * }
     */
    SH.User.prototype.hasVerifiedEmail = function () {
        return this.get("emailVerified");
    }
    /**
     * Follow to a particular user
     * @func SH.User.prototype.follow
     * @param {SH.User} user
     * @param {Object} [callback] An object that has an optional success function, that takes no arguments and will be called on a successful push, and an error function that takes a AV.Error and will be called if the push failed.
     * @example user.follow(user, {
         *          success: function(user) {
         *              //Updated user
         *          },
         *          error: function(error) {
         *              //SH.showError(error);
         *          }
         *      });
     */
    /**
     * Unfollow to a particular user
     * @func SH.User.prototype.unfollow
     * @param {SH.User} user
     * @param {Object} [callback] An object that has an optional success function, that takes no arguments and will be called on a successful push, and an error function that takes a AV.Error and will be called if the push failed.
     * @example user.unfollow(user, {
         *          success: function(user) {
         *              //Updated user
         *          },
         *          error: function(error) {
         *              //SH.showError(error);
         *          }
         *      });
     */
    /**
     * Create a followee query to query the user's followees.
     * @func SH.User.prototype.followeeQuery()
     * @example var followeeQuery = user.followeeQuery();
     */
    /**
     * Create a follower query to query the user's followers.
     * @func SH.User.prototype.followerQuery()
     * @example var followerQuery = user.followerQuery();
     */

    /**
     * Signs up a new user. You should call this instead of save for
     * new SH.Users. This will create a new SH.User on the server, and
     * also persist the session on disk so that you can access the user using
     * <code>current</code>.
     *
     * <p>A username and password must be set before calling signUp.</p>
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @func SH.User.signUp
     * @param {Object} attrs Extra fields to set on the new user, or null.
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled when the signup
     *     finishes.
     * @example
     *      var user = SH.User.new();
     *      user.username = "133342301@163.com";
     *      user.password = "abcdefg";
     *      user.signUp(null, {
     *        success: function(user) {
     *          // 注册成功，可以使用了.
     *        },
     *        error: function(user, error) {
     *          //SH.showError(error);
     *        }
     *      });
     */
    /**
     * Signs up a new user with mobile phone and sms code.
     * You should call this instead of save for
     * new AV.Users. This will create a new AV.User on the server, and
     * also persist the session on disk so that you can access the user using
     * <code>current</code>.
     *
     * <p>A username and password must be set before calling signUp.</p>
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @func SH.User.signUpOrlogInWithMobilePhone
     * @param {Object} attrs Extra fields to set on the new user, or null.
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled when the signup
     *     finishes.
     * @see @link https://leancloud.cn/docs/js_guide.html#手机号码一键登录 AV.Cloud.requestSmsCode}
     * @example
     *      var user = SH.User.new();
     *      user.username = "133342301@163.com";
     *      user.password = "abcdefg";
     *      user.signUpOrlogInWithMobilePhone({
     *        mobilePhoneNumber: '186xxxxxxxx',
     *        smsCode: '手机收到的 6 位验证码字符串',
     *        username: "feedback@sk8.asia",
     *        passwrod: "12345678"
     *        otherProperty: otherValue
     *      }, {
     *        success: function(user) {
     *          // 注册成功，可以使用了.
     *        },
     *        error: function(user, error) {
     *          //SH.showError(error);
     *        }
     *      });
     */

    /**
     * Logs in a user with a mobile phone number and password. On success, this
     * saves the session to disk, so you can retrieve the currently logged in
     * user using <code>current</code>.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @func SH.User.logInWithMobilePhone
     * @param {String} mobilePhone The user's mobilePhoneNumber
     * @param {String} password The password to log in with.
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled with the user when
     *     the login completes.
     * @see @link https://leancloud.cn/docs/js_guide.html#手机号码和短信登录 AV.User.logInWithMobilePhone}
     * @example
     *      SH.User.logInWithMobilePhone('186xxxxxxxx', password, {
     *        success: function(user) {
     *          // 注册成功，可以使用了.
     *        },
     *        error: function(user, error) {
     *          //SH.showError(error);
     *        }
     *      });
     */

    /**
     * Logs out the currently logged in user session. This will remove the
     * session from disk, log out of linked services, and future calls to
     * <code>current</code> will return <code>null</code>.
     * @func SH.User.logOut
     * @example SH.User.logOut();
     */

    /**
     * Requests a password reset email to be sent to the specified email address
     * associated with the user account. This email allows the user to securely
     * reset their password on the AV site.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @func SH.User.requestPasswordReset
     * @param {String} email The email address associated with the user that
     *     forgot their password.
     * @param {Object} options A Backbone-style options object.
     * @example
     *      SH.User.requestPasswordReset("email@example.com", {
     *        success: function() {
     *          // Password reset request was sent successfully
     *        },
     *        error: function(error) {
     *          //SH.showError(error);
     *      });
     */

    /**
     * Requests a verify email to be sent to the specified email address
     * associated with the user account. This email allows the user to securely
     * verify their email address on the AV site.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @func SH.User.requestEmailVerify
     * @param {String} email The email address associated with the user that
     *     doesn't verify their email address.
     * @param {Object} options A Backbone-style options object.
     * @example
     *      SH.User.requestEmailVerify("email@example.com", {
     *        success: function() {
     *          // Verification email was sent successfully
     *        },
     *        error: function(error) {
     *          //SH.showError(error);
     *      });
     */

    /**
     * Requests a verify sms code to be sent to the specified mobile phone
     * number associated with the user account. This sms code allows the user to
     * verify their mobile phone number by calling AV.User.verifyMobilePhone
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @func SH.User.requestMobilePhoneVerify
     * @param {String} mobilePhone The mobile phone number  associated with the
     *                  user that doesn't verify their mobile phone number.
     * @param {Object} options A Backbone-style options object.
     * @exmaple
     *      AV.User.requestMobilePhoneVerify('186xxxxxxxx').then(function(){
     *        //发送成功
     *      }, function(err){
     *         //SH.showError(error);
     *      });
     */

    /**
     * Requests a reset password sms code to be sent to the specified mobile phone
     * number associated with the user account. This sms code allows the user to
     * reset their account's password by calling AV.User.resetPasswordBySmsCode
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @func SH.User.requestPasswordResetBySmsCode
     * @param {String} mobilePhone The mobile phone number  associated with the
     *                  user that doesn't verify their mobile phone number.
     * @param {Object} options A Backbone-style options object.
     * @example
     *      SH.User.requestPasswordResetBySmsCode("186xxxxxxxx", {
     *        success: function() {
     *          // Password reset request was sent successfully
     *        },
     *        error: function(error) {
     *          //SH.showError(error);
     *      });
     */
    /**
     * Makes a call to reset user's account password by sms code and new password.
     * The sms code is sent by AV.User.requestPasswordResetBySmsCode.
     * @func SH.User.resetPasswordBySmsCode
     * @param {String} code The sms code sent by AV.User.Cloud.requestSmsCode
     * @param {String} password The new password.
     * @param {Object} options A Backbone-style options object
     * @return {AV.Promise} A promise that will be resolved with the result
     * of the function.
     * @example
     *      SH.User.requestPasswordResetBySmsCode("123456", "newPassword", {
     *        success: function() {
     *          // Password reset request was sent successfully
     *        },
     *        error: function(error) {
     *          //SH.showError(error);
     *      });
     */
    /**
     * Makes a call to verify sms code that sent by AV.User.Cloud.requestSmsCode
     * If verify successfully,the user mobilePhoneVerified attribute will be true.
     * @func SH.User.verifyMobilePhone
     * @param {String} code The sms code sent by AV.User.Cloud.requestSmsCode
     * @param {Object} options A Backbone-style options object
     * @return {AV.Promise} A promise that will be resolved with the result
     * of the function.
     * @example
     *      SH.User.verifyMobilePhone("123456", {
     *        success: function() {
     *          // Password reset request was sent successfully
     *        },
     *        error: function(error) {
     *          //SH.showError(error);
     *      });
     */
    /**
     * Requests a logIn sms code to be sent to the specified mobile phone
     * number associated with the user account. This sms code allows the user to
     * login by AV.User.logInWithMobilePhoneSmsCode function.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @func SH.User.requestLoginSmsCode
     * @param {String} mobilePhone The mobile phone number  associated with the
     *           user that want to login by AV.User.logInWithMobilePhoneSmsCode
     * @param {Object} options A Backbone-style options object.
     * @example
     *      SH.User.requestLoginSmsCode('186xxxxxxxx', {
     *        success: function() {
     *          // Password reset request was sent successfully
     *        },
     *        error: function(error) {
     *          //SH.showError(error);
     *      });
     */

    /**
     * Logs in a user with a mobile phone number and sms code sent by
     * AV.User.requestLoginSmsCode.On success, this
     * saves the session to disk, so you can retrieve the currently logged in
     * user using <code>current</code>.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @func SH.User.logInWithMobilePhoneSmsCode
     * @param {String} mobilePhone The user's mobilePhoneNumber
     * @param {String} smsCode The sms code sent by AV.User.requestLoginSmsCode
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled with the user when
     *     the login completes.
     * @func SH.User#logIn
     * @example
     *      SH.User.logInWithMobilePhoneSmsCode("186xxxxxxxx", "123456", {
     *        success: function() {
     *          // Password reset request was sent successfully
     *        },
     *        error: function(error) {
     *          //SH.showError(error);
     *      });
     */

    /**
     * Logs in a AV.User. On success, this saves the session to localStorage,
     * so you can retrieve the currently logged in user using
     * <code>current</code>.
     *
     * <p>A username and password must be set before calling logIn.</p>
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @func SH.User.prototype.logIn
     * @param {Object} options A Backbone-style options object.
     * @func SH.User.logIn
     * @return {AV.Promise} A promise that is fulfilled with the user when
     *     the login is complete.
     * @example
     *      AV.User.logIn("myUsername", "myPassword", {
     *        success: function(user) {
     *          // 成功了，现在可以做其他事情了.
     *        },
     *        error: function(user, error) {
     *          //SH.showError(error);
     *        }
     *      });
     */

    /**
     * Update user's new password safely based on old password.
     * @func SH.User.prototype
     * @param {String} oldPassword, the old password.
     * @param {String} newPassword, the new password.
     * @param {Object} An optional Backbone-like options object with
     *     success and error callbacks that will be invoked once the iteration
     *     has finished.
     * @example
     *      var user = AV.User.current();
     *      user.updatePassword('currentPassword', 'newPassword', {
     *        success: function(){
     *          //更新成功
     *        },
     *        error: function(user, err){
     *          //SH.showError(error);
     *        }
     *      });
     */

    /**
     * Logs in a user with a session token. On success, this saves the session
     * to disk, so you can retrieve the currently logged in user using
     * <code>current</code>.
     *
     * <p>Calls options.success or options.error on completion.</p>
     *
     * @func SH.User.become
     * @param {String} sessionToken The sessionToken to log in with.
     * @param {Object} options A Backbone-style options object.
     * @return {AV.Promise} A promise that is fulfilled with the user when
     *     the login completes.
     * @example
     *      SH.User.become("sessionToken", {
     *        success: function(){
     *          //更新成功
     *        },
     *        error: function(user, err){
     *          //SH.showError(error);
     *        }
     *      });
     */
}
}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/SH.User.js","/src")
},{"buffer":35,"oMfpAn":38}],42:[function(require,module,exports){
(function (process,global,Buffer,__argument0,__argument1,__argument2,__argument3,__filename,__dirname){
'use strict';

/**
 * SH is the fundamental function for Custom_App Library. All subclasses or methods will start with this function.
 * @class SH
 * @author Xujie Song
 * @copyright (c) SK8 PTY LTD 2015. All rights reserved.
 * @see {@link https://leancloud.cn/docs/leanengine_guide-node.html LeanEngine Reference}
 * @todo Resolve deploy error 'Unauthorized'
 */
module.exports = function(SH, AV) {
  SH.AV = AV;
  /**
   * Initiation method for Custom_App App
   * @func SH.initialize
   * @param {String} shopId The id of the Shop. Usually link would look like http://shopId.shelf.is
   * @param {Object} callback An object that has an optional success function, that takes no arguments and will be called on a successful push, and an error function that takes a AV.Error and will be called if the push failed.
   * @example SH.initialize("abcdShopId", {
   *          success: function(shop) {
   *              //$rootScope.currentShop = SH.currentShop;
   *              //$rootScope.currentSeller = SH.currentShop.owner;
   *              //$rootScope.currentUser = SH.currentUser;
   *              //$scope.reloadShop(shop);
   *          },
   *          error: function(error) {
   *              SH.showError(error);
   *          }
   * });
   */
  SH.initialize = function(shopId, callback) {
    //Initilization code for Custom_App
  };
    /**
     * Show an promote to user, it's currently an alert.
     * @func SH.Promote
     * @param {String} message The message you wish to promote
     * @example SH.promote("Custom_App is awesome!");
     */
  SH.promote = function(message) {
      SH.log(message);
      window.alert(message);
    }
    /**
     * Log the error message in console, and 'promote' it to user
     * @func SH.showError
     * @param {Error} error HTTP Error
     * @example SH.showError(error);
     */
  SH.showError = function(error) {
      SH.log(error.message);
      window.alert(error.message);
    }
    /**
     * custom SH.log function.
     * @func SH.log
     * @param {String} message The message you wish to log
     * @example SH.log(message);
     */
  SH.log = function(message) {
      console.log(message);
    }
  SH.openURL = function(url) {
    window.open(url, '_blank', 'resizable=yes');
  }
}
}).call(this,require("oMfpAn"),typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {},require("buffer").Buffer,arguments[3],arguments[4],arguments[5],arguments[6],"/src/SH.js","/src")
},{"buffer":35,"oMfpAn":38}]},{},[39])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvYWNsLmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvYXYuanMiLCIvVXNlcnMvWHVqaWVTb25nL0RvY3VtZW50cy9TSzhUZWNoL0Ryb3Bib3gvI1NLOFRlY2gvVGVjaC9XZWIvTGVhbkVuZ2luZS1GdWxsLVN0YWNrL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9iaWdxdWVyeS5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2Jyb3dzZXJpZnktd3JhcHBlci9sb2NhbHN0b3JhZ2UtYnJvd3Nlci5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2Jyb3dzZXJpZnktd3JhcHBlci9wYXJzZS1iYXNlNjQtYnJvd3Nlci5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2Jyb3dzZXJpZnktd3JhcHBlci91cGxvYWQtYnJvd3Nlci5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2Jyb3dzZXJpZnktd3JhcHBlci94bWxodHRwcmVxdWVzdC1icm93c2VyLmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvY2xvdWRmdW5jdGlvbi5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2NvbGxlY3Rpb24uanMiLCIvVXNlcnMvWHVqaWVTb25nL0RvY3VtZW50cy9TSzhUZWNoL0Ryb3Bib3gvI1NLOFRlY2gvVGVjaC9XZWIvTGVhbkVuZ2luZS1GdWxsLVN0YWNrL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9lcnJvci5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2V2ZW50LmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvZmFjZWJvb2suanMiLCIvVXNlcnMvWHVqaWVTb25nL0RvY3VtZW50cy9TSzhUZWNoL0Ryb3Bib3gvI1NLOFRlY2gvVGVjaC9XZWIvTGVhbkVuZ2luZS1GdWxsLVN0YWNrL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9maWxlLmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvZ2VvcG9pbnQuanMiLCIvVXNlcnMvWHVqaWVTb25nL0RvY3VtZW50cy9TSzhUZWNoL0Ryb3Bib3gvI1NLOFRlY2gvVGVjaC9XZWIvTGVhbkVuZ2luZS1GdWxsLVN0YWNrL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9oaXN0b3J5LmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvaW5zaWdodC5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2xvY2Fsc3RvcmFnZS5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL29iamVjdC5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL29wLmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvcHJvbWlzZS5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL3B1c2guanMiLCIvVXNlcnMvWHVqaWVTb25nL0RvY3VtZW50cy9TSzhUZWNoL0Ryb3Bib3gvI1NLOFRlY2gvVGVjaC9XZWIvTGVhbkVuZ2luZS1GdWxsLVN0YWNrL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9xdWVyeS5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL3JlbGF0aW9uLmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvcm9sZS5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL3JvdXRlci5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL3NlYXJjaC5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL3N0YXR1cy5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL3VzZXIuanMiLCIvVXNlcnMvWHVqaWVTb25nL0RvY3VtZW50cy9TSzhUZWNoL0Ryb3Bib3gvI1NLOFRlY2gvVGVjaC9XZWIvTGVhbkVuZ2luZS1GdWxsLVN0YWNrL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi91dGlscy5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL3ZlcnNpb24uanMiLCIvVXNlcnMvWHVqaWVTb25nL0RvY3VtZW50cy9TSzhUZWNoL0Ryb3Bib3gvI1NLOFRlY2gvVGVjaC9XZWIvTGVhbkVuZ2luZS1GdWxsLVN0YWNrL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi92aWV3LmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9ub2RlX21vZHVsZXMvbG9jYWxzdG9yYWdlLW1lbW9yeS9saWIvbG9jYWxzdG9yYWdlLW1lbW9yeS5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9ub2RlX21vZHVsZXMvZ3VscC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCIvVXNlcnMvWHVqaWVTb25nL0RvY3VtZW50cy9TSzhUZWNoL0Ryb3Bib3gvI1NLOFRlY2gvVGVjaC9XZWIvTGVhbkVuZ2luZS1GdWxsLVN0YWNrL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYi9iNjQuanMiLCIvVXNlcnMvWHVqaWVTb25nL0RvY3VtZW50cy9TSzhUZWNoL0Ryb3Bib3gvI1NLOFRlY2gvVGVjaC9XZWIvTGVhbkVuZ2luZS1GdWxsLVN0YWNrL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIi9Vc2Vycy9YdWppZVNvbmcvRG9jdW1lbnRzL1NLOFRlY2gvRHJvcGJveC8jU0s4VGVjaC9UZWNoL1dlYi9MZWFuRW5naW5lLUZ1bGwtU3RhY2svbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9zZXJ2ZXItbW9kdWxlcy9hcHBfbm9kZS9mYWtlXzM0NTI4MzlhLmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9zZXJ2ZXItbW9kdWxlcy9hcHBfbm9kZS9zcmMvU0guRXJyb3IuanMiLCIvVXNlcnMvWHVqaWVTb25nL0RvY3VtZW50cy9TSzhUZWNoL0Ryb3Bib3gvI1NLOFRlY2gvVGVjaC9XZWIvTGVhbkVuZ2luZS1GdWxsLVN0YWNrL3NlcnZlci1tb2R1bGVzL2FwcF9ub2RlL3NyYy9TSC5Vc2VyLmpzIiwiL1VzZXJzL1h1amllU29uZy9Eb2N1bWVudHMvU0s4VGVjaC9Ecm9wYm94LyNTSzhUZWNoL1RlY2gvV2ViL0xlYW5FbmdpbmUtRnVsbC1TdGFjay9zZXJ2ZXItbW9kdWxlcy9hcHBfbm9kZS9zcmMvU0guanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDei9DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6bEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzNkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6WEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmhDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0cUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDak5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWdEQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2bENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzljQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpfXZhciBmPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChmLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGYsZi5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuLypnbG9iYWwgbmF2aWdhdG9yOiBmYWxzZSAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihBVikge1xuICB2YXIgUFVCTElDX0tFWSA9IFwiKlwiO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEFDTC5cbiAgICogSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHRoZSBBQ0wgaGFzIG5vIHBlcm1pc3Npb25zIGZvciBhbnlvbmUuXG4gICAqIElmIHRoZSBhcmd1bWVudCBpcyBhIEFWLlVzZXIsIHRoZSBBQ0wgd2lsbCBoYXZlIHJlYWQgYW5kIHdyaXRlXG4gICAqICAgcGVybWlzc2lvbiBmb3Igb25seSB0aGF0IHVzZXIuXG4gICAqIElmIHRoZSBhcmd1bWVudCBpcyBhbnkgb3RoZXIgSlNPTiBvYmplY3QsIHRoYXQgb2JqZWN0IHdpbGwgYmUgaW50ZXJwcmV0dGVkXG4gICAqICAgYXMgYSBzZXJpYWxpemVkIEFDTCBjcmVhdGVkIHdpdGggdG9KU09OKCkuXG4gICAqIEBzZWUgQVYuT2JqZWN0I3NldEFDTFxuICAgKiBAY2xhc3NcbiAgICpcbiAgICogPHA+QW4gQUNMLCBvciBBY2Nlc3MgQ29udHJvbCBMaXN0IGNhbiBiZSBhZGRlZCB0byBhbnlcbiAgICogPGNvZGU+QVYuT2JqZWN0PC9jb2RlPiB0byByZXN0cmljdCBhY2Nlc3MgdG8gb25seSBhIHN1YnNldCBvZiB1c2Vyc1xuICAgKiBvZiB5b3VyIGFwcGxpY2F0aW9uLjwvcD5cbiAgICovXG4gIEFWLkFDTCA9IGZ1bmN0aW9uKGFyZzEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi5wZXJtaXNzaW9uc0J5SWQgPSB7fTtcbiAgICBpZiAoXy5pc09iamVjdChhcmcxKSkge1xuICAgICAgaWYgKGFyZzEgaW5zdGFuY2VvZiBBVi5Vc2VyKSB7XG4gICAgICAgIHNlbGYuc2V0UmVhZEFjY2VzcyhhcmcxLCB0cnVlKTtcbiAgICAgICAgc2VsZi5zZXRXcml0ZUFjY2VzcyhhcmcxLCB0cnVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChfLmlzRnVuY3Rpb24oYXJnMSkpIHtcbiAgICAgICAgICB0aHJvdyBcIkFWLkFDTCgpIGNhbGxlZCB3aXRoIGEgZnVuY3Rpb24uICBEaWQgeW91IGZvcmdldCAoKT9cIjtcbiAgICAgICAgfVxuICAgICAgICBBVi5fb2JqZWN0RWFjaChhcmcxLCBmdW5jdGlvbihhY2Nlc3NMaXN0LCB1c2VySWQpIHtcbiAgICAgICAgICBpZiAoIV8uaXNTdHJpbmcodXNlcklkKSkge1xuICAgICAgICAgICAgdGhyb3cgXCJUcmllZCB0byBjcmVhdGUgYW4gQUNMIHdpdGggYW4gaW52YWxpZCB1c2VySWQuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlbGYucGVybWlzc2lvbnNCeUlkW3VzZXJJZF0gPSB7fTtcbiAgICAgICAgICBBVi5fb2JqZWN0RWFjaChhY2Nlc3NMaXN0LCBmdW5jdGlvbihhbGxvd2VkLCBwZXJtaXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAocGVybWlzc2lvbiAhPT0gXCJyZWFkXCIgJiYgcGVybWlzc2lvbiAhPT0gXCJ3cml0ZVwiKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiVHJpZWQgdG8gY3JlYXRlIGFuIEFDTCB3aXRoIGFuIGludmFsaWQgcGVybWlzc2lvbiB0eXBlLlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfLmlzQm9vbGVhbihhbGxvd2VkKSkge1xuICAgICAgICAgICAgICB0aHJvdyBcIlRyaWVkIHRvIGNyZWF0ZSBhbiBBQ0wgd2l0aCBhbiBpbnZhbGlkIHBlcm1pc3Npb24gdmFsdWUuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnBlcm1pc3Npb25zQnlJZFt1c2VySWRdW3Blcm1pc3Npb25dID0gYWxsb3dlZDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTi1lbmNvZGVkIHZlcnNpb24gb2YgdGhlIEFDTC5cbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgQVYuQUNMLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy5jbG9uZSh0aGlzLnBlcm1pc3Npb25zQnlJZCk7XG4gIH07XG5cbiAgQVYuQUNMLnByb3RvdHlwZS5fc2V0QWNjZXNzID0gZnVuY3Rpb24oYWNjZXNzVHlwZSwgdXNlcklkLCBhbGxvd2VkKSB7XG4gICAgaWYgKHVzZXJJZCBpbnN0YW5jZW9mIEFWLlVzZXIpIHtcbiAgICAgIHVzZXJJZCA9IHVzZXJJZC5pZDtcbiAgICB9IGVsc2UgaWYgKHVzZXJJZCBpbnN0YW5jZW9mIEFWLlJvbGUpIHtcbiAgICAgIHVzZXJJZCA9IFwicm9sZTpcIiArIHVzZXJJZC5nZXROYW1lKCk7XG4gICAgfVxuICAgIGlmICghXy5pc1N0cmluZyh1c2VySWQpKSB7XG4gICAgICB0aHJvdyBcInVzZXJJZCBtdXN0IGJlIGEgc3RyaW5nLlwiO1xuICAgIH1cbiAgICBpZiAoIV8uaXNCb29sZWFuKGFsbG93ZWQpKSB7XG4gICAgICB0aHJvdyBcImFsbG93ZWQgbXVzdCBiZSBlaXRoZXIgdHJ1ZSBvciBmYWxzZS5cIjtcbiAgICB9XG4gICAgdmFyIHBlcm1pc3Npb25zID0gdGhpcy5wZXJtaXNzaW9uc0J5SWRbdXNlcklkXTtcbiAgICBpZiAoIXBlcm1pc3Npb25zKSB7XG4gICAgICBpZiAoIWFsbG93ZWQpIHtcbiAgICAgICAgLy8gVGhlIHVzZXIgYWxyZWFkeSBkb2Vzbid0IGhhdmUgdGhpcyBwZXJtaXNzaW9uLCBzbyBubyBhY3Rpb24gbmVlZGVkLlxuICAgICAgICByZXR1cm47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZXJtaXNzaW9ucyA9IHt9O1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25zQnlJZFt1c2VySWRdID0gcGVybWlzc2lvbnM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgIHRoaXMucGVybWlzc2lvbnNCeUlkW3VzZXJJZF1bYWNjZXNzVHlwZV0gPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGUgcGVybWlzc2lvbnNbYWNjZXNzVHlwZV07XG4gICAgICBpZiAoXy5pc0VtcHR5KHBlcm1pc3Npb25zKSkge1xuICAgICAgICBkZWxldGUgcGVybWlzc2lvbnNbdXNlcklkXTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQVYuQUNMLnByb3RvdHlwZS5fZ2V0QWNjZXNzID0gZnVuY3Rpb24oYWNjZXNzVHlwZSwgdXNlcklkKSB7XG4gICAgaWYgKHVzZXJJZCBpbnN0YW5jZW9mIEFWLlVzZXIpIHtcbiAgICAgIHVzZXJJZCA9IHVzZXJJZC5pZDtcbiAgICB9IGVsc2UgaWYgKHVzZXJJZCBpbnN0YW5jZW9mIEFWLlJvbGUpIHtcbiAgICAgIHVzZXJJZCA9IFwicm9sZTpcIiArIHVzZXJJZC5nZXROYW1lKCk7XG4gICAgfVxuICAgIHZhciBwZXJtaXNzaW9ucyA9IHRoaXMucGVybWlzc2lvbnNCeUlkW3VzZXJJZF07XG4gICAgaWYgKCFwZXJtaXNzaW9ucykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gcGVybWlzc2lvbnNbYWNjZXNzVHlwZV0gPyB0cnVlIDogZmFsc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHRoZSBnaXZlbiB1c2VyIGlzIGFsbG93ZWQgdG8gcmVhZCB0aGlzIG9iamVjdC5cbiAgICogQHBhcmFtIHVzZXJJZCBBbiBpbnN0YW5jZSBvZiBBVi5Vc2VyIG9yIGl0cyBvYmplY3RJZC5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbGxvd2VkIFdoZXRoZXIgdGhhdCB1c2VyIHNob3VsZCBoYXZlIHJlYWQgYWNjZXNzLlxuICAgKi9cbiAgQVYuQUNMLnByb3RvdHlwZS5zZXRSZWFkQWNjZXNzID0gZnVuY3Rpb24odXNlcklkLCBhbGxvd2VkKSB7XG4gICAgdGhpcy5fc2V0QWNjZXNzKFwicmVhZFwiLCB1c2VySWQsIGFsbG93ZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGUgZ2l2ZW4gdXNlciBpZCBpcyAqZXhwbGljaXRseSogYWxsb3dlZCB0byByZWFkIHRoaXMgb2JqZWN0LlxuICAgKiBFdmVuIGlmIHRoaXMgcmV0dXJucyBmYWxzZSwgdGhlIHVzZXIgbWF5IHN0aWxsIGJlIGFibGUgdG8gYWNjZXNzIGl0IGlmXG4gICAqIGdldFB1YmxpY1JlYWRBY2Nlc3MgcmV0dXJucyB0cnVlIG9yIGEgcm9sZSB0aGF0IHRoZSB1c2VyIGJlbG9uZ3MgdG8gaGFzXG4gICAqIHdyaXRlIGFjY2Vzcy5cbiAgICogQHBhcmFtIHVzZXJJZCBBbiBpbnN0YW5jZSBvZiBBVi5Vc2VyIG9yIGl0cyBvYmplY3RJZCwgb3IgYSBBVi5Sb2xlLlxuICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgKi9cbiAgQVYuQUNMLnByb3RvdHlwZS5nZXRSZWFkQWNjZXNzID0gZnVuY3Rpb24odXNlcklkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldEFjY2VzcyhcInJlYWRcIiwgdXNlcklkKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdGhlIGdpdmVuIHVzZXIgaWQgaXMgYWxsb3dlZCB0byB3cml0ZSB0aGlzIG9iamVjdC5cbiAgICogQHBhcmFtIHVzZXJJZCBBbiBpbnN0YW5jZSBvZiBBVi5Vc2VyIG9yIGl0cyBvYmplY3RJZCwgb3IgYSBBVi5Sb2xlLi5cbiAgICogQHBhcmFtIHtCb29sZWFufSBhbGxvd2VkIFdoZXRoZXIgdGhhdCB1c2VyIHNob3VsZCBoYXZlIHdyaXRlIGFjY2Vzcy5cbiAgICovXG4gIEFWLkFDTC5wcm90b3R5cGUuc2V0V3JpdGVBY2Nlc3MgPSBmdW5jdGlvbih1c2VySWQsIGFsbG93ZWQpIHtcbiAgICB0aGlzLl9zZXRBY2Nlc3MoXCJ3cml0ZVwiLCB1c2VySWQsIGFsbG93ZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGUgZ2l2ZW4gdXNlciBpZCBpcyAqZXhwbGljaXRseSogYWxsb3dlZCB0byB3cml0ZSB0aGlzIG9iamVjdC5cbiAgICogRXZlbiBpZiB0aGlzIHJldHVybnMgZmFsc2UsIHRoZSB1c2VyIG1heSBzdGlsbCBiZSBhYmxlIHRvIHdyaXRlIGl0IGlmXG4gICAqIGdldFB1YmxpY1dyaXRlQWNjZXNzIHJldHVybnMgdHJ1ZSBvciBhIHJvbGUgdGhhdCB0aGUgdXNlciBiZWxvbmdzIHRvIGhhc1xuICAgKiB3cml0ZSBhY2Nlc3MuXG4gICAqIEBwYXJhbSB1c2VySWQgQW4gaW5zdGFuY2Ugb2YgQVYuVXNlciBvciBpdHMgb2JqZWN0SWQsIG9yIGEgQVYuUm9sZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIEFWLkFDTC5wcm90b3R5cGUuZ2V0V3JpdGVBY2Nlc3MgPSBmdW5jdGlvbih1c2VySWQpIHtcbiAgICByZXR1cm4gdGhpcy5fZ2V0QWNjZXNzKFwid3JpdGVcIiwgdXNlcklkKTtcbiAgfTtcblxuICAvKipcbiAgICogU2V0IHdoZXRoZXIgdGhlIHB1YmxpYyBpcyBhbGxvd2VkIHRvIHJlYWQgdGhpcyBvYmplY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dlZFxuICAgKi9cbiAgQVYuQUNMLnByb3RvdHlwZS5zZXRQdWJsaWNSZWFkQWNjZXNzID0gZnVuY3Rpb24oYWxsb3dlZCkge1xuICAgIHRoaXMuc2V0UmVhZEFjY2VzcyhQVUJMSUNfS0VZLCBhbGxvd2VkKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IHdoZXRoZXIgdGhlIHB1YmxpYyBpcyBhbGxvd2VkIHRvIHJlYWQgdGhpcyBvYmplY3QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBBVi5BQ0wucHJvdG90eXBlLmdldFB1YmxpY1JlYWRBY2Nlc3MgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWFkQWNjZXNzKFBVQkxJQ19LRVkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB0aGUgcHVibGljIGlzIGFsbG93ZWQgdG8gd3JpdGUgdGhpcyBvYmplY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dlZFxuICAgKi9cbiAgQVYuQUNMLnByb3RvdHlwZS5zZXRQdWJsaWNXcml0ZUFjY2VzcyA9IGZ1bmN0aW9uKGFsbG93ZWQpIHtcbiAgICB0aGlzLnNldFdyaXRlQWNjZXNzKFBVQkxJQ19LRVksIGFsbG93ZWQpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB0aGUgcHVibGljIGlzIGFsbG93ZWQgdG8gd3JpdGUgdGhpcyBvYmplY3QuXG4gICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAqL1xuICBBVi5BQ0wucHJvdG90eXBlLmdldFB1YmxpY1dyaXRlQWNjZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0V3JpdGVBY2Nlc3MoUFVCTElDX0tFWSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB3aGV0aGVyIHVzZXJzIGJlbG9uZ2luZyB0byB0aGUgZ2l2ZW4gcm9sZSBhcmUgYWxsb3dlZFxuICAgKiB0byByZWFkIHRoaXMgb2JqZWN0LiBFdmVuIGlmIHRoaXMgcmV0dXJucyBmYWxzZSwgdGhlIHJvbGUgbWF5XG4gICAqIHN0aWxsIGJlIGFibGUgdG8gd3JpdGUgaXQgaWYgYSBwYXJlbnQgcm9sZSBoYXMgcmVhZCBhY2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSByb2xlIFRoZSBuYW1lIG9mIHRoZSByb2xlLCBvciBhIEFWLlJvbGUgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSByb2xlIGhhcyByZWFkIGFjY2Vzcy4gZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAdGhyb3dzIHtTdHJpbmd9IElmIHJvbGUgaXMgbmVpdGhlciBhIEFWLlJvbGUgbm9yIGEgU3RyaW5nLlxuICAgKi9cbiAgQVYuQUNMLnByb3RvdHlwZS5nZXRSb2xlUmVhZEFjY2VzcyA9IGZ1bmN0aW9uKHJvbGUpIHtcbiAgICBpZiAocm9sZSBpbnN0YW5jZW9mIEFWLlJvbGUpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSB0byB0aGUgU3RyaW5nIG5hbWVcbiAgICAgIHJvbGUgPSByb2xlLmdldE5hbWUoKTtcbiAgICB9XG4gICAgaWYgKF8uaXNTdHJpbmcocm9sZSkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJlYWRBY2Nlc3MoXCJyb2xlOlwiICsgcm9sZSk7XG4gICAgfVxuICAgIHRocm93IFwicm9sZSBtdXN0IGJlIGEgQVYuUm9sZSBvciBhIFN0cmluZ1wiO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXQgd2hldGhlciB1c2VycyBiZWxvbmdpbmcgdG8gdGhlIGdpdmVuIHJvbGUgYXJlIGFsbG93ZWRcbiAgICogdG8gd3JpdGUgdGhpcyBvYmplY3QuIEV2ZW4gaWYgdGhpcyByZXR1cm5zIGZhbHNlLCB0aGUgcm9sZSBtYXlcbiAgICogc3RpbGwgYmUgYWJsZSB0byB3cml0ZSBpdCBpZiBhIHBhcmVudCByb2xlIGhhcyB3cml0ZSBhY2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSByb2xlIFRoZSBuYW1lIG9mIHRoZSByb2xlLCBvciBhIEFWLlJvbGUgb2JqZWN0LlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSByb2xlIGhhcyB3cml0ZSBhY2Nlc3MuIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHRocm93cyB7U3RyaW5nfSBJZiByb2xlIGlzIG5laXRoZXIgYSBBVi5Sb2xlIG5vciBhIFN0cmluZy5cbiAgICovXG4gIEFWLkFDTC5wcm90b3R5cGUuZ2V0Um9sZVdyaXRlQWNjZXNzID0gZnVuY3Rpb24ocm9sZSkge1xuICAgIGlmIChyb2xlIGluc3RhbmNlb2YgQVYuUm9sZSkge1xuICAgICAgLy8gTm9ybWFsaXplIHRvIHRoZSBTdHJpbmcgbmFtZVxuICAgICAgcm9sZSA9IHJvbGUuZ2V0TmFtZSgpO1xuICAgIH1cbiAgICBpZiAoXy5pc1N0cmluZyhyb2xlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0V3JpdGVBY2Nlc3MoXCJyb2xlOlwiICsgcm9sZSk7XG4gICAgfVxuICAgIHRocm93IFwicm9sZSBtdXN0IGJlIGEgQVYuUm9sZSBvciBhIFN0cmluZ1wiO1xuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgd2hldGhlciB1c2VycyBiZWxvbmdpbmcgdG8gdGhlIGdpdmVuIHJvbGUgYXJlIGFsbG93ZWRcbiAgICogdG8gcmVhZCB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHJvbGUgVGhlIG5hbWUgb2YgdGhlIHJvbGUsIG9yIGEgQVYuUm9sZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dlZCBXaGV0aGVyIHRoZSBnaXZlbiByb2xlIGNhbiByZWFkIHRoaXMgb2JqZWN0LlxuICAgKiBAdGhyb3dzIHtTdHJpbmd9IElmIHJvbGUgaXMgbmVpdGhlciBhIEFWLlJvbGUgbm9yIGEgU3RyaW5nLlxuICAgKi9cbiAgQVYuQUNMLnByb3RvdHlwZS5zZXRSb2xlUmVhZEFjY2VzcyA9IGZ1bmN0aW9uKHJvbGUsIGFsbG93ZWQpIHtcbiAgICBpZiAocm9sZSBpbnN0YW5jZW9mIEFWLlJvbGUpIHtcbiAgICAgIC8vIE5vcm1hbGl6ZSB0byB0aGUgU3RyaW5nIG5hbWVcbiAgICAgIHJvbGUgPSByb2xlLmdldE5hbWUoKTtcbiAgICB9XG4gICAgaWYgKF8uaXNTdHJpbmcocm9sZSkpIHtcbiAgICAgIHRoaXMuc2V0UmVhZEFjY2VzcyhcInJvbGU6XCIgKyByb2xlLCBhbGxvd2VkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgXCJyb2xlIG11c3QgYmUgYSBBVi5Sb2xlIG9yIGEgU3RyaW5nXCI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNldCB3aGV0aGVyIHVzZXJzIGJlbG9uZ2luZyB0byB0aGUgZ2l2ZW4gcm9sZSBhcmUgYWxsb3dlZFxuICAgKiB0byB3cml0ZSB0aGlzIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHJvbGUgVGhlIG5hbWUgb2YgdGhlIHJvbGUsIG9yIGEgQVYuUm9sZSBvYmplY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYWxsb3dlZCBXaGV0aGVyIHRoZSBnaXZlbiByb2xlIGNhbiB3cml0ZSB0aGlzIG9iamVjdC5cbiAgICogQHRocm93cyB7U3RyaW5nfSBJZiByb2xlIGlzIG5laXRoZXIgYSBBVi5Sb2xlIG5vciBhIFN0cmluZy5cbiAgICovXG4gIEFWLkFDTC5wcm90b3R5cGUuc2V0Um9sZVdyaXRlQWNjZXNzID0gZnVuY3Rpb24ocm9sZSwgYWxsb3dlZCkge1xuICAgIGlmIChyb2xlIGluc3RhbmNlb2YgQVYuUm9sZSkge1xuICAgICAgLy8gTm9ybWFsaXplIHRvIHRoZSBTdHJpbmcgbmFtZVxuICAgICAgcm9sZSA9IHJvbGUuZ2V0TmFtZSgpO1xuICAgIH1cbiAgICBpZiAoXy5pc1N0cmluZyhyb2xlKSkge1xuICAgICAgdGhpcy5zZXRXcml0ZUFjY2VzcyhcInJvbGU6XCIgKyByb2xlLCBhbGxvd2VkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhyb3cgXCJyb2xlIG11c3QgYmUgYSBBVi5Sb2xlIG9yIGEgU3RyaW5nXCI7XG4gIH07XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2FjbC5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qIVxuICogQVZPU0Nsb3VkIEphdmFTY3JpcHQgU0RLXG4gKiBCdWlsdDogTW9uIEp1biAwMyAyMDEzIDEzOjQ1OjAwXG4gKiBodHRwczovL2xlYW5jbG91ZC5jblxuICpcbiAqIENvcHlyaWdodCAyMDE1IExlYW5DbG91ZC5jbiwgSW5jLlxuICogVGhlIEFWT1MgQ2xvdWQgSmF2YVNjcmlwdCBTREsgaXMgZnJlZWx5IGRpc3RyaWJ1dGFibGUgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICovXG5cbnZhciBBViA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbkFWLl8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5BVi5WRVJTSU9OID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5BVi5Qcm9taXNlID0gcmVxdWlyZSgnLi9wcm9taXNlJyk7XG5BVi5YTUxIdHRwUmVxdWVzdCA9IHJlcXVpcmUoJy4vYnJvd3NlcmlmeS13cmFwcGVyL3htbGh0dHByZXF1ZXN0JykuWE1MSHR0cFJlcXVlc3Q7XG5BVi5sb2NhbFN0b3JhZ2UgPSByZXF1aXJlKCcuL2xvY2Fsc3RvcmFnZScpO1xuXG4vLyDku6XkuIvmqKHlnZfkuLrkuoblhbzlrrnljp/mnInku6PnoIHvvIzkvb/nlKjov5nnp43liqDovb3mlrnlvI/jgIJcbi8vIFRoZSBtb2R1bGUgb3JkZXIgaXMgaW1wb3J0YW50LlxucmVxdWlyZSgnLi91dGlscycpKEFWKTtcbnJlcXVpcmUoJy4vZXJyb3InKShBVik7XG5yZXF1aXJlKCcuL2V2ZW50JykoQVYpO1xucmVxdWlyZSgnLi9nZW9wb2ludCcpKEFWKTtcbnJlcXVpcmUoJy4vYWNsJykoQVYpO1xucmVxdWlyZSgnLi9vcCcpKEFWKTtcbnJlcXVpcmUoJy4vcmVsYXRpb24nKShBVik7XG5yZXF1aXJlKCcuL2ZpbGUnKShBVik7XG5yZXF1aXJlKCcuL29iamVjdCcpKEFWKTtcbnJlcXVpcmUoJy4vcm9sZScpKEFWKTtcbnJlcXVpcmUoJy4vY29sbGVjdGlvbicpKEFWKTtcbnJlcXVpcmUoJy4vdmlldycpKEFWKTtcbnJlcXVpcmUoJy4vdXNlcicpKEFWKTtcbnJlcXVpcmUoJy4vcXVlcnknKShBVik7XG5yZXF1aXJlKCcuL2ZhY2Vib29rJykoQVYpO1xucmVxdWlyZSgnLi9oaXN0b3J5JykoQVYpO1xucmVxdWlyZSgnLi9yb3V0ZXInKShBVik7XG5yZXF1aXJlKCcuL2Nsb3VkZnVuY3Rpb24nKShBVik7XG5yZXF1aXJlKCcuL3B1c2gnKShBVik7XG5yZXF1aXJlKCcuL3N0YXR1cycpKEFWKTtcbnJlcXVpcmUoJy4vc2VhcmNoJykoQVYpO1xucmVxdWlyZSgnLi9pbnNpZ2h0JykoQVYpO1xucmVxdWlyZSgnLi9iaWdxdWVyeScpKEFWKTtcblxuQVYuQVYgPSBBVjsgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9hdi5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihBVikge1xuICAvKipcbiAgICogQG5hbWVzcGFjZSDljIXlkKvkuobkvb/nlKjkuoYgTGVhbkNsb3VkXG4gICAqICA8YSBocmVmPScvZG9jcy9sZWFuaW5zaWdodF9ndWlkZS5odG1sJz7nprvnur/mlbDmja7liIbmnpDlip/og708L2E+55qE5Ye95pWw77yM5pys5qih5Z2X5bey57uP5bqf5byD77yMXG4gICAqIOivt+S9v+eUqCBBVi5JbnNpZ2h0IOOAglxuICAgKiA8cD48c3Ryb25nPjxlbT5cbiAgICogICDpg6jliIblh73mlbDku4XlnKjkupHlvJXmk47ov5DooYznjq/looPkuIvmnInmlYjjgIJcbiAgICogPC9lbT48L3N0cm9uZz48L3A+XG4gICAqL1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQVYsIFwiQmlnUXVlcnlcIiwge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJBVi5CaWdRdWVyeSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIEFWLkluc2lnaHQgaW5zdGVhZC5cIik7XG4gICAgICByZXR1cm4gQVYuSW5zaWdodDtcbiAgICB9LFxuICB9KTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2JpZ3F1ZXJ5LmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcbnZhciBQcm9taXNlID0gcmVxdWlyZSgnLi4vcHJvbWlzZScpO1xuXG4vLyBpbnRlcmZhY2UgU3RvcmFnZSB7XG4vLyAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBib29sZWFuIGFzeW5jO1xuLy8gICBzdHJpbmcgZ2V0SXRlbShzdHJpbmcga2V5KTtcbi8vICAgdm9pZCBzZXRJdGVtKHN0cmluZyBrZXksIHN0cmluZyB2YWx1ZSk7XG4vLyAgIHZvaWQgcmVtb3ZlSXRlbShzdHJpbmcga2V5KTtcbi8vICAgdm9pZCBjbGVhcigpO1xuLy8gICBQcm9taXNlIGdldEl0ZW1Bc3luYyhzdHJpbmcga2V5KTtcbi8vICAgUHJvbWlzZSBzZXRJdGVtQXN5bmMoc3RyaW5nIGtleSwgc3RyaW5nIHZhbHVlKTtcbi8vICAgUHJvbWlzZSByZW1vdmVJdGVtQXN5bmMoc3RyaW5nIGtleSk7XG4vLyAgIFByb21pc2UgY2xlYXJBc3luYygpO1xuLy8gfVxudmFyIFN0b3JhZ2UgPSB7fTtcbnZhciBhcGlOYW1lcyA9IFtcbiAgJ2dldEl0ZW0nLFxuICAnc2V0SXRlbScsXG4gICdyZW1vdmVJdGVtJyxcbiAgJ2NsZWFyJ1xuXTtcblxuaWYgKGdsb2JhbC5sb2NhbFN0b3JhZ2UpIHtcblxuICB2YXIgbG9jYWxTdG9yYWdlID0gZ2xvYmFsLmxvY2FsU3RvcmFnZTtcblxuICB0cnkge1xuICAgIHZhciB0ZXN0S2V5ID0gJ19fc3RvcmVqc19fJztcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSh0ZXN0S2V5LCB0ZXN0S2V5KTtcbiAgICBpZiAobG9jYWxTdG9yYWdlLmdldEl0ZW0odGVzdEtleSkgIT0gdGVzdEtleSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgfVxuICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3RLZXkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgbG9jYWxTdG9yYWdlID0gcmVxdWlyZSgnbG9jYWxzdG9yYWdlLW1lbW9yeScpO1xuICB9XG5cbiAgLy8gaW4gYnJvd3NlciwgYGxvY2FsU3RvcmFnZS5hc3luYyA9IGZhbHNlYCB3aWxsIGV4Y3V0ZSBgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2FzeW5jJywgZmFsc2UpYFxuICBfKGFwaU5hbWVzKS5lYWNoKGZ1bmN0aW9uKGFwaU5hbWUpIHtcbiAgICBTdG9yYWdlW2FwaU5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsLmxvY2FsU3RvcmFnZVthcGlOYW1lXS5hcHBseShnbG9iYWwubG9jYWxTdG9yYWdlLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xuICBTdG9yYWdlLmFzeW5jID0gZmFsc2U7XG59IGVsc2Uge1xuICB2YXIgQXN5bmNTdG9yYWdlID0gcmVxdWlyZSgncmVhY3QtbmF0aXZlJykuQXN5bmNTdG9yYWdlO1xuICBfKGFwaU5hbWVzKS5lYWNoKGZ1bmN0aW9uKGFwaU5hbWUpIHtcbiAgICBTdG9yYWdlW2FwaU5hbWUgKyAnQXN5bmMnXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYXMoQXN5bmNTdG9yYWdlW2FwaU5hbWVdLmFwcGx5KEFzeW5jU3RvcmFnZSwgYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgfSk7XG4gIFN0b3JhZ2UuYXN5bmMgPSB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0b3JhZ2U7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2Jyb3dzZXJpZnktd3JhcHBlci9sb2NhbHN0b3JhZ2UtYnJvd3Nlci5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9icm93c2VyaWZ5LXdyYXBwZXJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkYXRhVVJJdG9CbG9iID0gZnVuY3Rpb24oZGF0YVVSSSwgdHlwZSkge1xuICB2YXIgYnl0ZVN0cmluZztcblxuICAvLyDkvKDlhaXnmoQgYmFzZTY077yM5LiN5pivIGRhdGFVUkxcbiAgaWYgKGRhdGFVUkkuaW5kZXhPZignYmFzZTY0JykgPCAwKSB7XG4gICAgYnl0ZVN0cmluZyA9IGF0b2IoZGF0YVVSSSk7XG4gIH0gZWxzZSBpZiAoZGF0YVVSSS5zcGxpdCgnLCcpWzBdLmluZGV4T2YoJ2Jhc2U2NCcpID49IDApIHtcbiAgICBieXRlU3RyaW5nID0gYXRvYihkYXRhVVJJLnNwbGl0KCcsJylbMV0pO1xuICB9IGVsc2Uge1xuICAgIGJ5dGVTdHJpbmcgPSB1bmVzY2FwZShkYXRhVVJJLnNwbGl0KCcsJylbMV0pO1xuICB9XG4gIC8vIHNlcGFyYXRlIG91dCB0aGUgbWltZSBjb21wb25lbnRcbiAgdmFyIG1pbWVTdHJpbmcgPSB0eXBlIHx8IGRhdGFVUkkuc3BsaXQoJywnKVswXS5zcGxpdCgnOicpWzFdLnNwbGl0KCc7JylbMF07XG4gIHZhciBpYSA9IG5ldyBVaW50OEFycmF5KGJ5dGVTdHJpbmcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlU3RyaW5nLmxlbmd0aDsgaSArKykge1xuICAgICAgaWFbaV0gPSBieXRlU3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBCbG9iKFtpYV0sIHt0eXBlOm1pbWVTdHJpbmd9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZGF0YVVSSXRvQmxvYjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJvTWZwQW5cIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvYnJvd3NlcmlmeS13cmFwcGVyL3BhcnNlLWJhc2U2NC1icm93c2VyLmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2Jyb3dzZXJpZnktd3JhcHBlclwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1cGxvYWQoZmlsZSwgQVYsIHNhdmVPcHRpb25zKSB7XG4gIC8vdXNlIC9maWxlcyBlbmRwb2ludC5cbiAgdmFyIHNlbGYgPSBmaWxlO1xuICB2YXIgZGF0YUZvcm1hdDtcbiAgc2VsZi5fcHJldmlvdXNTYXZlID0gc2VsZi5fc291cmNlLnRoZW4oZnVuY3Rpb24oZGF0YSwgdHlwZSkge1xuICAgIGRhdGFGb3JtYXQgPSBkYXRhO1xuICAgIHJldHVybiBzZWxmLl9xaW5pdVRva2VuKHR5cGUpO1xuICB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgc2VsZi5fdXJsID0gcmVzcG9uc2UudXJsO1xuICAgIHNlbGYuX2J1Y2tldCA9IHJlc3BvbnNlLmJ1Y2tldDtcbiAgICBzZWxmLmlkID0gcmVzcG9uc2Uub2JqZWN0SWQ7XG4gICAgLy9HZXQgdGhlIHVwdG9rZW4gdG8gdXBsb2FkIGZpbGVzIHRvIHFpbml1LlxuICAgIHZhciB1cHRva2VuID0gcmVzcG9uc2UudG9rZW47XG5cbiAgICB2YXIgZGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuICAgIGRhdGEuYXBwZW5kKFwiZmlsZVwiLCBkYXRhRm9ybWF0LCBzZWxmLl9uYW1lKTtcbiAgICBkYXRhLmFwcGVuZChcImtleVwiLCBzZWxmLl9xaW5pdV9rZXkpO1xuICAgIGRhdGEuYXBwZW5kKFwidG9rZW5cIiwgdXB0b2tlbik7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBBVi5Qcm9taXNlKCk7XG4gICAgdmFyIGhhbmRsZWQgPSBmYWxzZTtcblxuICAgIHZhciB4aHIgPSBuZXcgQVYuWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIGlmICh4aHIudXBsb2FkKSB7XG4gICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBzYXZlT3B0aW9ucy5vblByb2dyZXNzO1xuICAgIH1cblxuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcblxuICAgICAgICBkZWxldGUgc2VsZi5fcWluaXVfa2V5O1xuICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgICAgc2VsZi5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNwb25zZSkge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHNlbGYpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLnJlamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb21pc2UucmVqZWN0KHhocik7XG4gICAgICAgICAgc2VsZi5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHhoci5vcGVuKCdQT1NUJywgJ2h0dHA6Ly91cGxvYWQucWluaXUuY29tJywgdHJ1ZSk7XG4gICAgeGhyLnNlbmQoZGF0YSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfSk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9icm93c2VyaWZ5LXdyYXBwZXIvdXBsb2FkLWJyb3dzZXIuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvYnJvd3NlcmlmeS13cmFwcGVyXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLlhNTEh0dHBSZXF1ZXN0ID0gZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9icm93c2VyaWZ5LXdyYXBwZXIveG1saHR0cHJlcXVlc3QtYnJvd3Nlci5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9icm93c2VyaWZ5LXdyYXBwZXJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEFWKSB7XG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIENvbnRhaW5zIGZ1bmN0aW9ucyBmb3IgY2FsbGluZyBhbmQgZGVjbGFyaW5nXG4gICAqIDxhIGhyZWY9XCIvZG9jcy9jbG91ZF9jb2RlX2d1aWRlI2Z1bmN0aW9uc1wiPmNsb3VkIGZ1bmN0aW9uczwvYT4uXG4gICAqIDxwPjxzdHJvbmc+PGVtPlxuICAgKiAgIFNvbWUgZnVuY3Rpb25zIGFyZSBvbmx5IGF2YWlsYWJsZSBmcm9tIENsb3VkIENvZGUuXG4gICAqIDwvZW0+PC9zdHJvbmc+PC9wPlxuICAgKi9cbiAgQVYuQ2xvdWQgPSBBVi5DbG91ZCB8fCB7fTtcblxuICBfLmV4dGVuZChBVi5DbG91ZCwgLyoqIEBsZW5kcyBBVi5DbG91ZCAqLyB7XG4gICAgLyoqXG4gICAgICogTWFrZXMgYSBjYWxsIHRvIGEgY2xvdWQgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGZ1bmN0aW9uIG5hbWUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGEgVGhlIHBhcmFtZXRlcnMgdG8gc2VuZCB0byB0aGUgY2xvdWQgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdFxuICAgICAqIG9wdGlvbnMuc3VjY2VzcywgaWYgc2V0LCBzaG91bGQgYmUgYSBmdW5jdGlvbiB0byBoYW5kbGUgYSBzdWNjZXNzZnVsXG4gICAgICogY2FsbCB0byBhIGNsb3VkIGZ1bmN0aW9uLiAgb3B0aW9ucy5lcnJvciBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaGFuZGxlcyBhbiBlcnJvciBydW5uaW5nIHRoZSBjbG91ZCBmdW5jdGlvbi4gIEJvdGggZnVuY3Rpb25zIGFyZVxuICAgICAqIG9wdGlvbmFsLiAgQm90aCBmdW5jdGlvbnMgdGFrZSBhIHNpbmdsZSBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdFxuICAgICAqIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBydW46IGZ1bmN0aW9uKG5hbWUsIGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgIHZhciByZXF1ZXN0ID0gQVYuX3JlcXVlc3QoXCJmdW5jdGlvbnNcIiwgbmFtZSwgbnVsbCwgJ1BPU1QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBBVi5fZW5jb2RlKGRhdGEsIG51bGwsIHRydWUpKTtcblxuICAgICAgcmV0dXJuIHJlcXVlc3QudGhlbihmdW5jdGlvbihyZXNwKSB7XG4gICAgICAgIHJldHVybiBBVi5fZGVjb2RlKG51bGwsIHJlc3ApLnJlc3VsdDtcbiAgICAgIH0pLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlIGEgY2FsbCB0byByZXF1ZXN0IHNlcnZlciBkYXRlIHRpbWUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdFxuICAgICAqIG9wdGlvbnMuc3VjY2VzcywgaWYgc2V0LCBzaG91bGQgYmUgYSBmdW5jdGlvbiB0byBoYW5kbGUgYSBzdWNjZXNzZnVsXG4gICAgICogY2FsbCB0byBhIGNsb3VkIGZ1bmN0aW9uLiAgb3B0aW9ucy5lcnJvciBzaG91bGQgYmUgYSBmdW5jdGlvbiB0aGF0XG4gICAgICogaGFuZGxlcyBhbiBlcnJvciBydW5uaW5nIHRoZSBjbG91ZCBmdW5jdGlvbi4gIEJvdGggZnVuY3Rpb25zIGFyZVxuICAgICAqIG9wdGlvbmFsLiAgQm90aCBmdW5jdGlvbnMgdGFrZSBhIHNpbmdsZSBhcmd1bWVudC5cbiAgICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdFxuICAgICAqIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKiBAc2luY2UgMC41LjlcbiAgICAgKi9cbiAgICBnZXRTZXJ2ZXJEYXRlOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IEFWLl9yZXF1ZXN0KFwiZGF0ZVwiLCBudWxsLCBudWxsLCAnR0VUJyk7XG5cbiAgICAgIHJldHVybiByZXF1ZXN0LnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICByZXR1cm4gQVYuX2RlY29kZShudWxsLCByZXNwKTtcbiAgICAgIH0pLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNhbGwgdG8gcmVxdWVzdCBhIHNtcyBjb2RlIGZvciBvcGVyYXRpb24gdmVyaWZpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIFRoZSBtb2JpbGUgcGhvbmUgbnVtYmVyIHN0cmluZyBvciBhIEpTT05cbiAgICAgKiAgICBvYmplY3QgdGhhdCBjb250YWlucyBtb2JpbGVQaG9uZU51bWJlcix0ZW1wbGF0ZSxvcCx0dGwsbmFtZSBldGMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0XG4gICAgICogb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHJlcXVlc3RTbXNDb2RlOiBmdW5jdGlvbihkYXRhLCBvcHRpb25zKXtcbiAgICAgIGlmKF8uaXNTdHJpbmcoZGF0YSkpIHtcbiAgICAgICAgZGF0YSA9IHsgbW9iaWxlUGhvbmVOdW1iZXI6IGRhdGEgfTtcbiAgICAgIH1cbiAgICAgIGlmKCFkYXRhLm1vYmlsZVBob25lTnVtYmVyKSB7XG4gICAgICAgIHRocm93IFwiTWlzc2luZyBtb2JpbGVQaG9uZU51bWJlci5cIjtcbiAgICAgIH1cbiAgICAgIHZhciByZXF1ZXN0ID0gQVYuX3JlcXVlc3QoXCJyZXF1ZXN0U21zQ29kZVwiLCBudWxsLCBudWxsLCAnUE9TVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhKTtcbiAgICAgIHJldHVybiByZXF1ZXN0Ll90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNhbGwgdG8gdmVyaWZ5IHNtcyBjb2RlIHRoYXQgc2VudCBieSBBVi5DbG91ZC5yZXF1ZXN0U21zQ29kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlIFRoZSBzbXMgY29kZSBzZW50IGJ5IEFWLkNsb3VkLnJlcXVlc3RTbXNDb2RlXG4gICAgICogQHBhcmFtIHtwaG9uZX0gcGhvbmUgVGhlIG1vYmlsZSBwaG9uZXIgbnVtYmVyKG9wdGlvbmFsKS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgKiBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdmVyaWZ5U21zQ29kZTogZnVuY3Rpb24oY29kZSwgcGhvbmUsIG9wdGlvbnMpe1xuICAgICAgaWYoIWNvZGUpXG4gICAgICAgIHRocm93IFwiTWlzc2luZyBzbXMgY29kZS5cIjtcbiAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgIGlmKEFWLl8uaXNTdHJpbmcocGhvbmUpKSB7XG4gICAgICAgICBwYXJhbXNbJ21vYmlsZVBob25lTnVtYmVyJ10gPSBwaG9uZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRvIGJlIGNvbXBhdGlibGUgd2l0aCBvbGQgdmVyc2lvbnMuXG4gICAgICAgICBvcHRpb25zID0gcGhvbmU7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXF1ZXN0ID0gQVYuX3JlcXVlc3QoXCJ2ZXJpZnlTbXNDb2RlXCIsIGNvZGUsIG51bGwsICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zKTtcbiAgICAgIHJldHVybiByZXF1ZXN0Ll90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH1cbiAgfSk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9jbG91ZGZ1bmN0aW9uLmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihBVikge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSB3aXRoIHRoZSBnaXZlbiBtb2RlbHMgYW5kIG9wdGlvbnMuICBUeXBpY2FsbHksIHlvdVxuICAgKiB3aWxsIG5vdCBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5LCBidXQgd2lsbCBpbnN0ZWFkIG1ha2UgYSBzdWJjbGFzcyB1c2luZ1xuICAgKiA8Y29kZT5BVi5Db2xsZWN0aW9uLmV4dGVuZDwvY29kZT4uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IG1vZGVscyBBbiBhcnJheSBvZiBpbnN0YW5jZXMgb2YgPGNvZGU+QVYuT2JqZWN0PC9jb2RlPi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9uYWwgb2JqZWN0IHdpdGggQmFja2JvbmUtc3R5bGUgb3B0aW9ucy5cbiAgICogVmFsaWQgb3B0aW9ucyBhcmU6PHVsPlxuICAgKiAgIDxsaT5tb2RlbDogVGhlIEFWLk9iamVjdCBzdWJjbGFzcyB0aGF0IHRoaXMgY29sbGVjdGlvbiBjb250YWlucy5cbiAgICogICA8bGk+cXVlcnk6IEFuIGluc3RhbmNlIG9mIEFWLlF1ZXJ5IHRvIHVzZSB3aGVuIGZldGNoaW5nIGl0ZW1zLlxuICAgKiAgIDxsaT5jb21wYXJhdG9yOiBBIHN0cmluZyBwcm9wZXJ0eSBuYW1lIG9yIGZ1bmN0aW9uIHRvIHNvcnQgYnkuXG4gICAqIDwvdWw+XG4gICAqXG4gICAqIEBzZWUgQVYuQ29sbGVjdGlvbi5leHRlbmRcbiAgICpcbiAgICogQGNsYXNzXG4gICAqXG4gICAqIDxwPlByb3ZpZGVzIGEgc3RhbmRhcmQgY29sbGVjdGlvbiBjbGFzcyBmb3Igb3VyIHNldHMgb2YgbW9kZWxzLCBvcmRlcmVkXG4gICAqIG9yIHVub3JkZXJlZC4gIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWUgdGhlXG4gICAqIDxhIGhyZWY9XCJodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL2JhY2tib25lLyNDb2xsZWN0aW9uXCI+QmFja2JvbmVcbiAgICogZG9jdW1lbnRhdGlvbjwvYT4uPC9wPlxuICAgKi9cbiAgQVYuQ29sbGVjdGlvbiA9IGZ1bmN0aW9uKG1vZGVscywgb3B0aW9ucykge1xuICAgIGNvbnNvbGUud2FybihcIkFWLkNvbGxlY3Rpb24gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIGRvbid0IHVzZSBpdCBhbnltb3JlLlwiKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5jb21wYXJhdG9yKSB7XG4gICAgICB0aGlzLmNvbXBhcmF0b3IgPSBvcHRpb25zLmNvbXBhcmF0b3I7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLm1vZGVsKSB7XG4gICAgICB0aGlzLm1vZGVsID0gb3B0aW9ucy5tb2RlbDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucXVlcnkpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBvcHRpb25zLnF1ZXJ5O1xuICAgIH1cbiAgICB0aGlzLl9yZXNldCgpO1xuICAgIHRoaXMuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIGlmIChtb2RlbHMpIHtcbiAgICAgIHRoaXMucmVzZXQobW9kZWxzLCB7c2lsZW50OiB0cnVlLCBwYXJzZTogb3B0aW9ucy5wYXJzZX0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBEZWZpbmUgdGhlIENvbGxlY3Rpb24ncyBpbmhlcml0YWJsZSBtZXRob2RzLlxuICBfLmV4dGVuZChBVi5Db2xsZWN0aW9uLnByb3RvdHlwZSwgQVYuRXZlbnRzLFxuICAgICAgLyoqIEBsZW5kcyBBVi5Db2xsZWN0aW9uLnByb3RvdHlwZSAqLyB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBtb2RlbCBmb3IgYSBjb2xsZWN0aW9uIGlzIGp1c3QgYSBBVi5PYmplY3QuXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgb3ZlcnJpZGRlbiBpbiBtb3N0IGNhc2VzLlxuXG4gICAgbW9kZWw6IEFWLk9iamVjdCxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgICAqIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIGEgQ29sbGVjdGlvbiBpcyBhbiBhcnJheSBvZiB0aGVcbiAgICAgKiBtb2RlbHMnIGF0dHJpYnV0ZXMuXG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbihtb2RlbCl7IHJldHVybiBtb2RlbC50b0pTT04oKTsgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIG1vZGVsLCBvciBsaXN0IG9mIG1vZGVscyB0byB0aGUgc2V0LiBQYXNzICoqc2lsZW50KiogdG8gYXZvaWRcbiAgICAgKiBmaXJpbmcgdGhlIGBhZGRgIGV2ZW50IGZvciBldmVyeSBuZXcgbW9kZWwuXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBpLCBpbmRleCwgbGVuZ3RoLCBtb2RlbCwgY2lkLCBpZCwgY2lkcyA9IHt9LCBpZHMgPSB7fTtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgbW9kZWxzID0gXy5pc0FycmF5KG1vZGVscykgPyBtb2RlbHMuc2xpY2UoKSA6IFttb2RlbHNdO1xuXG4gICAgICAvLyBCZWdpbiBieSB0dXJuaW5nIGJhcmUgb2JqZWN0cyBpbnRvIG1vZGVsIHJlZmVyZW5jZXMsIGFuZCBwcmV2ZW50aW5nXG4gICAgICAvLyBpbnZhbGlkIG1vZGVscyBvciBkdXBsaWNhdGUgbW9kZWxzIGZyb20gYmVpbmcgYWRkZWQuXG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBtb2RlbHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbW9kZWxzW2ldID0gdGhpcy5fcHJlcGFyZU1vZGVsKG1vZGVsc1tpXSwgb3B0aW9ucyk7XG4gICAgICAgIG1vZGVsID0gbW9kZWxzW2ldO1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgYWRkIGFuIGludmFsaWQgbW9kZWwgdG8gYSBjb2xsZWN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNpZCA9IG1vZGVsLmNpZDtcbiAgICAgICAgaWYgKGNpZHNbY2lkXSB8fCB0aGlzLl9ieUNpZFtjaWRdKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRHVwbGljYXRlIGNpZDogY2FuJ3QgYWRkIHRoZSBzYW1lIG1vZGVsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0byBhIGNvbGxlY3Rpb24gdHdpY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWQgPSBtb2RlbC5pZDtcbiAgICAgICAgaWYgKCFBVi5faXNOdWxsT3JVbmRlZmluZWQoaWQpICYmIChpZHNbaWRdIHx8IHRoaXMuX2J5SWRbaWRdKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBpZDogY2FuJ3QgYWRkIHRoZSBzYW1lIG1vZGVsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0byBhIGNvbGxlY3Rpb24gdHdpY2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWRzW2lkXSA9IG1vZGVsO1xuICAgICAgICBjaWRzW2NpZF0gPSBtb2RlbDtcbiAgICAgIH1cblxuICAgICAgLy8gTGlzdGVuIHRvIGFkZGVkIG1vZGVscycgZXZlbnRzLCBhbmQgaW5kZXggbW9kZWxzIGZvciBsb29rdXAgYnlcbiAgICAgIC8vIGBpZGAgYW5kIGJ5IGBjaWRgLlxuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIChtb2RlbCA9IG1vZGVsc1tpXSkub24oJ2FsbCcsIHRoaXMuX29uTW9kZWxFdmVudCwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2J5Q2lkW21vZGVsLmNpZF0gPSBtb2RlbDtcbiAgICAgICAgaWYgKG1vZGVsLmlkKSB7XG4gICAgICAgICAgdGhpcy5fYnlJZFttb2RlbC5pZF0gPSBtb2RlbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJbnNlcnQgbW9kZWxzIGludG8gdGhlIGNvbGxlY3Rpb24sIHJlLXNvcnRpbmcgaWYgbmVlZGVkLCBhbmQgdHJpZ2dlcmluZ1xuICAgICAgLy8gYGFkZGAgZXZlbnRzIHVubGVzcyBzaWxlbmNlZC5cbiAgICAgIHRoaXMubGVuZ3RoICs9IGxlbmd0aDtcbiAgICAgIGluZGV4ID0gQVYuX2lzTnVsbE9yVW5kZWZpbmVkKG9wdGlvbnMuYXQpID9cbiAgICAgICAgICB0aGlzLm1vZGVscy5sZW5ndGggOiBvcHRpb25zLmF0O1xuICAgICAgdGhpcy5tb2RlbHMuc3BsaWNlLmFwcGx5KHRoaXMubW9kZWxzLCBbaW5kZXgsIDBdLmNvbmNhdChtb2RlbHMpKTtcbiAgICAgIGlmICh0aGlzLmNvbXBhcmF0b3IpIHtcbiAgICAgICAgdGhpcy5zb3J0KHtzaWxlbnQ6IHRydWV9KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnNpbGVudCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IHRoaXMubW9kZWxzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG1vZGVsID0gdGhpcy5tb2RlbHNbaV07XG4gICAgICAgIGlmIChjaWRzW21vZGVsLmNpZF0pIHtcbiAgICAgICAgICBvcHRpb25zLmluZGV4ID0gaTtcbiAgICAgICAgICBtb2RlbC50cmlnZ2VyKCdhZGQnLCBtb2RlbCwgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBtb2RlbCwgb3IgYSBsaXN0IG9mIG1vZGVscyBmcm9tIHRoZSBzZXQuIFBhc3Mgc2lsZW50IHRvIGF2b2lkXG4gICAgICogZmlyaW5nIHRoZSA8Y29kZT5yZW1vdmU8L2NvZGU+IGV2ZW50IGZvciBldmVyeSBtb2RlbCByZW1vdmVkLlxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24obW9kZWxzLCBvcHRpb25zKSB7XG4gICAgICB2YXIgaSwgbCwgaW5kZXgsIG1vZGVsO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBtb2RlbHMgPSBfLmlzQXJyYXkobW9kZWxzKSA/IG1vZGVscy5zbGljZSgpIDogW21vZGVsc107XG4gICAgICBmb3IgKGkgPSAwLCBsID0gbW9kZWxzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBtb2RlbCA9IHRoaXMuZ2V0QnlDaWQobW9kZWxzW2ldKSB8fCB0aGlzLmdldChtb2RlbHNbaV0pO1xuICAgICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwuaWRdO1xuICAgICAgICBkZWxldGUgdGhpcy5fYnlDaWRbbW9kZWwuY2lkXTtcbiAgICAgICAgaW5kZXggPSB0aGlzLmluZGV4T2YobW9kZWwpO1xuICAgICAgICB0aGlzLm1vZGVscy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB0aGlzLmxlbmd0aC0tO1xuICAgICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgb3B0aW9ucy5pbmRleCA9IGluZGV4O1xuICAgICAgICAgIG1vZGVsLnRyaWdnZXIoJ3JlbW92ZScsIG1vZGVsLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdmVSZWZlcmVuY2UobW9kZWwpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgYSBtb2RlbCBmcm9tIHRoZSBzZXQgYnkgaWQuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihpZCkge1xuICAgICAgcmV0dXJuIGlkICYmIHRoaXMuX2J5SWRbaWQuaWQgfHwgaWRdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbW9kZWwgZnJvbSB0aGUgc2V0IGJ5IGNsaWVudCBpZC5cbiAgICAgKi9cbiAgICBnZXRCeUNpZDogZnVuY3Rpb24oY2lkKSB7XG4gICAgICByZXR1cm4gY2lkICYmIHRoaXMuX2J5Q2lkW2NpZC5jaWQgfHwgY2lkXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgbW9kZWwgYXQgdGhlIGdpdmVuIGluZGV4LlxuICAgICAqL1xuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZWxzW2luZGV4XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yY2VzIHRoZSBjb2xsZWN0aW9uIHRvIHJlLXNvcnQgaXRzZWxmLiBZb3UgZG9uJ3QgbmVlZCB0byBjYWxsIHRoaXNcbiAgICAgKiB1bmRlciBub3JtYWwgY2lyY3Vtc3RhbmNlcywgYXMgdGhlIHNldCB3aWxsIG1haW50YWluIHNvcnQgb3JkZXIgYXMgZWFjaFxuICAgICAqIGl0ZW0gaXMgYWRkZWQuXG4gICAgICovXG4gICAgc29ydDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIXRoaXMuY29tcGFyYXRvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzb3J0IGEgc2V0IHdpdGhvdXQgYSBjb21wYXJhdG9yJyk7XG4gICAgICB9XG4gICAgICB2YXIgYm91bmRDb21wYXJhdG9yID0gXy5iaW5kKHRoaXMuY29tcGFyYXRvciwgdGhpcyk7XG4gICAgICBpZiAodGhpcy5jb21wYXJhdG9yLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICB0aGlzLm1vZGVscyA9IHRoaXMuc29ydEJ5KGJvdW5kQ29tcGFyYXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLm1vZGVscy5zb3J0KGJvdW5kQ29tcGFyYXRvcik7XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcigncmVzZXQnLCB0aGlzLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQbHVja3MgYW4gYXR0cmlidXRlIGZyb20gZWFjaCBtb2RlbCBpbiB0aGUgY29sbGVjdGlvbi5cbiAgICAgKi9cbiAgICBwbHVjazogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIF8ubWFwKHRoaXMubW9kZWxzLCBmdW5jdGlvbihtb2RlbCl7IHJldHVybiBtb2RlbC5nZXQoYXR0cik7IH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBXaGVuIHlvdSBoYXZlIG1vcmUgaXRlbXMgdGhhbiB5b3Ugd2FudCB0byBhZGQgb3IgcmVtb3ZlIGluZGl2aWR1YWxseSxcbiAgICAgKiB5b3UgY2FuIHJlc2V0IHRoZSBlbnRpcmUgc2V0IHdpdGggYSBuZXcgbGlzdCBvZiBtb2RlbHMsIHdpdGhvdXQgZmlyaW5nXG4gICAgICogYW55IGBhZGRgIG9yIGByZW1vdmVgIGV2ZW50cy4gRmlyZXMgYHJlc2V0YCB3aGVuIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbihtb2RlbHMsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIG1vZGVscyA9IG1vZGVscyB8fCBbXTtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgQVYuX2FycmF5RWFjaCh0aGlzLm1vZGVscywgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgc2VsZi5fcmVtb3ZlUmVmZXJlbmNlKG1vZGVsKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgIHRoaXMuYWRkKG1vZGVscywge3NpbGVudDogdHJ1ZSwgcGFyc2U6IG9wdGlvbnMucGFyc2V9KTtcbiAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdyZXNldCcsIHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZldGNoZXMgdGhlIGRlZmF1bHQgc2V0IG9mIG1vZGVscyBmb3IgdGhpcyBjb2xsZWN0aW9uLCByZXNldHRpbmcgdGhlXG4gICAgICogY29sbGVjdGlvbiB3aGVuIHRoZXkgYXJyaXZlLiBJZiBgYWRkOiB0cnVlYCBpcyBwYXNzZWQsIGFwcGVuZHMgdGhlXG4gICAgICogbW9kZWxzIHRvIHRoZSBjb2xsZWN0aW9uIGluc3RlYWQgb2YgcmVzZXR0aW5nLlxuICAgICAqL1xuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gXy5jbG9uZShvcHRpb25zKSB8fCB7fTtcbiAgICAgIGlmIChvcHRpb25zLnBhcnNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5wYXJzZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YXIgY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5IHx8IG5ldyBBVi5RdWVyeSh0aGlzLm1vZGVsKTtcbiAgICAgIHJldHVybiBxdWVyeS5maW5kKCkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAgICAgIGlmIChvcHRpb25zLmFkZCkge1xuICAgICAgICAgIGNvbGxlY3Rpb24uYWRkKHJlc3VsdHMsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbGxlY3Rpb24ucmVzZXQocmVzdWx0cywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb247XG4gICAgICB9KS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIG1vZGVsIGluIHRoaXMgY29sbGVjdGlvbi4gQWRkIHRoZSBtb2RlbCB0b1xuICAgICAqIHRoZSBjb2xsZWN0aW9uIGltbWVkaWF0ZWx5LCB1bmxlc3MgYHdhaXQ6IHRydWVgIGlzIHBhc3NlZCwgaW4gd2hpY2ggY2FzZVxuICAgICAqIHdlIHdhaXQgZm9yIHRoZSBzZXJ2ZXIgdG8gYWdyZWUuXG4gICAgICovXG4gICAgY3JlYXRlOiBmdW5jdGlvbihtb2RlbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGNvbGwgPSB0aGlzO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBfLmNsb25lKG9wdGlvbnMpIDoge307XG4gICAgICBtb2RlbCA9IHRoaXMuX3ByZXBhcmVNb2RlbChtb2RlbCwgb3B0aW9ucyk7XG4gICAgICBpZiAoIW1vZGVsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucy53YWl0KSB7XG4gICAgICAgIGNvbGwuYWRkKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHZhciBzdWNjZXNzID0gb3B0aW9ucy5zdWNjZXNzO1xuICAgICAgb3B0aW9ucy5zdWNjZXNzID0gZnVuY3Rpb24obmV4dE1vZGVsLCByZXNwLCB4aHIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2FpdCkge1xuICAgICAgICAgIGNvbGwuYWRkKG5leHRNb2RlbCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdWNjZXNzKG5leHRNb2RlbCwgcmVzcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dE1vZGVsLnRyaWdnZXIoJ3N5bmMnLCBtb2RlbCwgcmVzcCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBtb2RlbC5zYXZlKG51bGwsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHJlc3BvbnNlIGludG8gYSBsaXN0IG9mIG1vZGVscyB0byBiZSBhZGRlZCB0byB0aGUgY29sbGVjdGlvbi5cbiAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBpcyBqdXN0IHRvIHBhc3MgaXQgdGhyb3VnaC5cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHJlc3AsIHhocikge1xuICAgICAgcmV0dXJuIHJlc3A7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByb3h5IHRvIF8ncyBjaGFpbi4gQ2FuJ3QgYmUgcHJveGllZCB0aGUgc2FtZSB3YXkgdGhlIHJlc3Qgb2YgdGhlXG4gICAgICogdW5kZXJzY29yZSBtZXRob2RzIGFyZSBwcm94aWVkIGJlY2F1c2UgaXQgcmVsaWVzIG9uIHRoZSB1bmRlcnNjb3JlXG4gICAgICogY29uc3RydWN0b3IuXG4gICAgICovXG4gICAgY2hhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF8odGhpcy5tb2RlbHMpLmNoYWluKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc2V0IGFsbCBpbnRlcm5hbCBzdGF0ZS4gQ2FsbGVkIHdoZW4gdGhlIGNvbGxlY3Rpb24gaXMgcmVzZXQuXG4gICAgICovXG4gICAgX3Jlc2V0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICB0aGlzLm1vZGVscyA9IFtdO1xuICAgICAgdGhpcy5fYnlJZCAgPSB7fTtcbiAgICAgIHRoaXMuX2J5Q2lkID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmUgYSBtb2RlbCBvciBoYXNoIG9mIGF0dHJpYnV0ZXMgdG8gYmUgYWRkZWQgdG8gdGhpcyBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIF9wcmVwYXJlTW9kZWw6IGZ1bmN0aW9uKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIShtb2RlbCBpbnN0YW5jZW9mIEFWLk9iamVjdCkpIHtcbiAgICAgICAgdmFyIGF0dHJzID0gbW9kZWw7XG4gICAgICAgIG9wdGlvbnMuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICAgIG1vZGVsID0gbmV3IHRoaXMubW9kZWwoYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIW1vZGVsLl92YWxpZGF0ZShtb2RlbC5hdHRyaWJ1dGVzLCBvcHRpb25zKSkge1xuICAgICAgICAgIG1vZGVsID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIW1vZGVsLmNvbGxlY3Rpb24pIHtcbiAgICAgICAgbW9kZWwuY29sbGVjdGlvbiA9IHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIG1ldGhvZCB0byByZW1vdmUgYSBtb2RlbCdzIHRpZXMgdG8gYSBjb2xsZWN0aW9uLlxuICAgICAqL1xuICAgIF9yZW1vdmVSZWZlcmVuY2U6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICBpZiAodGhpcyA9PT0gbW9kZWwuY29sbGVjdGlvbikge1xuICAgICAgICBkZWxldGUgbW9kZWwuY29sbGVjdGlvbjtcbiAgICAgIH1cbiAgICAgIG1vZGVsLm9mZignYWxsJywgdGhpcy5fb25Nb2RlbEV2ZW50LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIGNhbGxlZCBldmVyeSB0aW1lIGEgbW9kZWwgaW4gdGhlIHNldCBmaXJlcyBhbiBldmVudC5cbiAgICAgKiBTZXRzIG5lZWQgdG8gdXBkYXRlIHRoZWlyIGluZGV4ZXMgd2hlbiBtb2RlbHMgY2hhbmdlIGlkcy4gQWxsIG90aGVyXG4gICAgICogZXZlbnRzIHNpbXBseSBwcm94eSB0aHJvdWdoLiBcImFkZFwiIGFuZCBcInJlbW92ZVwiIGV2ZW50cyB0aGF0IG9yaWdpbmF0ZVxuICAgICAqIGluIG90aGVyIGNvbGxlY3Rpb25zIGFyZSBpZ25vcmVkLlxuICAgICAqL1xuICAgIF9vbk1vZGVsRXZlbnQ6IGZ1bmN0aW9uKGV2LCBtb2RlbCwgY29sbGVjdGlvbiwgb3B0aW9ucykge1xuICAgICAgaWYgKChldiA9PT0gJ2FkZCcgfHwgZXYgPT09ICdyZW1vdmUnKSAmJiBjb2xsZWN0aW9uICE9PSB0aGlzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChldiA9PT0gJ2Rlc3Ryb3knKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKG1vZGVsLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlbCAmJiBldiA9PT0gJ2NoYW5nZTpvYmplY3RJZCcpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbbW9kZWwucHJldmlvdXMoXCJvYmplY3RJZFwiKV07XG4gICAgICAgIHRoaXMuX2J5SWRbbW9kZWwuaWRdID0gbW9kZWw7XG4gICAgICB9XG4gICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgfSk7XG5cbiAgLy8gVW5kZXJzY29yZSBtZXRob2RzIHRoYXQgd2Ugd2FudCB0byBpbXBsZW1lbnQgb24gdGhlIENvbGxlY3Rpb24uXG4gIHZhciBtZXRob2RzID0gWydmb3JFYWNoJywgJ2VhY2gnLCAnbWFwJywgJ3JlZHVjZScsICdyZWR1Y2VSaWdodCcsICdmaW5kJyxcbiAgICAnZGV0ZWN0JywgJ2ZpbHRlcicsICdzZWxlY3QnLCAncmVqZWN0JywgJ2V2ZXJ5JywgJ2FsbCcsICdzb21lJywgJ2FueScsXG4gICAgJ2luY2x1ZGUnLCAnY29udGFpbnMnLCAnaW52b2tlJywgJ21heCcsICdtaW4nLCAnc29ydEJ5JywgJ3NvcnRlZEluZGV4JyxcbiAgICAndG9BcnJheScsICdzaXplJywgJ2ZpcnN0JywgJ2luaXRpYWwnLCAncmVzdCcsICdsYXN0JywgJ3dpdGhvdXQnLCAnaW5kZXhPZicsXG4gICAgJ3NodWZmbGUnLCAnbGFzdEluZGV4T2YnLCAnaXNFbXB0eScsICdncm91cEJ5J107XG5cbiAgLy8gTWl4IGluIGVhY2ggVW5kZXJzY29yZSBtZXRob2QgYXMgYSBwcm94eSB0byBgQ29sbGVjdGlvbiNtb2RlbHNgLlxuICBBVi5fYXJyYXlFYWNoKG1ldGhvZHMsIGZ1bmN0aW9uKG1ldGhvZCkge1xuICAgIEFWLkNvbGxlY3Rpb24ucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfW21ldGhvZF0uYXBwbHkoXywgW3RoaXMubW9kZWxzXS5jb25jYXQoXy50b0FycmF5KGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICB9KTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdWJjbGFzcyBvZiA8Y29kZT5BVi5Db2xsZWN0aW9uPC9jb2RlPi4gIEZvciBleGFtcGxlLDxwcmU+XG4gICAqICAgdmFyIE15Q29sbGVjdGlvbiA9IEFWLkNvbGxlY3Rpb24uZXh0ZW5kKHtcbiAgICogICAgIC8vIEluc3RhbmNlIHByb3BlcnRpZXNcbiAgICpcbiAgICogICAgIG1vZGVsOiBNeUNsYXNzLFxuICAgKiAgICAgcXVlcnk6IE15UXVlcnksXG4gICAqXG4gICAqICAgICBnZXRGaXJzdDogZnVuY3Rpb24oKSB7XG4gICAqICAgICAgIHJldHVybiB0aGlzLmF0KDApO1xuICAgKiAgICAgfVxuICAgKiAgIH0sIHtcbiAgICogICAgIC8vIENsYXNzIHByb3BlcnRpZXNcbiAgICpcbiAgICogICAgIG1ha2VPbmU6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgICByZXR1cm4gbmV3IE15Q29sbGVjdGlvbigpO1xuICAgKiAgICAgfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiAgIHZhciBjb2xsZWN0aW9uID0gbmV3IE15Q29sbGVjdGlvbigpO1xuICAgKiA8L3ByZT5cbiAgICpcbiAgICogQGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZVByb3BzIEluc3RhbmNlIHByb3BlcnRpZXMgZm9yIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2xhc3NQcm9wcyBDbGFzcyBwcm9wZXJpZXMgZm9yIHRoZSBjb2xsZWN0aW9uLlxuICAgKiBAcmV0dXJuIHtDbGFzc30gQSBuZXcgc3ViY2xhc3Mgb2YgPGNvZGU+QVYuQ29sbGVjdGlvbjwvY29kZT4uXG4gICAqL1xuICBBVi5Db2xsZWN0aW9uLmV4dGVuZCA9IEFWLl9leHRlbmQ7XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2NvbGxlY3Rpb24uanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEFWKSB7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgQVYuRXJyb3Igb2JqZWN0IHdpdGggdGhlIGdpdmVuIGNvZGUgYW5kIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIEFuIGVycm9yIGNvZGUgY29uc3RhbnQgZnJvbSA8Y29kZT5BVi5FcnJvcjwvY29kZT4uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIEEgZGV0YWlsZWQgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yLlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICogPHA+Q2xhc3MgdXNlZCBmb3IgYWxsIG9iamVjdHMgcGFzc2VkIHRvIGVycm9yIGNhbGxiYWNrcy48L3A+XG4gICAqL1xuICBBVi5FcnJvciA9IGZ1bmN0aW9uKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gIH07XG5cbiAgXy5leHRlbmQoQVYuRXJyb3IsIC8qKiBAbGVuZHMgQVYuRXJyb3IgKi8ge1xuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyBzb21lIGVycm9yIG90aGVyIHRoYW4gdGhvc2UgZW51bWVyYXRlZCBoZXJlLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIE9USEVSX0NBVVNFOiAtMSxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IHNvbWV0aGluZyBoYXMgZ29uZSB3cm9uZyB3aXRoIHRoZSBzZXJ2ZXIuXG4gICAgICogSWYgeW91IGdldCB0aGlzIGVycm9yIGNvZGUsIGl0IGlzIEFWJ3MgZmF1bHQuIENvbnRhY3QgdXMgYXRcbiAgICAgKiBodHRwczovL2F2b3NjbG91ZC5jb20vaGVscFxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIElOVEVSTkFMX1NFUlZFUl9FUlJPUjogMSxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGUgY29ubmVjdGlvbiB0byB0aGUgQVYgc2VydmVycyBmYWlsZWQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgQ09OTkVDVElPTl9GQUlMRUQ6IDEwMCxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGUgc3BlY2lmaWVkIG9iamVjdCBkb2Vzbid0IGV4aXN0LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIE9CSkVDVF9OT1RfRk9VTkQ6IDEwMSxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB5b3UgdHJpZWQgdG8gcXVlcnkgd2l0aCBhIGRhdGF0eXBlIHRoYXQgZG9lc24ndFxuICAgICAqIHN1cHBvcnQgaXQsIGxpa2UgZXhhY3QgbWF0Y2hpbmcgYW4gYXJyYXkgb3Igb2JqZWN0LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIElOVkFMSURfUVVFUlk6IDEwMixcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyBhIG1pc3Npbmcgb3IgaW52YWxpZCBjbGFzc25hbWUuIENsYXNzbmFtZXMgYXJlXG4gICAgICogY2FzZS1zZW5zaXRpdmUuIFRoZXkgbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLCBhbmQgYS16QS1aMC05XyBhcmUgdGhlXG4gICAgICogb25seSB2YWxpZCBjaGFyYWN0ZXJzLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIElOVkFMSURfQ0xBU1NfTkFNRTogMTAzLFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIGFuIHVuc3BlY2lmaWVkIG9iamVjdCBpZC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBNSVNTSU5HX09CSkVDVF9JRDogMTA0LFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIGFuIGludmFsaWQga2V5IG5hbWUuIEtleXMgYXJlIGNhc2Utc2Vuc2l0aXZlLiBUaGV5XG4gICAgICogbXVzdCBzdGFydCB3aXRoIGEgbGV0dGVyLCBhbmQgYS16QS1aMC05XyBhcmUgdGhlIG9ubHkgdmFsaWQgY2hhcmFjdGVycy5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBJTlZBTElEX0tFWV9OQU1FOiAxMDUsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgYSBtYWxmb3JtZWQgcG9pbnRlci4gWW91IHNob3VsZCBub3Qgc2VlIHRoaXMgdW5sZXNzXG4gICAgICogeW91IGhhdmUgYmVlbiBtdWNraW5nIGFib3V0IGNoYW5naW5nIGludGVybmFsIEFWIGNvZGUuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgSU5WQUxJRF9QT0lOVEVSOiAxMDYsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBiYWRseSBmb3JtZWQgSlNPTiB3YXMgcmVjZWl2ZWQgdXBzdHJlYW0uIFRoaXNcbiAgICAgKiBlaXRoZXIgaW5kaWNhdGVzIHlvdSBoYXZlIGRvbmUgc29tZXRoaW5nIHVudXN1YWwgd2l0aCBtb2RpZnlpbmcgaG93XG4gICAgICogdGhpbmdzIGVuY29kZSB0byBKU09OLCBvciB0aGUgbmV0d29yayBpcyBmYWlsaW5nIGJhZGx5LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIElOVkFMSURfSlNPTjogMTA3LFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoYXQgdGhlIGZlYXR1cmUgeW91IHRyaWVkIHRvIGFjY2VzcyBpcyBvbmx5XG4gICAgICogYXZhaWxhYmxlIGludGVybmFsbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgQ09NTUFORF9VTkFWQUlMQUJMRTogMTA4LFxuXG4gICAgLyoqXG4gICAgICogWW91IG11c3QgY2FsbCBBVi5pbml0aWFsaXplIGJlZm9yZSB1c2luZyB0aGUgQVYgbGlicmFyeS5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBOT1RfSU5JVElBTElaRUQ6IDEwOSxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IGEgZmllbGQgd2FzIHNldCB0byBhbiBpbmNvbnNpc3RlbnQgdHlwZS5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBJTkNPUlJFQ1RfVFlQRTogMTExLFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIGFuIGludmFsaWQgY2hhbm5lbCBuYW1lLiBBIGNoYW5uZWwgbmFtZSBpcyBlaXRoZXJcbiAgICAgKiBhbiBlbXB0eSBzdHJpbmcgKHRoZSBicm9hZGNhc3QgY2hhbm5lbCkgb3IgY29udGFpbnMgb25seSBhLXpBLVowLTlfXG4gICAgICogY2hhcmFjdGVycyBhbmQgc3RhcnRzIHdpdGggYSBsZXR0ZXIuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgSU5WQUxJRF9DSEFOTkVMX05BTUU6IDExMixcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IHB1c2ggaXMgbWlzY29uZmlndXJlZC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBQVVNIX01JU0NPTkZJR1VSRUQ6IDExNSxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IHRoZSBvYmplY3QgaXMgdG9vIGxhcmdlLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIE9CSkVDVF9UT09fTEFSR0U6IDExNixcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IHRoZSBvcGVyYXRpb24gaXNuJ3QgYWxsb3dlZCBmb3IgY2xpZW50cy5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBPUEVSQVRJT05fRk9SQklEREVOOiAxMTksXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhlIHJlc3VsdCB3YXMgbm90IGZvdW5kIGluIHRoZSBjYWNoZS5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBDQUNIRV9NSVNTOiAxMjAsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhbiBpbnZhbGlkIGtleSB3YXMgdXNlZCBpbiBhIG5lc3RlZFxuICAgICAqIEpTT05PYmplY3QuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgSU5WQUxJRF9ORVNURURfS0VZOiAxMjEsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhbiBpbnZhbGlkIGZpbGVuYW1lIHdhcyB1c2VkIGZvciBBVkZpbGUuXG4gICAgICogQSB2YWxpZCBmaWxlIG5hbWUgY29udGFpbnMgb25seSBhLXpBLVowLTlfLiBjaGFyYWN0ZXJzIGFuZCBpcyBiZXR3ZWVuIDFcbiAgICAgKiBhbmQgMTI4IGNoYXJhY3RlcnMuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgSU5WQUxJRF9GSUxFX05BTUU6IDEyMixcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyBhbiBpbnZhbGlkIEFDTCB3YXMgcHJvdmlkZWQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgSU5WQUxJRF9BQ0w6IDEyMyxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IHRoZSByZXF1ZXN0IHRpbWVkIG91dCBvbiB0aGUgc2VydmVyLiBUeXBpY2FsbHlcbiAgICAgKiB0aGlzIGluZGljYXRlcyB0aGF0IHRoZSByZXF1ZXN0IGlzIHRvbyBleHBlbnNpdmUgdG8gcnVuLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIFRJTUVPVVQ6IDEyNCxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IHRoZSBlbWFpbCBhZGRyZXNzIHdhcyBpbnZhbGlkLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIElOVkFMSURfRU1BSUxfQUREUkVTUzogMTI1LFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIGEgbWlzc2luZyBjb250ZW50IHR5cGUuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgTUlTU0lOR19DT05URU5UX1RZUEU6IDEyNixcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyBhIG1pc3NpbmcgY29udGVudCBsZW5ndGguXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgTUlTU0lOR19DT05URU5UX0xFTkdUSDogMTI3LFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIGFuIGludmFsaWQgY29udGVudCBsZW5ndGguXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgSU5WQUxJRF9DT05URU5UX0xFTkdUSDogMTI4LFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIGEgZmlsZSB0aGF0IHdhcyB0b28gbGFyZ2UuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgRklMRV9UT09fTEFSR0U6IDEyOSxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyBhbiBlcnJvciBzYXZpbmcgYSBmaWxlLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIEZJTEVfU0FWRV9FUlJPUjogMTMwLFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIGFuIGVycm9yIGRlbGV0aW5nIGEgZmlsZS5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBGSUxFX0RFTEVURV9FUlJPUjogMTUzLFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoYXQgYSB1bmlxdWUgZmllbGQgd2FzIGdpdmVuIGEgdmFsdWUgdGhhdCBpc1xuICAgICAqIGFscmVhZHkgdGFrZW4uXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgRFVQTElDQVRFX1ZBTFVFOiAxMzcsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIHJvbGUncyBuYW1lIGlzIGludmFsaWQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgSU5WQUxJRF9ST0xFX05BTUU6IDEzOSxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IGFuIGFwcGxpY2F0aW9uIHF1b3RhIHdhcyBleGNlZWRlZC4gIFVwZ3JhZGUgdG9cbiAgICAgKiByZXNvbHZlLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIEVYQ0VFREVEX1FVT1RBOiAxNDAsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIENsb3VkIENvZGUgc2NyaXB0IGZhaWxlZC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBTQ1JJUFRfRkFJTEVEOiAxNDEsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIENsb3VkIENvZGUgdmFsaWRhdGlvbiBmYWlsZWQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgVkFMSURBVElPTl9FUlJPUjogMTQyLFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoYXQgaW52YWxpZCBpbWFnZSBkYXRhIHdhcyBwcm92aWRlZC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBJTlZBTElEX0lNQUdFX0RBVEE6IDE1MCxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyBhbiB1bnNhdmVkIGZpbGUuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgVU5TQVZFRF9GSUxFX0VSUk9SOiAxNTEsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgYW4gaW52YWxpZCBwdXNoIHRpbWUuXG4gICAgICovXG4gICAgSU5WQUxJRF9QVVNIX1RJTUVfRVJST1I6IDE1MixcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IHRoZSB1c2VybmFtZSBpcyBtaXNzaW5nIG9yIGVtcHR5LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIFVTRVJOQU1FX01JU1NJTkc6IDIwMCxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IHRoZSBwYXNzd29yZCBpcyBtaXNzaW5nIG9yIGVtcHR5LlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIFBBU1NXT1JEX01JU1NJTkc6IDIwMSxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IHRoZSB1c2VybmFtZSBoYXMgYWxyZWFkeSBiZWVuIHRha2VuLlxuICAgICAqIEBjb25zdGFudFxuICAgICAqL1xuICAgIFVTRVJOQU1FX1RBS0VOOiAyMDIsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCB0aGUgZW1haWwgaGFzIGFscmVhZHkgYmVlbiB0YWtlbi5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBFTUFJTF9UQUtFTjogMjAzLFxuXG4gICAgLyoqXG4gICAgICogRXJyb3IgY29kZSBpbmRpY2F0aW5nIHRoYXQgdGhlIGVtYWlsIGlzIG1pc3NpbmcsIGJ1dCBtdXN0IGJlIHNwZWNpZmllZC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBFTUFJTF9NSVNTSU5HOiAyMDQsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIHVzZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGVtYWlsIHdhcyBub3QgZm91bmQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgRU1BSUxfTk9UX0ZPVU5EOiAyMDUsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIHVzZXIgb2JqZWN0IHdpdGhvdXQgYSB2YWxpZCBzZXNzaW9uIGNvdWxkXG4gICAgICogbm90IGJlIGFsdGVyZWQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgU0VTU0lPTl9NSVNTSU5HOiAyMDYsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIHVzZXIgY2FuIG9ubHkgYmUgY3JlYXRlZCB0aHJvdWdoIHNpZ251cC5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBNVVNUX0NSRUFURV9VU0VSX1RIUk9VR0hfU0lHTlVQOiAyMDcsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhbiBhbiBhY2NvdW50IGJlaW5nIGxpbmtlZCBpcyBhbHJlYWR5IGxpbmtlZFxuICAgICAqIHRvIGFub3RoZXIgdXNlci5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBBQ0NPVU5UX0FMUkVBRFlfTElOS0VEOiAyMDgsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIHVzZXIgY2Fubm90IGJlIGxpbmtlZCB0byBhbiBhY2NvdW50IGJlY2F1c2VcbiAgICAgKiB0aGF0IGFjY291bnQncyBpZCBjb3VsZCBub3QgYmUgZm91bmQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgTElOS0VEX0lEX01JU1NJTkc6IDI1MCxcblxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyB0aGF0IGEgdXNlciB3aXRoIGEgbGlua2VkIChlLmcuIEZhY2Vib29rKSBhY2NvdW50XG4gICAgICogaGFzIGFuIGludmFsaWQgc2Vzc2lvbi5cbiAgICAgKiBAY29uc3RhbnRcbiAgICAgKi9cbiAgICBJTlZBTElEX0xJTktFRF9TRVNTSU9OOiAyNTEsXG5cbiAgICAvKipcbiAgICAgKiBFcnJvciBjb2RlIGluZGljYXRpbmcgdGhhdCBhIHNlcnZpY2UgYmVpbmcgbGlua2VkIChlLmcuIEZhY2Vib29rIG9yXG4gICAgICogVHdpdHRlcikgaXMgdW5zdXBwb3J0ZWQuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgVU5TVVBQT1JURURfU0VSVklDRTogMjUyLFxuICAgIC8qKlxuICAgICAqIEVycm9yIGNvZGUgaW5kaWNhdGluZyBhIHJlYWwgZXJyb3IgY29kZSBpcyB1bmF2YWlsYWJsZSBiZWNhdXNlXG4gICAgICogd2UgaGFkIHRvIHVzZSBhbiBYRG9tYWluUmVxdWVzdCBvYmplY3QgdG8gYWxsb3cgQ09SUyByZXF1ZXN0cyBpblxuICAgICAqIEludGVybmV0IEV4cGxvcmVyLCB3aGljaCBzdHJpcHMgdGhlIGJvZHkgZnJvbSBIVFRQIHJlc3BvbnNlcyB0aGF0IGhhdmVcbiAgICAgKiBhIG5vbi0yWFggc3RhdHVzIGNvZGUuXG4gICAgICogQGNvbnN0YW50XG4gICAgICovXG4gICAgWF9ET01BSU5fUkVRVUVTVDogNjAyXG4gIH0pO1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9lcnJvci5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qZ2xvYmFsIF86IGZhbHNlICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEFWKSB7XG4gIHZhciBldmVudFNwbGl0dGVyID0gL1xccysvO1xuICB2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKiA8cD5BVi5FdmVudHMgaXMgYSBmb3JrIG9mIEJhY2tib25lJ3MgRXZlbnRzIG1vZHVsZSwgcHJvdmlkZWQgZm9yIHlvdXJcbiAgICogY29udmVuaWVuY2UuPC9wPlxuICAgKlxuICAgKiA8cD5BIG1vZHVsZSB0aGF0IGNhbiBiZSBtaXhlZCBpbiB0byBhbnkgb2JqZWN0IGluIG9yZGVyIHRvIHByb3ZpZGVcbiAgICogaXQgd2l0aCBjdXN0b20gZXZlbnRzLiBZb3UgbWF5IGJpbmQgY2FsbGJhY2sgZnVuY3Rpb25zIHRvIGFuIGV2ZW50XG4gICAqIHdpdGggYG9uYCwgb3IgcmVtb3ZlIHRoZXNlIGZ1bmN0aW9ucyB3aXRoIGBvZmZgLlxuICAgKiBUcmlnZ2VyaW5nIGFuIGV2ZW50IGZpcmVzIGFsbCBjYWxsYmFja3MgaW4gdGhlIG9yZGVyIHRoYXQgYG9uYCB3YXNcbiAgICogY2FsbGVkLlxuICAgKlxuICAgKiA8cHJlPlxuICAgKiAgICAgdmFyIG9iamVjdCA9IHt9O1xuICAgKiAgICAgXy5leHRlbmQob2JqZWN0LCBBVi5FdmVudHMpO1xuICAgKiAgICAgb2JqZWN0Lm9uKCdleHBhbmQnLCBmdW5jdGlvbigpeyBhbGVydCgnZXhwYW5kZWQnKTsgfSk7XG4gICAqICAgICBvYmplY3QudHJpZ2dlcignZXhwYW5kJyk7PC9wcmU+PC9wPlxuICAgKlxuICAgKiA8cD5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZVxuICAgKiA8YSBocmVmPVwiaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS9iYWNrYm9uZS8jRXZlbnRzXCI+QmFja2JvbmVcbiAgICogZG9jdW1lbnRhdGlvbjwvYT4uPC9wPlxuICAgKi9cbiAgQVYuRXZlbnRzID0ge1xuICAgIC8qKlxuICAgICAqIEJpbmQgb25lIG9yIG1vcmUgc3BhY2Ugc2VwYXJhdGVkIGV2ZW50cywgYGV2ZW50c2AsIHRvIGEgYGNhbGxiYWNrYFxuICAgICAqIGZ1bmN0aW9uLiBQYXNzaW5nIGBcImFsbFwiYCB3aWxsIGJpbmQgdGhlIGNhbGxiYWNrIHRvIGFsbCBldmVudHMgZmlyZWQuXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKGV2ZW50cywgY2FsbGJhY2ssIGNvbnRleHQpIHtcblxuICAgICAgdmFyIGNhbGxzLCBldmVudCwgbm9kZSwgdGFpbCwgbGlzdDtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBldmVudHMgPSBldmVudHMuc3BsaXQoZXZlbnRTcGxpdHRlcik7XG4gICAgICBjYWxscyA9IHRoaXMuX2NhbGxiYWNrcyB8fCAodGhpcy5fY2FsbGJhY2tzID0ge30pO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gaW1tdXRhYmxlIGNhbGxiYWNrIGxpc3QsIGFsbG93aW5nIHRyYXZlcnNhbCBkdXJpbmdcbiAgICAgIC8vIG1vZGlmaWNhdGlvbi4gIFRoZSB0YWlsIGlzIGFuIGVtcHR5IG9iamVjdCB0aGF0IHdpbGwgYWx3YXlzIGJlIHVzZWRcbiAgICAgIC8vIGFzIHRoZSBuZXh0IG5vZGUuXG4gICAgICBldmVudCA9IGV2ZW50cy5zaGlmdCgpO1xuICAgICAgd2hpbGUgKGV2ZW50KSB7XG4gICAgICAgIGxpc3QgPSBjYWxsc1tldmVudF07XG4gICAgICAgIG5vZGUgPSBsaXN0ID8gbGlzdC50YWlsIDoge307XG4gICAgICAgIG5vZGUubmV4dCA9IHRhaWwgPSB7fTtcbiAgICAgICAgbm9kZS5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgbm9kZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICBjYWxsc1tldmVudF0gPSB7dGFpbDogdGFpbCwgbmV4dDogbGlzdCA/IGxpc3QubmV4dCA6IG5vZGV9O1xuICAgICAgICBldmVudCA9IGV2ZW50cy5zaGlmdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIG9uZSBvciBtYW55IGNhbGxiYWNrcy4gSWYgYGNvbnRleHRgIGlzIG51bGwsIHJlbW92ZXMgYWxsIGNhbGxiYWNrc1xuICAgICAqIHdpdGggdGhhdCBmdW5jdGlvbi4gSWYgYGNhbGxiYWNrYCBpcyBudWxsLCByZW1vdmVzIGFsbCBjYWxsYmFja3MgZm9yIHRoZVxuICAgICAqIGV2ZW50LiBJZiBgZXZlbnRzYCBpcyBudWxsLCByZW1vdmVzIGFsbCBib3VuZCBjYWxsYmFja3MgZm9yIGFsbCBldmVudHMuXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihldmVudHMsIGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZXZlbnQsIGNhbGxzLCBub2RlLCB0YWlsLCBjYiwgY3R4O1xuXG4gICAgICAvLyBObyBldmVudHMsIG9yIHJlbW92aW5nICphbGwqIGV2ZW50cy5cbiAgICAgIGlmICghKGNhbGxzID0gdGhpcy5fY2FsbGJhY2tzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIShldmVudHMgfHwgY2FsbGJhY2sgfHwgY29udGV4dCkpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrcztcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgbGlzdGVkIGV2ZW50cyBhbmQgY29udGV4dHMsIHNwbGljaW5nIHRoZW0gb3V0IG9mIHRoZVxuICAgICAgLy8gbGlua2VkIGxpc3Qgb2YgY2FsbGJhY2tzIGlmIGFwcHJvcHJpYXRlLlxuICAgICAgZXZlbnRzID0gZXZlbnRzID8gZXZlbnRzLnNwbGl0KGV2ZW50U3BsaXR0ZXIpIDogXy5rZXlzKGNhbGxzKTtcbiAgICAgIGV2ZW50ID0gZXZlbnRzLnNoaWZ0KCk7XG4gICAgICB3aGlsZSAoZXZlbnQpIHtcbiAgICAgICAgbm9kZSA9IGNhbGxzW2V2ZW50XTtcbiAgICAgICAgZGVsZXRlIGNhbGxzW2V2ZW50XTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICEoY2FsbGJhY2sgfHwgY29udGV4dCkpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgbGlzdCwgb21pdHRpbmcgdGhlIGluZGljYXRlZCBjYWxsYmFja3MuXG4gICAgICAgIHRhaWwgPSBub2RlLnRhaWw7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIHdoaWxlIChub2RlICE9PSB0YWlsKSB7XG4gICAgICAgICAgY2IgPSBub2RlLmNhbGxiYWNrO1xuICAgICAgICAgIGN0eCA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICBpZiAoKGNhbGxiYWNrICYmIGNiICE9PSBjYWxsYmFjaykgfHwgKGNvbnRleHQgJiYgY3R4ICE9PSBjb250ZXh0KSkge1xuICAgICAgICAgICAgdGhpcy5vbihldmVudCwgY2IsIGN0eCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUgPSBub2RlLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQgPSBldmVudHMuc2hpZnQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFRyaWdnZXIgb25lIG9yIG1hbnkgZXZlbnRzLCBmaXJpbmcgYWxsIGJvdW5kIGNhbGxiYWNrcy4gQ2FsbGJhY2tzIGFyZVxuICAgICAqIHBhc3NlZCB0aGUgc2FtZSBhcmd1bWVudHMgYXMgYHRyaWdnZXJgIGlzLCBhcGFydCBmcm9tIHRoZSBldmVudCBuYW1lXG4gICAgICogKHVubGVzcyB5b3UncmUgbGlzdGVuaW5nIG9uIGBcImFsbFwiYCwgd2hpY2ggd2lsbCBjYXVzZSB5b3VyIGNhbGxiYWNrIHRvXG4gICAgICogcmVjZWl2ZSB0aGUgdHJ1ZSBuYW1lIG9mIHRoZSBldmVudCBhcyB0aGUgZmlyc3QgYXJndW1lbnQpLlxuICAgICAqL1xuICAgIHRyaWdnZXI6IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgICAgdmFyIGV2ZW50LCBub2RlLCBjYWxscywgdGFpbCwgYXJncywgYWxsLCByZXN0O1xuICAgICAgaWYgKCEoY2FsbHMgPSB0aGlzLl9jYWxsYmFja3MpKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgYWxsID0gY2FsbHMuYWxsO1xuICAgICAgZXZlbnRzID0gZXZlbnRzLnNwbGl0KGV2ZW50U3BsaXR0ZXIpO1xuICAgICAgcmVzdCA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblxuICAgICAgLy8gRm9yIGVhY2ggZXZlbnQsIHdhbGsgdGhyb3VnaCB0aGUgbGlua2VkIGxpc3Qgb2YgY2FsbGJhY2tzIHR3aWNlLFxuICAgICAgLy8gZmlyc3QgdG8gdHJpZ2dlciB0aGUgZXZlbnQsIHRoZW4gdG8gdHJpZ2dlciBhbnkgYFwiYWxsXCJgIGNhbGxiYWNrcy5cbiAgICAgIGV2ZW50ID0gZXZlbnRzLnNoaWZ0KCk7XG4gICAgICB3aGlsZSAoZXZlbnQpIHtcbiAgICAgICAgbm9kZSA9IGNhbGxzW2V2ZW50XTtcbiAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICB0YWlsID0gbm9kZS50YWlsO1xuICAgICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUubmV4dCkgIT09IHRhaWwpIHtcbiAgICAgICAgICAgIG5vZGUuY2FsbGJhY2suYXBwbHkobm9kZS5jb250ZXh0IHx8IHRoaXMsIHJlc3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBub2RlID0gYWxsO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgIHRhaWwgPSBub2RlLnRhaWw7XG4gICAgICAgICAgYXJncyA9IFtldmVudF0uY29uY2F0KHJlc3QpO1xuICAgICAgICAgIHdoaWxlICgobm9kZSA9IG5vZGUubmV4dCkgIT09IHRhaWwpIHtcbiAgICAgICAgICAgIG5vZGUuY2FsbGJhY2suYXBwbHkobm9kZS5jb250ZXh0IHx8IHRoaXMsIGFyZ3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBldmVudCA9IGV2ZW50cy5zaGlmdCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgQVYuRXZlbnRzLmJpbmQgPSBBVi5FdmVudHMub247XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKi9cbiAgQVYuRXZlbnRzLnVuYmluZCA9IEFWLkV2ZW50cy5vZmY7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9ldmVudC5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbi8qZ2xvYmFsIEZCOiBmYWxzZSAsIGNvbnNvbGU6IGZhbHNlKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQVYpIHtcbiAgdmFyIFBVQkxJQ19LRVkgPSBcIipcIjtcblxuICB2YXIgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgdmFyIHJlcXVlc3RlZFBlcm1pc3Npb25zO1xuICB2YXIgaW5pdE9wdGlvbnM7XG4gIHZhciBwcm92aWRlciA9IHtcbiAgICBhdXRoZW50aWNhdGU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIEZCLmxvZ2luKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChyZXNwb25zZS5hdXRoUmVzcG9uc2UpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5zdWNjZXNzKSB7XG4gICAgICAgICAgICBvcHRpb25zLnN1Y2Nlc3Moc2VsZiwge1xuICAgICAgICAgICAgICBpZDogcmVzcG9uc2UuYXV0aFJlc3BvbnNlLnVzZXJJRCxcbiAgICAgICAgICAgICAgYWNjZXNzX3Rva2VuOiByZXNwb25zZS5hdXRoUmVzcG9uc2UuYWNjZXNzVG9rZW4sXG4gICAgICAgICAgICAgIGV4cGlyYXRpb25fZGF0ZTogbmV3IERhdGUocmVzcG9uc2UuYXV0aFJlc3BvbnNlLmV4cGlyZXNJbiAqIDEwMDAgK1xuICAgICAgICAgICAgICAgICAgKG5ldyBEYXRlKCkpLmdldFRpbWUoKSkudG9KU09OKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5lcnJvcikge1xuICAgICAgICAgICAgb3B0aW9ucy5lcnJvcihzZWxmLCByZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LCB7XG4gICAgICAgIHNjb3BlOiByZXF1ZXN0ZWRQZXJtaXNzaW9uc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICByZXN0b3JlQXV0aGVudGljYXRpb246IGZ1bmN0aW9uKGF1dGhEYXRhKSB7XG4gICAgICBpZiAoYXV0aERhdGEpIHtcbiAgICAgICAgdmFyIGF1dGhSZXNwb25zZSA9IHtcbiAgICAgICAgICB1c2VySUQ6IGF1dGhEYXRhLmlkLFxuICAgICAgICAgIGFjY2Vzc1Rva2VuOiBhdXRoRGF0YS5hY2Nlc3NfdG9rZW4sXG4gICAgICAgICAgZXhwaXJlc0luOiAoQVYuX3BhcnNlRGF0ZShhdXRoRGF0YS5leHBpcmF0aW9uX2RhdGUpLmdldFRpbWUoKSAtXG4gICAgICAgICAgICAgIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCkpIC8gMTAwMFxuICAgICAgICB9O1xuICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IF8uY2xvbmUoaW5pdE9wdGlvbnMpO1xuICAgICAgICBuZXdPcHRpb25zLmF1dGhSZXNwb25zZSA9IGF1dGhSZXNwb25zZTtcblxuICAgICAgICAvLyBTdXBwcmVzcyBjaGVja3MgZm9yIGxvZ2luIHN0YXR1cyBmcm9tIHRoZSBicm93c2VyLlxuICAgICAgICBuZXdPcHRpb25zLnN0YXR1cyA9IGZhbHNlO1xuICAgICAgICBGQi5pbml0KG5ld09wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcbiAgICBnZXRBdXRoVHlwZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJmYWNlYm9va1wiO1xuICAgIH0sXG4gICAgZGVhdXRoZW50aWNhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5yZXN0b3JlQXV0aGVudGljYXRpb24obnVsbCk7XG4gICAgICBGQi5sb2dvdXQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgc2V0IG9mIHV0aWxpdGllcyBmb3IgdXNpbmcgQVYgd2l0aCBGYWNlYm9vay5cbiAgICogQG5hbWVzcGFjZVxuICAgKiBQcm92aWRlcyBhIHNldCBvZiB1dGlsaXRpZXMgZm9yIHVzaW5nIEFWIHdpdGggRmFjZWJvb2suXG4gICAqL1xuICBBVi5GYWNlYm9va1V0aWxzID0ge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIEFWIEZhY2Vib29rIGludGVncmF0aW9uLiAgQ2FsbCB0aGlzIGZ1bmN0aW9uIGFmdGVyIHlvdVxuICAgICAqIGhhdmUgbG9hZGVkIHRoZSBGYWNlYm9vayBKYXZhc2NyaXB0IFNESyB3aXRoIHRoZSBzYW1lIHBhcmFtZXRlcnNcbiAgICAgKiBhcyB5b3Ugd291bGQgcGFzcyB0bzxjb2RlPlxuICAgICAqIDxhIGhyZWY9XG4gICAgICogXCJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tL2RvY3MvcmVmZXJlbmNlL2phdmFzY3JpcHQvRkIuaW5pdC9cIj5cbiAgICAgKiBGQi5pbml0KCk8L2E+PC9jb2RlPi4gIEFWLkZhY2Vib29rVXRpbHMgd2lsbCBpbnZva2UgRkIuaW5pdCgpIGZvciB5b3VcbiAgICAgKiB3aXRoIHRoZXNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEZhY2Vib29rIG9wdGlvbnMgYXJndW1lbnQgYXMgZGVzY3JpYmVkIGhlcmU6XG4gICAgICogICA8YSBocmVmPVxuICAgICAqICAgXCJodHRwczovL2RldmVsb3BlcnMuZmFjZWJvb2suY29tL2RvY3MvcmVmZXJlbmNlL2phdmFzY3JpcHQvRkIuaW5pdC9cIj5cbiAgICAgKiAgIEZCLmluaXQoKTwvYT4uIFRoZSBzdGF0dXMgZmxhZyB3aWxsIGJlIGNvZXJjZWQgdG8gJ2ZhbHNlJyBiZWNhdXNlIGl0XG4gICAgICogICBpbnRlcmZlcmVzIHdpdGggQVYgRmFjZWJvb2sgaW50ZWdyYXRpb24uIENhbGwgRkIuZ2V0TG9naW5TdGF0dXMoKVxuICAgICAqICAgZXhwbGljaXRseSBpZiB0aGlzIGJlaGF2aW9yIGlzIHJlcXVpcmVkIGJ5IHlvdXIgYXBwbGljYXRpb24uXG4gICAgICovXG4gICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgY29uc29sZS53YXJuKFwiQVYuRmFjZWJvb2tVdGlscyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgZG9uJ3QgdXNlIGl0IGFueW1vcmUuXCIpO1xuICAgICAgaWYgKHR5cGVvZihGQikgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IFwiVGhlIEZhY2Vib29rIEphdmFTY3JpcHQgU0RLIG11c3QgYmUgbG9hZGVkIGJlZm9yZSBjYWxsaW5nIGluaXQuXCI7XG4gICAgICB9XG4gICAgICBpbml0T3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XG4gICAgICBpZiAoaW5pdE9wdGlvbnMuc3RhdHVzICYmIHR5cGVvZihjb25zb2xlKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB2YXIgd2FybiA9IGNvbnNvbGUud2FybiB8fCBjb25zb2xlLmxvZyB8fCBmdW5jdGlvbigpIHt9O1xuICAgICAgICB3YXJuLmNhbGwoY29uc29sZSwgXCJUaGUgJ3N0YXR1cycgZmxhZyBwYXNzZWQgaW50b1wiICtcbiAgICAgICAgICBcIiBGQi5pbml0LCB3aGVuIHNldCB0byB0cnVlLCBjYW4gaW50ZXJmZXJlIHdpdGggQVYgRmFjZWJvb2tcIiArXG4gICAgICAgICAgXCIgaW50ZWdyYXRpb24sIHNvIGl0IGhhcyBiZWVuIHN1cHByZXNzZWQuIFBsZWFzZSBjYWxsXCIgK1xuICAgICAgICAgIFwiIEZCLmdldExvZ2luU3RhdHVzKCkgZXhwbGljaXRseSBpZiB5b3UgcmVxdWlyZSB0aGlzIGJlaGF2aW9yLlwiKTtcbiAgICAgIH1cbiAgICAgIGluaXRPcHRpb25zLnN0YXR1cyA9IGZhbHNlO1xuICAgICAgRkIuaW5pdChpbml0T3B0aW9ucyk7XG4gICAgICBBVi5Vc2VyLl9yZWdpc3RlckF1dGhlbnRpY2F0aW9uUHJvdmlkZXIocHJvdmlkZXIpO1xuICAgICAgaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHdoZXRoZXIgdGhlIHVzZXIgaGFzIHRoZWlyIGFjY291bnQgbGlua2VkIHRvIEZhY2Vib29rLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBVi5Vc2VyfSB1c2VyIFVzZXIgdG8gY2hlY2sgZm9yIGEgZmFjZWJvb2sgbGluay5cbiAgICAgKiAgICAgVGhlIHVzZXIgbXVzdCBiZSBsb2dnZWQgaW4gb24gdGhpcyBkZXZpY2UuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIHVzZXIgaGFzIHRoZWlyIGFjY291bnRcbiAgICAgKiAgICAgbGlua2VkIHRvIEZhY2Vib29rLlxuICAgICAqL1xuICAgIGlzTGlua2VkOiBmdW5jdGlvbih1c2VyKSB7XG4gICAgICByZXR1cm4gdXNlci5faXNMaW5rZWQoXCJmYWNlYm9va1wiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9ncyBpbiBhIHVzZXIgdXNpbmcgRmFjZWJvb2suIFRoaXMgbWV0aG9kIGRlbGVnYXRlcyB0byB0aGUgRmFjZWJvb2tcbiAgICAgKiBTREsgdG8gYXV0aGVudGljYXRlIHRoZSB1c2VyLCBhbmQgdGhlbiBhdXRvbWF0aWNhbGx5IGxvZ3MgaW4gKG9yXG4gICAgICogY3JlYXRlcywgaW4gdGhlIGNhc2Ugd2hlcmUgaXQgaXMgYSBuZXcgdXNlcikgYSBBVi5Vc2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmcsIE9iamVjdH0gcGVybWlzc2lvbnMgVGhlIHBlcm1pc3Npb25zIHJlcXVpcmVkIGZvciBGYWNlYm9va1xuICAgICAqICAgIGxvZyBpbi4gIFRoaXMgaXMgYSBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nIG9mIHBlcm1pc3Npb25zLlxuICAgICAqICAgIEFsdGVybmF0aXZlbHksIHN1cHBseSBhIEZhY2Vib29rIGF1dGhEYXRhIG9iamVjdCBhcyBkZXNjcmliZWQgaW4gb3VyXG4gICAgICogICAgUkVTVCBBUEkgZG9jcyBpZiB5b3Ugd2FudCB0byBoYW5kbGUgZ2V0dGluZyBmYWNlYm9vayBhdXRoIHRva2Vuc1xuICAgICAqICAgIHlvdXJzZWxmLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFN0YW5kYXJkIG9wdGlvbnMgb2JqZWN0IHdpdGggc3VjY2VzcyBhbmQgZXJyb3JcbiAgICAgKiAgICBjYWxsYmFja3MuXG4gICAgICovXG4gICAgbG9nSW46IGZ1bmN0aW9uKHBlcm1pc3Npb25zLCBvcHRpb25zKSB7XG4gICAgICBpZiAoIXBlcm1pc3Npb25zIHx8IF8uaXNTdHJpbmcocGVybWlzc2lvbnMpKSB7XG4gICAgICAgIGlmICghaW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICB0aHJvdyBcIllvdSBtdXN0IGluaXRpYWxpemUgRmFjZWJvb2tVdGlscyBiZWZvcmUgY2FsbGluZyBsb2dJbi5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0ZWRQZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zO1xuICAgICAgICByZXR1cm4gQVYuVXNlci5fbG9nSW5XaXRoKFwiZmFjZWJvb2tcIiwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbmV3T3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XG4gICAgICAgIG5ld09wdGlvbnMuYXV0aERhdGEgPSBwZXJtaXNzaW9ucztcbiAgICAgICAgcmV0dXJuIEFWLlVzZXIuX2xvZ0luV2l0aChcImZhY2Vib29rXCIsIG5ld09wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMaW5rcyBGYWNlYm9vayB0byBhbiBleGlzdGluZyBQRlVzZXIuIFRoaXMgbWV0aG9kIGRlbGVnYXRlcyB0byB0aGVcbiAgICAgKiBGYWNlYm9vayBTREsgdG8gYXV0aGVudGljYXRlIHRoZSB1c2VyLCBhbmQgdGhlbiBhdXRvbWF0aWNhbGx5IGxpbmtzXG4gICAgICogdGhlIGFjY291bnQgdG8gdGhlIEFWLlVzZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FWLlVzZXJ9IHVzZXIgVXNlciB0byBsaW5rIHRvIEZhY2Vib29rLiBUaGlzIG11c3QgYmUgdGhlXG4gICAgICogICAgIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcGFyYW0ge1N0cmluZywgT2JqZWN0fSBwZXJtaXNzaW9ucyBUaGUgcGVybWlzc2lvbnMgcmVxdWlyZWQgZm9yIEZhY2Vib29rXG4gICAgICogICAgbG9nIGluLiAgVGhpcyBpcyBhIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmcgb2YgcGVybWlzc2lvbnMuXG4gICAgICogICAgQWx0ZXJuYXRpdmVseSwgc3VwcGx5IGEgRmFjZWJvb2sgYXV0aERhdGEgb2JqZWN0IGFzIGRlc2NyaWJlZCBpbiBvdXJcbiAgICAgKiAgICBSRVNUIEFQSSBkb2NzIGlmIHlvdSB3YW50IHRvIGhhbmRsZSBnZXR0aW5nIGZhY2Vib29rIGF1dGggdG9rZW5zXG4gICAgICogICAgeW91cnNlbGYuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU3RhbmRhcmQgb3B0aW9ucyBvYmplY3Qgd2l0aCBzdWNjZXNzIGFuZCBlcnJvclxuICAgICAqICAgIGNhbGxiYWNrcy5cbiAgICAgKi9cbiAgICBsaW5rOiBmdW5jdGlvbih1c2VyLCBwZXJtaXNzaW9ucywgb3B0aW9ucykge1xuICAgICAgaWYgKCFwZXJtaXNzaW9ucyB8fCBfLmlzU3RyaW5nKHBlcm1pc3Npb25zKSkge1xuICAgICAgICBpZiAoIWluaXRpYWxpemVkKSB7XG4gICAgICAgICAgdGhyb3cgXCJZb3UgbXVzdCBpbml0aWFsaXplIEZhY2Vib29rVXRpbHMgYmVmb3JlIGNhbGxpbmcgbGluay5cIjtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0ZWRQZXJtaXNzaW9ucyA9IHBlcm1pc3Npb25zO1xuICAgICAgICByZXR1cm4gdXNlci5fbGlua1dpdGgoXCJmYWNlYm9va1wiLCBvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBuZXdPcHRpb25zID0gXy5jbG9uZShvcHRpb25zKSB8fCB7fTtcbiAgICAgICAgbmV3T3B0aW9ucy5hdXRoRGF0YSA9IHBlcm1pc3Npb25zO1xuICAgICAgICByZXR1cm4gdXNlci5fbGlua1dpdGgoXCJmYWNlYm9va1wiLCBuZXdPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVW5saW5rcyB0aGUgQVYuVXNlciBmcm9tIGEgRmFjZWJvb2sgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QVYuVXNlcn0gdXNlciBVc2VyIHRvIHVubGluayBmcm9tIEZhY2Vib29rLiBUaGlzIG11c3QgYmUgdGhlXG4gICAgICogICAgIGN1cnJlbnQgdXNlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTdGFuZGFyZCBvcHRpb25zIG9iamVjdCB3aXRoIHN1Y2Nlc3MgYW5kIGVycm9yXG4gICAgICogICAgY2FsbGJhY2tzLlxuICAgICAqL1xuICAgIHVubGluazogZnVuY3Rpb24odXNlciwgb3B0aW9ucykge1xuICAgICAgaWYgKCFpbml0aWFsaXplZCkge1xuICAgICAgICB0aHJvdyBcIllvdSBtdXN0IGluaXRpYWxpemUgRmFjZWJvb2tVdGlscyBiZWZvcmUgY2FsbGluZyB1bmxpbmsuXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXNlci5fdW5saW5rRnJvbShcImZhY2Vib29rXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJvTWZwQW5cIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvZmFjZWJvb2suanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG4vLyBwb3J0IGZyb20gYnJvd3NlcmlmeSBwYXRoIG1vZHVsZVxuLy8gc2luY2UgcmVhY3QtbmF0aXZlIHBhY2thZ2VyIHdvbid0IHNoaW0gbm9kZSBtb2R1bGVzLlxuZnVuY3Rpb24gZXh0bmFtZShwYXRoKSB7XG4gIHJldHVybiBwYXRoLm1hdGNoKC9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvKVs0XTtcbn1cblxuLypqc2hpbnQgYml0d2lzZTpmYWxzZSAqLy8qZ2xvYmFsIEZpbGVSZWFkZXI6IHRydWUsIEZpbGU6IHRydWUgKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQVYpIHtcbiAgdmFyIGI2NERpZ2l0ID0gZnVuY3Rpb24obnVtYmVyKSB7XG4gICAgaWYgKG51bWJlciA8IDI2KSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg2NSArIG51bWJlcik7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCA1Mikge1xuICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoOTcgKyAobnVtYmVyIC0gMjYpKTtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDYyKSB7XG4gICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSg0OCArIChudW1iZXIgLSA1MikpO1xuICAgIH1cbiAgICBpZiAobnVtYmVyID09PSA2Mikge1xuICAgICAgcmV0dXJuIFwiK1wiO1xuICAgIH1cbiAgICBpZiAobnVtYmVyID09PSA2Mykge1xuICAgICAgcmV0dXJuIFwiL1wiO1xuICAgIH1cbiAgICB0aHJvdyBcIlRyaWVkIHRvIGVuY29kZSBsYXJnZSBkaWdpdCBcIiArIG51bWJlciArIFwiIGluIGJhc2U2NC5cIjtcbiAgfTtcblxuICB2YXIgZW5jb2RlQmFzZTY0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgY2h1bmtzID0gW107XG4gICAgY2h1bmtzLmxlbmd0aCA9IE1hdGguY2VpbChhcnJheS5sZW5ndGggLyAzKTtcbiAgICBfLnRpbWVzKGNodW5rcy5sZW5ndGgsIGZ1bmN0aW9uKGkpIHtcbiAgICAgIHZhciBiMSA9IGFycmF5W2kgKiAzXTtcbiAgICAgIHZhciBiMiA9IGFycmF5W2kgKiAzICsgMV0gfHwgMDtcbiAgICAgIHZhciBiMyA9IGFycmF5W2kgKiAzICsgMl0gfHwgMDtcblxuICAgICAgdmFyIGhhczIgPSAoaSAqIDMgKyAxKSA8IGFycmF5Lmxlbmd0aDtcbiAgICAgIHZhciBoYXMzID0gKGkgKiAzICsgMikgPCBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGNodW5rc1tpXSA9IFtcbiAgICAgICAgYjY0RGlnaXQoKGIxID4+IDIpICYgMHgzRiksXG4gICAgICAgIGI2NERpZ2l0KCgoYjEgPDwgNCkgJiAweDMwKSB8ICgoYjIgPj4gNCkgJiAweDBGKSksXG4gICAgICAgIGhhczIgPyBiNjREaWdpdCgoKGIyIDw8IDIpICYgMHgzQykgfCAoKGIzID4+IDYpICYgMHgwMykpIDogXCI9XCIsXG4gICAgICAgIGhhczMgPyBiNjREaWdpdChiMyAmIDB4M0YpIDogXCI9XCJcbiAgICAgIF0uam9pbihcIlwiKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2h1bmtzLmpvaW4oXCJcIik7XG4gIH07XG5cbiAgLy8gQSBsaXN0IG9mIGZpbGUgZXh0ZW5zaW9ucyB0byBtaW1lIHR5cGVzIGFzIGZvdW5kIGhlcmU6XG4gIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTg1MTAvdXNpbmctbmV0LWhvdy1jYW4teW91LWZpbmQtdGhlLVxuICAvLyAgICAgbWltZS10eXBlLW9mLWEtZmlsZS1iYXNlZC1vbi10aGUtZmlsZS1zaWduYXR1cmVcbiAgdmFyIG1pbWVUeXBlcyA9IHtcbiAgICBhaTogXCJhcHBsaWNhdGlvbi9wb3N0c2NyaXB0XCIsXG4gICAgYWlmOiBcImF1ZGlvL3gtYWlmZlwiLFxuICAgIGFpZmM6IFwiYXVkaW8veC1haWZmXCIsXG4gICAgYWlmZjogXCJhdWRpby94LWFpZmZcIixcbiAgICBhc2M6IFwidGV4dC9wbGFpblwiLFxuICAgIGF0b206IFwiYXBwbGljYXRpb24vYXRvbSt4bWxcIixcbiAgICBhdTogXCJhdWRpby9iYXNpY1wiLFxuICAgIGF2aTogXCJ2aWRlby94LW1zdmlkZW9cIixcbiAgICBiY3BpbzogXCJhcHBsaWNhdGlvbi94LWJjcGlvXCIsXG4gICAgYmluOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICAgIGJtcDogXCJpbWFnZS9ibXBcIixcbiAgICBjZGY6IFwiYXBwbGljYXRpb24veC1uZXRjZGZcIixcbiAgICBjZ206IFwiaW1hZ2UvY2dtXCIsXG4gICAgXCJjbGFzc1wiOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICAgIGNwaW86IFwiYXBwbGljYXRpb24veC1jcGlvXCIsXG4gICAgY3B0OiBcImFwcGxpY2F0aW9uL21hYy1jb21wYWN0cHJvXCIsXG4gICAgY3NoOiBcImFwcGxpY2F0aW9uL3gtY3NoXCIsXG4gICAgY3NzOiBcInRleHQvY3NzXCIsXG4gICAgZGNyOiBcImFwcGxpY2F0aW9uL3gtZGlyZWN0b3JcIixcbiAgICBkaWY6IFwidmlkZW8veC1kdlwiLFxuICAgIGRpcjogXCJhcHBsaWNhdGlvbi94LWRpcmVjdG9yXCIsXG4gICAgZGp2OiBcImltYWdlL3ZuZC5kanZ1XCIsXG4gICAgZGp2dTogXCJpbWFnZS92bmQuZGp2dVwiLFxuICAgIGRsbDogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIixcbiAgICBkbWc6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gICAgZG1zOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICAgIGRvYzogXCJhcHBsaWNhdGlvbi9tc3dvcmRcIixcbiAgICBkb2N4OiBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC53b3JkcHJvY2Vzc2luZ21sLlwiICtcbiAgICAgICAgICBcImRvY3VtZW50XCIsXG4gICAgZG90eDogXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQud29yZHByb2Nlc3NpbmdtbC5cIiArXG4gICAgICAgICAgXCJ0ZW1wbGF0ZVwiLFxuICAgIGRvY206IFwiYXBwbGljYXRpb24vdm5kLm1zLXdvcmQuZG9jdW1lbnQubWFjcm9FbmFibGVkLjEyXCIsXG4gICAgZG90bTogXCJhcHBsaWNhdGlvbi92bmQubXMtd29yZC50ZW1wbGF0ZS5tYWNyb0VuYWJsZWQuMTJcIixcbiAgICBkdGQ6IFwiYXBwbGljYXRpb24veG1sLWR0ZFwiLFxuICAgIGR2OiBcInZpZGVvL3gtZHZcIixcbiAgICBkdmk6IFwiYXBwbGljYXRpb24veC1kdmlcIixcbiAgICBkeHI6IFwiYXBwbGljYXRpb24veC1kaXJlY3RvclwiLFxuICAgIGVwczogXCJhcHBsaWNhdGlvbi9wb3N0c2NyaXB0XCIsXG4gICAgZXR4OiBcInRleHQveC1zZXRleHRcIixcbiAgICBleGU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gICAgZXo6IFwiYXBwbGljYXRpb24vYW5kcmV3LWluc2V0XCIsXG4gICAgZ2lmOiBcImltYWdlL2dpZlwiLFxuICAgIGdyYW06IFwiYXBwbGljYXRpb24vc3Jnc1wiLFxuICAgIGdyeG1sOiBcImFwcGxpY2F0aW9uL3NyZ3MreG1sXCIsXG4gICAgZ3RhcjogXCJhcHBsaWNhdGlvbi94LWd0YXJcIixcbiAgICBoZGY6IFwiYXBwbGljYXRpb24veC1oZGZcIixcbiAgICBocXg6IFwiYXBwbGljYXRpb24vbWFjLWJpbmhleDQwXCIsXG4gICAgaHRtOiBcInRleHQvaHRtbFwiLFxuICAgIGh0bWw6IFwidGV4dC9odG1sXCIsXG4gICAgaWNlOiBcIngtY29uZmVyZW5jZS94LWNvb2x0YWxrXCIsXG4gICAgaWNvOiBcImltYWdlL3gtaWNvblwiLFxuICAgIGljczogXCJ0ZXh0L2NhbGVuZGFyXCIsXG4gICAgaWVmOiBcImltYWdlL2llZlwiLFxuICAgIGlmYjogXCJ0ZXh0L2NhbGVuZGFyXCIsXG4gICAgaWdlczogXCJtb2RlbC9pZ2VzXCIsXG4gICAgaWdzOiBcIm1vZGVsL2lnZXNcIixcbiAgICBqbmxwOiBcImFwcGxpY2F0aW9uL3gtamF2YS1qbmxwLWZpbGVcIixcbiAgICBqcDI6IFwiaW1hZ2UvanAyXCIsXG4gICAganBlOiBcImltYWdlL2pwZWdcIixcbiAgICBqcGVnOiBcImltYWdlL2pwZWdcIixcbiAgICBqcGc6IFwiaW1hZ2UvanBlZ1wiLFxuICAgIGpzOiBcImFwcGxpY2F0aW9uL3gtamF2YXNjcmlwdFwiLFxuICAgIGthcjogXCJhdWRpby9taWRpXCIsXG4gICAgbGF0ZXg6IFwiYXBwbGljYXRpb24veC1sYXRleFwiLFxuICAgIGxoYTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIixcbiAgICBsemg6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gICAgbTN1OiBcImF1ZGlvL3gtbXBlZ3VybFwiLFxuICAgIG00YTogXCJhdWRpby9tcDRhLWxhdG1cIixcbiAgICBtNGI6IFwiYXVkaW8vbXA0YS1sYXRtXCIsXG4gICAgbTRwOiBcImF1ZGlvL21wNGEtbGF0bVwiLFxuICAgIG00dTogXCJ2aWRlby92bmQubXBlZ3VybFwiLFxuICAgIG00djogXCJ2aWRlby94LW00dlwiLFxuICAgIG1hYzogXCJpbWFnZS94LW1hY3BhaW50XCIsXG4gICAgbWFuOiBcImFwcGxpY2F0aW9uL3gtdHJvZmYtbWFuXCIsXG4gICAgbWF0aG1sOiBcImFwcGxpY2F0aW9uL21hdGhtbCt4bWxcIixcbiAgICBtZTogXCJhcHBsaWNhdGlvbi94LXRyb2ZmLW1lXCIsXG4gICAgbWVzaDogXCJtb2RlbC9tZXNoXCIsXG4gICAgbWlkOiBcImF1ZGlvL21pZGlcIixcbiAgICBtaWRpOiBcImF1ZGlvL21pZGlcIixcbiAgICBtaWY6IFwiYXBwbGljYXRpb24vdm5kLm1pZlwiLFxuICAgIG1vdjogXCJ2aWRlby9xdWlja3RpbWVcIixcbiAgICBtb3ZpZTogXCJ2aWRlby94LXNnaS1tb3ZpZVwiLFxuICAgIG1wMjogXCJhdWRpby9tcGVnXCIsXG4gICAgbXAzOiBcImF1ZGlvL21wZWdcIixcbiAgICBtcDQ6IFwidmlkZW8vbXA0XCIsXG4gICAgbXBlOiBcInZpZGVvL21wZWdcIixcbiAgICBtcGVnOiBcInZpZGVvL21wZWdcIixcbiAgICBtcGc6IFwidmlkZW8vbXBlZ1wiLFxuICAgIG1wZ2E6IFwiYXVkaW8vbXBlZ1wiLFxuICAgIG1zOiBcImFwcGxpY2F0aW9uL3gtdHJvZmYtbXNcIixcbiAgICBtc2g6IFwibW9kZWwvbWVzaFwiLFxuICAgIG14dTogXCJ2aWRlby92bmQubXBlZ3VybFwiLFxuICAgIG5jOiBcImFwcGxpY2F0aW9uL3gtbmV0Y2RmXCIsXG4gICAgb2RhOiBcImFwcGxpY2F0aW9uL29kYVwiLFxuICAgIG9nZzogXCJhcHBsaWNhdGlvbi9vZ2dcIixcbiAgICBwYm06IFwiaW1hZ2UveC1wb3J0YWJsZS1iaXRtYXBcIixcbiAgICBwY3Q6IFwiaW1hZ2UvcGljdFwiLFxuICAgIHBkYjogXCJjaGVtaWNhbC94LXBkYlwiLFxuICAgIHBkZjogXCJhcHBsaWNhdGlvbi9wZGZcIixcbiAgICBwZ206IFwiaW1hZ2UveC1wb3J0YWJsZS1ncmF5bWFwXCIsXG4gICAgcGduOiBcImFwcGxpY2F0aW9uL3gtY2hlc3MtcGduXCIsXG4gICAgcGljOiBcImltYWdlL3BpY3RcIixcbiAgICBwaWN0OiBcImltYWdlL3BpY3RcIixcbiAgICBwbmc6IFwiaW1hZ2UvcG5nXCIsXG4gICAgcG5tOiBcImltYWdlL3gtcG9ydGFibGUtYW55bWFwXCIsXG4gICAgcG50OiBcImltYWdlL3gtbWFjcGFpbnRcIixcbiAgICBwbnRnOiBcImltYWdlL3gtbWFjcGFpbnRcIixcbiAgICBwcG06IFwiaW1hZ2UveC1wb3J0YWJsZS1waXhtYXBcIixcbiAgICBwcHQ6IFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnRcIixcbiAgICBwcHR4OiBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5cIiArXG4gICAgICAgICAgXCJwcmVzZW50YXRpb25cIixcbiAgICBwb3R4OiBcImFwcGxpY2F0aW9uL3ZuZC5vcGVueG1sZm9ybWF0cy1vZmZpY2Vkb2N1bWVudC5wcmVzZW50YXRpb25tbC5cIiArXG4gICAgICAgICAgXCJ0ZW1wbGF0ZVwiLFxuICAgIHBwc3g6IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnByZXNlbnRhdGlvbm1sLlwiICtcbiAgICAgICAgICBcInNsaWRlc2hvd1wiLFxuICAgIHBwYW06IFwiYXBwbGljYXRpb24vdm5kLm1zLXBvd2VycG9pbnQuYWRkaW4ubWFjcm9FbmFibGVkLjEyXCIsXG4gICAgcHB0bTogXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC5wcmVzZW50YXRpb24ubWFjcm9FbmFibGVkLjEyXCIsXG4gICAgcG90bTogXCJhcHBsaWNhdGlvbi92bmQubXMtcG93ZXJwb2ludC50ZW1wbGF0ZS5tYWNyb0VuYWJsZWQuMTJcIixcbiAgICBwcHNtOiBcImFwcGxpY2F0aW9uL3ZuZC5tcy1wb3dlcnBvaW50LnNsaWRlc2hvdy5tYWNyb0VuYWJsZWQuMTJcIixcbiAgICBwczogXCJhcHBsaWNhdGlvbi9wb3N0c2NyaXB0XCIsXG4gICAgcXQ6IFwidmlkZW8vcXVpY2t0aW1lXCIsXG4gICAgcXRpOiBcImltYWdlL3gtcXVpY2t0aW1lXCIsXG4gICAgcXRpZjogXCJpbWFnZS94LXF1aWNrdGltZVwiLFxuICAgIHJhOiBcImF1ZGlvL3gtcG4tcmVhbGF1ZGlvXCIsXG4gICAgcmFtOiBcImF1ZGlvL3gtcG4tcmVhbGF1ZGlvXCIsXG4gICAgcmFzOiBcImltYWdlL3gtY211LXJhc3RlclwiLFxuICAgIHJkZjogXCJhcHBsaWNhdGlvbi9yZGYreG1sXCIsXG4gICAgcmdiOiBcImltYWdlL3gtcmdiXCIsXG4gICAgcm06IFwiYXBwbGljYXRpb24vdm5kLnJuLXJlYWxtZWRpYVwiLFxuICAgIHJvZmY6IFwiYXBwbGljYXRpb24veC10cm9mZlwiLFxuICAgIHJ0ZjogXCJ0ZXh0L3J0ZlwiLFxuICAgIHJ0eDogXCJ0ZXh0L3JpY2h0ZXh0XCIsXG4gICAgc2dtOiBcInRleHQvc2dtbFwiLFxuICAgIHNnbWw6IFwidGV4dC9zZ21sXCIsXG4gICAgc2g6IFwiYXBwbGljYXRpb24veC1zaFwiLFxuICAgIHNoYXI6IFwiYXBwbGljYXRpb24veC1zaGFyXCIsXG4gICAgc2lsbzogXCJtb2RlbC9tZXNoXCIsXG4gICAgc2l0OiBcImFwcGxpY2F0aW9uL3gtc3R1ZmZpdFwiLFxuICAgIHNrZDogXCJhcHBsaWNhdGlvbi94LWtvYW5cIixcbiAgICBza206IFwiYXBwbGljYXRpb24veC1rb2FuXCIsXG4gICAgc2twOiBcImFwcGxpY2F0aW9uL3gta29hblwiLFxuICAgIHNrdDogXCJhcHBsaWNhdGlvbi94LWtvYW5cIixcbiAgICBzbWk6IFwiYXBwbGljYXRpb24vc21pbFwiLFxuICAgIHNtaWw6IFwiYXBwbGljYXRpb24vc21pbFwiLFxuICAgIHNuZDogXCJhdWRpby9iYXNpY1wiLFxuICAgIHNvOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiLFxuICAgIHNwbDogXCJhcHBsaWNhdGlvbi94LWZ1dHVyZXNwbGFzaFwiLFxuICAgIHNyYzogXCJhcHBsaWNhdGlvbi94LXdhaXMtc291cmNlXCIsXG4gICAgc3Y0Y3BpbzogXCJhcHBsaWNhdGlvbi94LXN2NGNwaW9cIixcbiAgICBzdjRjcmM6IFwiYXBwbGljYXRpb24veC1zdjRjcmNcIixcbiAgICBzdmc6IFwiaW1hZ2Uvc3ZnK3htbFwiLFxuICAgIHN3ZjogXCJhcHBsaWNhdGlvbi94LXNob2Nrd2F2ZS1mbGFzaFwiLFxuICAgIHQ6IFwiYXBwbGljYXRpb24veC10cm9mZlwiLFxuICAgIHRhcjogXCJhcHBsaWNhdGlvbi94LXRhclwiLFxuICAgIHRjbDogXCJhcHBsaWNhdGlvbi94LXRjbFwiLFxuICAgIHRleDogXCJhcHBsaWNhdGlvbi94LXRleFwiLFxuICAgIHRleGk6IFwiYXBwbGljYXRpb24veC10ZXhpbmZvXCIsXG4gICAgdGV4aW5mbzogXCJhcHBsaWNhdGlvbi94LXRleGluZm9cIixcbiAgICB0aWY6IFwiaW1hZ2UvdGlmZlwiLFxuICAgIHRpZmY6IFwiaW1hZ2UvdGlmZlwiLFxuICAgIHRyOiBcImFwcGxpY2F0aW9uL3gtdHJvZmZcIixcbiAgICB0c3Y6IFwidGV4dC90YWItc2VwYXJhdGVkLXZhbHVlc1wiLFxuICAgIHR4dDogXCJ0ZXh0L3BsYWluXCIsXG4gICAgdXN0YXI6IFwiYXBwbGljYXRpb24veC11c3RhclwiLFxuICAgIHZjZDogXCJhcHBsaWNhdGlvbi94LWNkbGlua1wiLFxuICAgIHZybWw6IFwibW9kZWwvdnJtbFwiLFxuICAgIHZ4bWw6IFwiYXBwbGljYXRpb24vdm9pY2V4bWwreG1sXCIsXG4gICAgd2F2OiBcImF1ZGlvL3gtd2F2XCIsXG4gICAgd2JtcDogXCJpbWFnZS92bmQud2FwLndibXBcIixcbiAgICB3Ym14bDogXCJhcHBsaWNhdGlvbi92bmQud2FwLndieG1sXCIsXG4gICAgd21sOiBcInRleHQvdm5kLndhcC53bWxcIixcbiAgICB3bWxjOiBcImFwcGxpY2F0aW9uL3ZuZC53YXAud21sY1wiLFxuICAgIHdtbHM6IFwidGV4dC92bmQud2FwLndtbHNjcmlwdFwiLFxuICAgIHdtbHNjOiBcImFwcGxpY2F0aW9uL3ZuZC53YXAud21sc2NyaXB0Y1wiLFxuICAgIHdybDogXCJtb2RlbC92cm1sXCIsXG4gICAgeGJtOiBcImltYWdlL3gteGJpdG1hcFwiLFxuICAgIHhodDogXCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIixcbiAgICB4aHRtbDogXCJhcHBsaWNhdGlvbi94aHRtbCt4bWxcIixcbiAgICB4bHM6IFwiYXBwbGljYXRpb24vdm5kLm1zLWV4Y2VsXCIsXG4gICAgeG1sOiBcImFwcGxpY2F0aW9uL3htbFwiLFxuICAgIHhwbTogXCJpbWFnZS94LXhwaXhtYXBcIixcbiAgICB4c2w6IFwiYXBwbGljYXRpb24veG1sXCIsXG4gICAgeGxzeDogXCJhcHBsaWNhdGlvbi92bmQub3BlbnhtbGZvcm1hdHMtb2ZmaWNlZG9jdW1lbnQuc3ByZWFkc2hlZXRtbC5zaGVldFwiLFxuICAgIHhsdHg6IFwiYXBwbGljYXRpb24vdm5kLm9wZW54bWxmb3JtYXRzLW9mZmljZWRvY3VtZW50LnNwcmVhZHNoZWV0bWwuXCIgK1xuICAgICAgICAgIFwidGVtcGxhdGVcIixcbiAgICB4bHNtOiBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5tYWNyb0VuYWJsZWQuMTJcIixcbiAgICB4bHRtOiBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC50ZW1wbGF0ZS5tYWNyb0VuYWJsZWQuMTJcIixcbiAgICB4bGFtOiBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5hZGRpbi5tYWNyb0VuYWJsZWQuMTJcIixcbiAgICB4bHNiOiBcImFwcGxpY2F0aW9uL3ZuZC5tcy1leGNlbC5zaGVldC5iaW5hcnkubWFjcm9FbmFibGVkLjEyXCIsXG4gICAgeHNsdDogXCJhcHBsaWNhdGlvbi94c2x0K3htbFwiLFxuICAgIHh1bDogXCJhcHBsaWNhdGlvbi92bmQubW96aWxsYS54dWwreG1sXCIsXG4gICAgeHdkOiBcImltYWdlL3gteHdpbmRvd2R1bXBcIixcbiAgICB4eXo6IFwiY2hlbWljYWwveC14eXpcIixcbiAgICB6aXA6IFwiYXBwbGljYXRpb24vemlwXCJcbiAgfTtcblxuICAvKipcbiAgICogUmVhZHMgYSBGaWxlIHVzaW5nIGEgRmlsZVJlYWRlci5cbiAgICogQHBhcmFtIGZpbGUge0ZpbGV9IHRoZSBGaWxlIHRvIHJlYWQuXG4gICAqIEBwYXJhbSB0eXBlIHtTdHJpbmd9IChvcHRpb25hbCkgdGhlIG1pbWV0eXBlIHRvIG92ZXJyaWRlIHdpdGguXG4gICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdpdGggYVxuICAgKiAgICAgYmFzZTY0LWVuY29kZWQgc3RyaW5nIG9mIHRoZSBkYXRhIGFuZCBpdHMgbWltZSB0eXBlLlxuICAgKi9cbiAgdmFyIHJlYWRBc3luYyA9IGZ1bmN0aW9uKGZpbGUsIHR5cGUpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBBVi5Qcm9taXNlKCk7XG5cbiAgICBpZiAodHlwZW9mKEZpbGVSZWFkZXIpID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICByZXR1cm4gQVYuUHJvbWlzZS5lcnJvcihuZXcgQVYuRXJyb3IoXG4gICAgICAgICAgLTEsIFwiQXR0ZW1wdGVkIHRvIHVzZSBhIEZpbGVSZWFkZXIgb24gYW4gdW5zdXBwb3J0ZWQgYnJvd3Nlci5cIikpO1xuICAgIH1cblxuICAgIHZhciByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmIChyZWFkZXIucmVhZHlTdGF0ZSAhPT0gMikge1xuICAgICAgICBwcm9taXNlLnJlamVjdChuZXcgQVYuRXJyb3IoLTEsIFwiRXJyb3IgcmVhZGluZyBmaWxlLlwiKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGRhdGFVUkwgPSByZWFkZXIucmVzdWx0O1xuICAgICAgdmFyIG1hdGNoZXMgPSAvXmRhdGE6KFteO10qKTtiYXNlNjQsKC4qKSQvLmV4ZWMoZGF0YVVSTCk7XG4gICAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoXG4gICAgICAgICAgICBuZXcgQVYuRXJyb3IoLTEsIFwiVW5hYmxlIHRvIGludGVycHJldCBkYXRhIFVSTDogXCIgKyBkYXRhVVJMKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJvbWlzZS5yZXNvbHZlKG1hdGNoZXNbMl0sIHR5cGUgfHwgbWF0Y2hlc1sxXSk7XG4gICAgfTtcbiAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfTtcblxuICAvKipcbiAgICogQSBBVi5GaWxlIGlzIGEgbG9jYWwgcmVwcmVzZW50YXRpb24gb2YgYSBmaWxlIHRoYXQgaXMgc2F2ZWQgdG8gdGhlIEFWXG4gICAqIGNsb3VkLlxuICAgKiBAcGFyYW0gbmFtZSB7U3RyaW5nfSBUaGUgZmlsZSdzIG5hbWUuIFRoaXMgd2lsbCBjaGFuZ2UgdG8gYSB1bmlxdWUgdmFsdWVcbiAgICogICAgIG9uY2UgdGhlIGZpbGUgaGFzIGZpbmlzaGVkIHNhdmluZy5cbiAgICogQHBhcmFtIGRhdGEge0FycmF5fSBUaGUgZGF0YSBmb3IgdGhlIGZpbGUsIGFzIGVpdGhlcjpcbiAgICogICAgIDEuIGFuIEFycmF5IG9mIGJ5dGUgdmFsdWUgTnVtYmVycywgb3JcbiAgICogICAgIDIuIGFuIE9iamVjdCBsaWtlIHsgYmFzZTY0OiBcIi4uLlwiIH0gd2l0aCBhIGJhc2U2NC1lbmNvZGVkIFN0cmluZy5cbiAgICogICAgIDMuIGEgRmlsZSBvYmplY3Qgc2VsZWN0ZWQgd2l0aCBhIGZpbGUgdXBsb2FkIGNvbnRyb2wuICgzKSBvbmx5IHdvcmtzXG4gICAqICAgICAgICBpbiBGaXJlZm94IDMuNissIFNhZmFyaSA2LjAuMissIENocm9tZSA3KywgYW5kIElFIDEwKy5cbiAgICogICAgICAgIEZvciBleGFtcGxlOjxwcmU+XG4gICAqICAgICA0LmEgQnVmZmVyIG9iamVjdCBpbiBOb2RlLmpzIHJ1bnRpbWUuXG4gICAqIHZhciBmaWxlVXBsb2FkQ29udHJvbCA9ICQoXCIjcHJvZmlsZVBob3RvRmlsZVVwbG9hZFwiKVswXTtcbiAgICogaWYgKGZpbGVVcGxvYWRDb250cm9sLmZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICogICB2YXIgZmlsZSA9IGZpbGVVcGxvYWRDb250cm9sLmZpbGVzWzBdO1xuICAgKiAgIHZhciBuYW1lID0gXCJwaG90by5qcGdcIjtcbiAgICogICB2YXIgcGFyc2VGaWxlID0gbmV3IEFWLkZpbGUobmFtZSwgZmlsZSk7XG4gICAqICAgcGFyc2VGaWxlLnNhdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgKiAgICAgLy8gVGhlIGZpbGUgaGFzIGJlZW4gc2F2ZWQgdG8gQVYuXG4gICAqICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICogICAgIC8vIFRoZSBmaWxlIGVpdGhlciBjb3VsZCBub3QgYmUgcmVhZCwgb3IgY291bGQgbm90IGJlIHNhdmVkIHRvIEFWLlxuICAgKiAgIH0pO1xuICAgKiB9PC9wcmU+XG4gICAqXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0gdHlwZSB7U3RyaW5nfSBPcHRpb25hbCBDb250ZW50LVR5cGUgaGVhZGVyIHRvIHVzZSBmb3IgdGhlIGZpbGUuIElmXG4gICAqICAgICB0aGlzIGlzIG9taXR0ZWQsIHRoZSBjb250ZW50IHR5cGUgd2lsbCBiZSBpbmZlcnJlZCBmcm9tIHRoZSBuYW1lJ3NcbiAgICogICAgIGV4dGVuc2lvbi5cbiAgICovXG4gIEFWLkZpbGUgPSBmdW5jdGlvbihuYW1lLCBkYXRhLCB0eXBlKSB7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgdmFyIGN1cnJlbnRVc2VyO1xuICAgIHRyeSB7XG4gICAgICBjdXJyZW50VXNlciA9IEFWLlVzZXIuY3VycmVudCgpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKCdHZXQgY3VycmVudCB1c2VyIGZhaWxlZC4gSXQgc2VlbXMgdGhpcyBydW50aW1lIHVzZSBhbiBhc3luYyBzdG9yYWdlIHN5c3RlbSwgcGxlYXNlIG5ldyBBVi5GaWxlIGluIHRoZSBjYWxsYmFjayBvZiBBVi5Vc2VyLmN1cnJlbnRBc3luYygpLicpO1xuICAgIH1cbiAgICB0aGlzLl9tZXRhRGF0YSA9IHtcbiAgICAgICBvd25lcjogKGN1cnJlbnRVc2VyICE9IG51bGwgPyBjdXJyZW50VXNlci5pZCA6ICd1bmtub3duJylcbiAgICB9O1xuXG4gICAgLy8gR3Vlc3MgdGhlIGNvbnRlbnQgdHlwZSBmcm9tIHRoZSBleHRlbnNpb24gaWYgd2UgbmVlZCB0by5cbiAgICB2YXIgZXh0ZW5zaW9uID0gL1xcLihbXi5dKikkLy5leGVjKG5hbWUpO1xuICAgIGlmIChleHRlbnNpb24pIHtcbiAgICAgIGV4dGVuc2lvbiA9IGV4dGVuc2lvblsxXS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICB2YXIgZ3Vlc3NlZFR5cGUgPSB0eXBlIHx8IG1pbWVUeXBlc1tleHRlbnNpb25dIHx8IFwidGV4dC9wbGFpblwiO1xuICAgIHRoaXMuX2d1ZXNzZWRUeXBlID0gZ3Vlc3NlZFR5cGU7XG5cbiAgICBpZiAoXy5pc0FycmF5KGRhdGEpKSB7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBBVi5Qcm9taXNlLmFzKGVuY29kZUJhc2U2NChkYXRhKSwgZ3Vlc3NlZFR5cGUpO1xuICAgICAgdGhpcy5fbWV0YURhdGEuc2l6ZSA9IGRhdGEubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAoZGF0YSAmJiBkYXRhLmJhc2U2NCkge1xuICAgICAgdmFyIHBhcnNlQmFzZTY0ID0gcmVxdWlyZSgnLi9icm93c2VyaWZ5LXdyYXBwZXIvcGFyc2UtYmFzZTY0Jyk7XG4gICAgICB2YXIgZGF0YUJhc2U2NCA9IHBhcnNlQmFzZTY0KGRhdGEuYmFzZTY0LCBndWVzc2VkVHlwZSk7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBBVi5Qcm9taXNlLmFzKGRhdGFCYXNlNjQsIGd1ZXNzZWRUeXBlKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgJiYgZGF0YS5ibG9iKSB7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBBVi5Qcm9taXNlLmFzKGRhdGEuYmxvYiwgZ3Vlc3NlZFR5cGUpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mKEZpbGUpICE9PSBcInVuZGVmaW5lZFwiICYmIGRhdGEgaW5zdGFuY2VvZiBGaWxlKSB7XG4gICAgICB0aGlzLl9zb3VyY2UgPSBBVi5Qcm9taXNlLmFzKGRhdGEsIGd1ZXNzZWRUeXBlKTtcbiAgICB9IGVsc2UgaWYoQVYuX2lzTm9kZSAmJiBnbG9iYWwuQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAvLyB1c2UgZ2xvYmFsLkJ1ZmZlciB0byBwcmV2ZW50IGJyb3dzZXJpZnkgcGFjayBCdWZmZXIgbW9kdWxlXG4gICAgICB0aGlzLl9zb3VyY2UgPSBBVi5Qcm9taXNlLmFzKGRhdGEudG9TdHJpbmcoJ2Jhc2U2NCcpLCBndWVzc2VkVHlwZSk7XG4gICAgICB0aGlzLl9tZXRhRGF0YS5zaXplID0gZGF0YS5sZW5ndGg7XG4gICAgfSBlbHNlIGlmIChfLmlzU3RyaW5nKGRhdGEpKSB7XG4gICAgICB0aHJvdyBcIkNyZWF0aW5nIGEgQVYuRmlsZSBmcm9tIGEgU3RyaW5nIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLlwiO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZyZXNoIEFWLkZpbGUgb2JqZWN0IHdpdGggZXhpc3RzIHVybCBmb3Igc2F2aW5nIHRvIEFWT1MgQ2xvdWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIHRoZSBmaWxlIG5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVybCB0aGUgZmlsZSB1cmwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhRGF0YSB0aGUgZmlsZSBtZXRhZGF0YSBvYmplY3QsaXQncyBvcHRpb25hbC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IE9wdGlvbmFsIENvbnRlbnQtVHlwZSBoZWFkZXIgdG8gdXNlIGZvciB0aGUgZmlsZS4gSWZcbiAgICogICAgIHRoaXMgaXMgb21pdHRlZCwgdGhlIGNvbnRlbnQgdHlwZSB3aWxsIGJlIGluZmVycmVkIGZyb20gdGhlIG5hbWUnc1xuICAgKiAgICAgZXh0ZW5zaW9uLlxuICAgKiBAcmV0dXJuIHtBVi5GaWxlfSB0aGUgZmlsZSBvYmplY3RcbiAgICovXG4gIEFWLkZpbGUud2l0aFVSTCA9IGZ1bmN0aW9uKG5hbWUsIHVybCwgbWV0YURhdGEsIHR5cGUpe1xuICAgIGlmKCFuYW1lIHx8ICF1cmwpe1xuICAgICAgdGhyb3cgXCJQbGVhc2UgcHJvdmlkZSBmaWxlIG5hbWUgYW5kIHVybFwiO1xuICAgIH1cbiAgICB2YXIgZmlsZSA9IG5ldyBBVi5GaWxlKG5hbWUsIG51bGwsIHR5cGUpO1xuICAgIC8vY29weSBtZXRhRGF0YSBwcm9wZXJ0aWVzIHRvIGZpbGUuXG4gICAgaWYobWV0YURhdGEpe1xuICAgICAgZm9yKHZhciBwcm9wIGluIG1ldGFEYXRhKXtcbiAgICAgICAgaWYoIWZpbGUuX21ldGFEYXRhW3Byb3BdKVxuICAgICAgICAgIGZpbGUuX21ldGFEYXRhW3Byb3BdID0gbWV0YURhdGFbcHJvcF07XG4gICAgICB9XG4gICAgfVxuICAgIGZpbGUuX3VybCA9IHVybDtcbiAgICAvL01hcmsgdGhlIGZpbGUgaXMgZnJvbSBleHRlcm5hbCBzb3VyY2UuXG4gICAgZmlsZS5fbWV0YURhdGFbJ19fc291cmNlJ10gPSAnZXh0ZXJuYWwnO1xuICAgIHJldHVybiBmaWxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZmlsZSBvYmplY3Qgd2l0aCBleGlzdHMgb2JqZWN0SWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBvYmplY3RJZCBUaGUgb2JqZWN0SWQgc3RyaW5nXG4gICAqIEByZXR1cm4ge0FWLkZpbGV9IHRoZSBmaWxlIG9iamVjdFxuICAgKi9cbiAgQVYuRmlsZS5jcmVhdGVXaXRob3V0RGF0YSA9IGZ1bmN0aW9uKG9iamVjdElkKXtcbiAgICB2YXIgZmlsZSA9IG5ldyBBVi5GaWxlKCk7XG4gICAgZmlsZS5pZCA9IG9iamVjdElkO1xuICAgIHJldHVybiBmaWxlO1xuICB9O1xuXG4gIEFWLkZpbGUucHJvdG90eXBlID0ge1xuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBBVi5fZW5jb2RlKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBBQ0wgZm9yIHRoaXMgZmlsZS5cbiAgICAgKiBAcmV0dXJucyB7QVYuQUNMfSBBbiBpbnN0YW5jZSBvZiBBVi5BQ0wuXG4gICAgICovXG4gICAgZ2V0QUNMOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hY2w7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIEFDTCB0byBiZSB1c2VkIGZvciB0aGlzIGZpbGUuXG4gICAgICogQHBhcmFtIHtBVi5BQ0x9IGFjbCBBbiBpbnN0YW5jZSBvZiBBVi5BQ0wuXG4gICAgICovXG4gICAgc2V0QUNMOiBmdW5jdGlvbihhY2wpIHtcbiAgICAgICAgaWYoIShhY2wgaW5zdGFuY2VvZiBBVi5BQ0wpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBVi5FcnJvcihBVi5FcnJvci5PVEhFUl9DQVVTRSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkFDTCBtdXN0IGJlIGEgQVYuQUNMLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9hY2wgPSBhY2w7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIGZpbGUuIEJlZm9yZSBzYXZlIGlzIGNhbGxlZCwgdGhpcyBpcyB0aGUgZmlsZW5hbWVcbiAgICAgKiBnaXZlbiBieSB0aGUgdXNlci4gQWZ0ZXIgc2F2ZSBpcyBjYWxsZWQsIHRoYXQgbmFtZSBnZXRzIHByZWZpeGVkIHdpdGggYVxuICAgICAqIHVuaXF1ZSBpZGVudGlmaWVyLlxuICAgICAqL1xuICAgIG5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX25hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHVybCBvZiB0aGUgZmlsZS4gSXQgaXMgb25seSBhdmFpbGFibGUgYWZ0ZXIgeW91IHNhdmUgdGhlIGZpbGUgb3JcbiAgICAgKiBhZnRlciB5b3UgZ2V0IHRoZSBmaWxlIGZyb20gYSBBVi5PYmplY3QuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqL1xuICAgIHVybDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdXJsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAqIDxwPlJldHVybnMgdGhlIGZpbGUncyBtZXRhZGF0YSBKU09OIG9iamVjdCBpZiBubyBhcmd1bWVudHMgaXMgZ2l2ZW4uUmV0dXJucyB0aGVcbiAgICAqIG1ldGFkYXRhIHZhbHVlIGlmIGEga2V5IGlzIGdpdmVuLlNldCBtZXRhZGF0YSB2YWx1ZSBpZiBrZXkgYW5kIHZhbHVlIGFyZSBib3RoIGdpdmVuLjwvcD5cbiAgICAqIDxwPjxwcmU+XG4gICAgKiAgdmFyIG1ldGFkYXRhID0gZmlsZS5tZXRhRGF0YSgpOyAvL0dldCBtZXRhZGF0YSBKU09OIG9iamVjdC5cbiAgICAqICB2YXIgc2l6ZSA9IGZpbGUubWV0YURhdGEoJ3NpemUnKTsgIC8vIEdldCB0aGUgc2l6ZSBtZXRhZGF0YSB2YWx1ZS5cbiAgICAqICBmaWxlLm1ldGFEYXRhKCdmb3JtYXQnLCAnanBlZycpOyAvL3NldCBtZXRhZGF0YSBhdHRyaWJ1dGUgYW5kIHZhbHVlLlxuICAgICo8L3ByZT48L3A+XG4gICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBmaWxlJ3MgbWV0YWRhdGEgSlNPTiBvYmplY3QuXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBhbiBvcHRpb25hbCBtZXRhZGF0YSBrZXkuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWUgYW4gb3B0aW9uYWwgbWV0YWRhdGEgdmFsdWUuXG4gICAgKiovXG4gICAgbWV0YURhdGE6IGZ1bmN0aW9uKGF0dHIsIHZhbHVlKSB7XG4gICAgICBpZihhdHRyICE9IG51bGwgJiYgdmFsdWUgIT0gbnVsbCl7XG4gICAgICAgICB0aGlzLl9tZXRhRGF0YVthdHRyXSA9IHZhbHVlO1xuICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9ZWxzZSBpZihhdHRyICE9IG51bGwpe1xuICAgICAgICAgcmV0dXJuIHRoaXMuX21ldGFEYXRhW2F0dHJdO1xuICAgICAgfWVsc2V7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZXRhRGF0YTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAvKipcbiAgICAqIOWmguaenOaWh+S7tuaYr+WbvueJh++8jOiOt+WPluWbvueJh+eahOe8qeeVpeWbvlVSTOOAguWPr+S7peS8oOWFpeWuveW6puOAgemrmOW6puOAgei0qOmHj+OAgeagvOW8j+etieWPguaVsOOAglxuICAgICogQHJldHVybiB7U3RyaW5nfSDnvKnnlaXlm75VUkxcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aCDlrr3luqbvvIzljZXkvY3vvJrlg4/ntKBcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBoZWlndGgg6auY5bqm77yM5Y2V5L2N77ya5YOP57SgXG4gICAgKiBAcGFyYW0ge051bWJlcn0gcXVhbGl0eSDotKjph4/vvIwxLTEwMOeahOaVsOWtl++8jOm7mOiupDEwMFxuICAgICogQHBhcmFtIHtOdW1iZXJ9IHNjYWxlVG9GaXQg5piv5ZCm5bCG5Zu+54mH6Ieq6YCC5bqU5aSn5bCP44CC6buY6K6k5Li6dHJ1ZeOAglxuICAgICogQHBhcmFtIHtTdHJpbmd9IGZtdCDmoLzlvI/vvIzpu5jorqTkuLpwbmfvvIzkuZ/lj6/ku6XkuLpqcGVnLGdpZuetieagvOW8j+OAglxuICAgICovXG4gICB0aHVtYm5haWxVUkw6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHF1YWxpdHksIHNjYWxlVG9GaXQsIGZtdCl7XG4gICAgIGlmKCF0aGlzLnVybCgpKXtcbiAgICAgICB0aHJvdyBcIkludmFsaWQgdXJsLlwiO1xuICAgICB9XG4gICAgIGlmKCF3aWR0aCB8fCAhaGVpZ2h0IHx8IHdpZHRoPD0wIHx8IGhlaWdodCA8PTAgKXtcbiAgICAgICB0aHJvdyBcIkludmFsaWQgd2lkdGggb3IgaGVpZ2h0IHZhbHVlLlwiO1xuICAgICB9XG4gICAgIHF1YWxpdHkgPSBxdWFsaXR5IHx8IDEwMDtcbiAgICAgc2NhbGVUb0ZpdCA9IChzY2FsZVRvRml0ID09IG51bGwpID8gdHJ1ZTogc2NhbGVUb0ZpdDtcbiAgICAgaWYocXVhbGl0eTw9MCB8fCBxdWFsaXR5PjEwMCl7XG4gICAgICAgdGhyb3cgXCJJbnZhbGlkIHF1YWxpdHkgdmFsdWUuXCI7XG4gICAgIH1cbiAgICAgZm10ID0gZm10IHx8ICdwbmcnO1xuICAgICB2YXIgbW9kZSA9IHNjYWxlVG9GaXQgPyAyOiAxO1xuICAgICByZXR1cm4gdGhpcy51cmwoKSArICc/aW1hZ2VWaWV3LycgKyBtb2RlICsgJy93LycgKyB3aWR0aCArICcvaC8nICsgaGVpZ2h0XG4gICAgICAgKyAnL3EvJyArIHF1YWxpdHkgKyAnL2Zvcm1hdC8nICsgZm10O1xuICAgfSxcblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgZmlsZSdzIHNpemUuXG4gICAgKiBAcmV0dXJuIHtOdW1iZXJ9IFRoZSBmaWxlJ3Mgc2l6ZSBpbiBieXRlcy5cbiAgICAqKi9cbiAgICBzaXplOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMubWV0YURhdGEoKS5zaXplO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBmaWxlJ3Mgb3duZXIuXG4gICAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgZmlsZSdzIG93bmVyIGlkLlxuICAgICAqL1xuICAgIG93bmVySWQ6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5tZXRhRGF0YSgpLm93bmVyO1xuICAgIH0sXG4gICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIGZpbGUuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gdGhlIGRlc3Ryb3lcbiAgICAgKiAgICAgY29tcGxldGVzLlxuICAgICAqL1xuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgaWYoIXRoaXMuaWQpXG4gICAgICAgIHJldHVybiBBVi5Qcm9taXNlLmVycm9yKCdUaGUgZmlsZSBpZCBpcyBub3QgZWl4c3RzLicpLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgICAgdmFyIHJlcXVlc3QgPSBBVi5fcmVxdWVzdChcImZpbGVzXCIsIG51bGwsIHRoaXMuaWQsICdERUxFVEUnKTtcbiAgICAgIHJldHVybiByZXF1ZXN0Ll90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IFFpbml1IHVwbG9hZCB0b2tlblxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gUmVzb2x2ZWQgd2l0aCB0aGUgcmVzcG9uc2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9xaW5pdVRva2VuOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAvL0NyZWF0ZSAxNi1iaXRzIHV1aWQgYXMgcWluaXUga2V5LlxuICAgICAgdmFyIGV4dE5hbWUgPSBleHRuYW1lKHNlbGYuX25hbWUpO1xuICAgICAgdmFyIGhleE9jdGV0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKCgxK01hdGgucmFuZG9tKCkpKjB4MTAwMDApLnRvU3RyaW5nKDE2KS5zdWJzdHJpbmcoMSk7XG4gICAgICB9O1xuICAgICAgdmFyIGtleSA9IGhleE9jdGV0KCkgKyBoZXhPY3RldCgpICsgaGV4T2N0ZXQoKSArIGhleE9jdGV0KCkgKyBoZXhPY3RldCgpXG4gICAgICAgICAgKyBleHROYW1lO1xuXG4gICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIEFDTDogc2VsZi5fYWNsLFxuICAgICAgICBuYW1lOnNlbGYuX25hbWUsXG4gICAgICAgIG1pbWVfdHlwZTogdHlwZSxcbiAgICAgICAgbWV0YURhdGE6IHNlbGYuX21ldGFEYXRhXG4gICAgICB9O1xuICAgICAgaWYodHlwZSAmJiBzZWxmLl9tZXRhRGF0YS5taW1lX3R5cGUgPT0gbnVsbClcbiAgICAgICAgc2VsZi5fbWV0YURhdGEubWltZV90eXBlID0gdHlwZTtcbiAgICAgIHNlbGYuX3Fpbml1X2tleSA9IGtleTtcbiAgICAgIHJldHVybiBBVi5fcmVxdWVzdChcInFpbml1XCIsIG51bGwsIG51bGwsICdQT1NUJywgZGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBjYWxsYmFjayBVcGxvYWRQcm9ncmVzc0NhbGxiYWNrXG4gICAgICogQHBhcmFtIHtYTUxIdHRwUmVxdWVzdFByb2dyZXNzRXZlbnR9IGV2ZW50IC0gVGhlIHByb2dyZXNzIGV2ZW50IHdpdGggJ2xvYWRlZCcgYW5kICd0b3RhbCcgYXR0cmlidXRlc1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFNhdmVzIHRoZSBmaWxlIHRvIHRoZSBBViBjbG91ZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc2F2ZU9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge1VwbG9hZFByb2dyZXNzQ2FsbGJhY2t9IFtzYXZlT3B0aW9ucy5vblByb2dyZXNzXVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gUHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdoZW4gdGhlIHNhdmUgZmluaXNoZXMuXG4gICAgICovXG4gICAgc2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IG51bGw7XG4gICAgICB2YXIgc2F2ZU9wdGlvbnMgPSB7fTtcbiAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3VtZW50c1swXTtcbiAgICAgIH0gZWxzZSBpZihhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHNhdmVPcHRpb25zID0gYXJndW1lbnRzWzBdO1xuICAgICAgICBvcHRpb25zID0gYXJndW1lbnRzWzFdO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKCFzZWxmLl9wcmV2aW91c1NhdmUpIHtcbiAgICAgICAgaWYoc2VsZi5fc291cmNlKSB7XG4gICAgICAgICAgdmFyIHVwbG9hZCA9IHJlcXVpcmUoJy4vYnJvd3NlcmlmeS13cmFwcGVyL3VwbG9hZCcpO1xuICAgICAgICAgIHVwbG9hZChzZWxmLCBBViwgc2F2ZU9wdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYoc2VsZi5fdXJsICYmIHNlbGYuX21ldGFEYXRhWydfX3NvdXJjZSddID09ICdleHRlcm5hbCcpIHtcbiAgICAgICAgICAvL2V4dGVybmFsIGxpbmsgZmlsZS5cbiAgICAgICAgICB2YXIgZGF0YSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHNlbGYuX25hbWUsXG4gICAgICAgICAgICBBQ0w6IHNlbGYuX2FjbCxcbiAgICAgICAgICAgIG1ldGFEYXRhOiBzZWxmLl9tZXRhRGF0YSxcbiAgICAgICAgICAgIG1pbWVfdHlwZTogc2VsZi5fZ3Vlc3NlZFR5cGUsXG4gICAgICAgICAgICB1cmw6IHNlbGYuX3VybFxuICAgICAgICAgIH07XG4gICAgICAgICAgc2VsZi5fcHJldmlvdXNTYXZlID0gQVYuX3JlcXVlc3QoXCJmaWxlc1wiLCBzZWxmLl9uYW1lLCBudWxsLCAnUE9TVCcsIGRhdGEpLnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHNlbGYuX25hbWUgPSByZXNwb25zZS5uYW1lO1xuICAgICAgICAgICAgc2VsZi5fdXJsID0gcmVzcG9uc2UudXJsO1xuICAgICAgICAgICAgc2VsZi5pZCA9IHJlc3BvbnNlLm9iamVjdElkO1xuICAgICAgICAgICAgaWYocmVzcG9uc2Uuc2l6ZSkge1xuICAgICAgICAgICAgICBzZWxmLl9tZXRhRGF0YS5zaXplID0gcmVzcG9uc2Uuc2l6ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VsZi5fcHJldmlvdXNTYXZlLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH1cbiAgfTtcblxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJvTWZwQW5cIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvZmlsZS5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG4vKmdsb2JhbCBuYXZpZ2F0b3I6IGZhbHNlICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEFWKSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IEdlb1BvaW50IHdpdGggYW55IG9mIHRoZSBmb2xsb3dpbmcgZm9ybXM6PGJyPlxuICAgKiAgIDxwcmU+XG4gICAqICAgbmV3IEdlb1BvaW50KG90aGVyR2VvUG9pbnQpXG4gICAqICAgbmV3IEdlb1BvaW50KDMwLCAzMClcbiAgICogICBuZXcgR2VvUG9pbnQoWzMwLCAzMF0pXG4gICAqICAgbmV3IEdlb1BvaW50KHtsYXRpdHVkZTogMzAsIGxvbmdpdHVkZTogMzB9KVxuICAgKiAgIG5ldyBHZW9Qb2ludCgpICAvLyBkZWZhdWx0cyB0byAoMCwgMClcbiAgICogICA8L3ByZT5cbiAgICogQGNsYXNzXG4gICAqXG4gICAqIDxwPlJlcHJlc2VudHMgYSBsYXRpdHVkZSAvIGxvbmdpdHVkZSBwb2ludCB0aGF0IG1heSBiZSBhc3NvY2lhdGVkXG4gICAqIHdpdGggYSBrZXkgaW4gYSBBVk9iamVjdCBvciB1c2VkIGFzIGEgcmVmZXJlbmNlIHBvaW50IGZvciBnZW8gcXVlcmllcy5cbiAgICogVGhpcyBhbGxvd3MgcHJveGltaXR5LWJhc2VkIHF1ZXJpZXMgb24gdGhlIGtleS48L3A+XG4gICAqXG4gICAqIDxwPk9ubHkgb25lIGtleSBpbiBhIGNsYXNzIG1heSBjb250YWluIGEgR2VvUG9pbnQuPC9wPlxuICAgKlxuICAgKiA8cD5FeGFtcGxlOjxwcmU+XG4gICAqICAgdmFyIHBvaW50ID0gbmV3IEFWLkdlb1BvaW50KDMwLjAsIC0yMC4wKTtcbiAgICogICB2YXIgb2JqZWN0ID0gbmV3IEFWLk9iamVjdChcIlBsYWNlT2JqZWN0XCIpO1xuICAgKiAgIG9iamVjdC5zZXQoXCJsb2NhdGlvblwiLCBwb2ludCk7XG4gICAqICAgb2JqZWN0LnNhdmUoKTs8L3ByZT48L3A+XG4gICAqL1xuICBBVi5HZW9Qb2ludCA9IGZ1bmN0aW9uKGFyZzEsIGFyZzIpIHtcbiAgICBpZiAoXy5pc0FycmF5KGFyZzEpKSB7XG4gICAgICBBVi5HZW9Qb2ludC5fdmFsaWRhdGUoYXJnMVswXSwgYXJnMVsxXSk7XG4gICAgICB0aGlzLmxhdGl0dWRlID0gYXJnMVswXTtcbiAgICAgIHRoaXMubG9uZ2l0dWRlID0gYXJnMVsxXTtcbiAgICB9IGVsc2UgaWYgKF8uaXNPYmplY3QoYXJnMSkpIHtcbiAgICAgIEFWLkdlb1BvaW50Ll92YWxpZGF0ZShhcmcxLmxhdGl0dWRlLCBhcmcxLmxvbmdpdHVkZSk7XG4gICAgICB0aGlzLmxhdGl0dWRlID0gYXJnMS5sYXRpdHVkZTtcbiAgICAgIHRoaXMubG9uZ2l0dWRlID0gYXJnMS5sb25naXR1ZGU7XG4gICAgfSBlbHNlIGlmIChfLmlzTnVtYmVyKGFyZzEpICYmIF8uaXNOdW1iZXIoYXJnMikpIHtcbiAgICAgIEFWLkdlb1BvaW50Ll92YWxpZGF0ZShhcmcxLCBhcmcyKTtcbiAgICAgIHRoaXMubGF0aXR1ZGUgPSBhcmcxO1xuICAgICAgdGhpcy5sb25naXR1ZGUgPSBhcmcyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxhdGl0dWRlID0gMDtcbiAgICAgIHRoaXMubG9uZ2l0dWRlID0gMDtcbiAgICB9XG5cbiAgICAvLyBBZGQgcHJvcGVydGllcyBzbyB0aGF0IGFueW9uZSB1c2luZyBXZWJraXQgb3IgTW96aWxsYSB3aWxsIGdldCBhbiBlcnJvclxuICAgIC8vIGlmIHRoZXkgdHJ5IHRvIHNldCB2YWx1ZXMgdGhhdCBhcmUgb3V0IG9mIGJvdW5kcy5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHRoaXMuX19kZWZpbmVHZXR0ZXJfXyAmJiB0aGlzLl9fZGVmaW5lU2V0dGVyX18pIHtcbiAgICAgIC8vIFVzZSBfbGF0aXR1ZGUgYW5kIF9sb25naXR1ZGUgdG8gYWN0dWFsbHkgc3RvcmUgdGhlIHZhbHVlcywgYW5kIGFkZFxuICAgICAgLy8gZ2V0dGVycyBhbmQgc2V0dGVycyBmb3IgbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZS5cbiAgICAgIHRoaXMuX2xhdGl0dWRlID0gdGhpcy5sYXRpdHVkZTtcbiAgICAgIHRoaXMuX2xvbmdpdHVkZSA9IHRoaXMubG9uZ2l0dWRlO1xuICAgICAgdGhpcy5fX2RlZmluZUdldHRlcl9fKFwibGF0aXR1ZGVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmLl9sYXRpdHVkZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX2RlZmluZUdldHRlcl9fKFwibG9uZ2l0dWRlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5fbG9uZ2l0dWRlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9fZGVmaW5lU2V0dGVyX18oXCJsYXRpdHVkZVwiLCBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgQVYuR2VvUG9pbnQuX3ZhbGlkYXRlKHZhbCwgc2VsZi5sb25naXR1ZGUpO1xuICAgICAgICBzZWxmLl9sYXRpdHVkZSA9IHZhbDtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX2RlZmluZVNldHRlcl9fKFwibG9uZ2l0dWRlXCIsIGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBBVi5HZW9Qb2ludC5fdmFsaWRhdGUoc2VsZi5sYXRpdHVkZSwgdmFsKTtcbiAgICAgICAgc2VsZi5fbG9uZ2l0dWRlID0gdmFsO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBAbGVuZHMgQVYuR2VvUG9pbnQucHJvdG90eXBlXG4gICAqIEBwcm9wZXJ0eSB7ZmxvYXR9IGxhdGl0dWRlIE5vcnRoLXNvdXRoIHBvcnRpb24gb2YgdGhlIGNvb3JkaW5hdGUsIGluIHJhbmdlXG4gICAqICAgWy05MCwgOTBdLiAgVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiBzZXQgb3V0IG9mIHJhbmdlIGluIGEgbW9kZXJuIGJyb3dzZXIuXG4gICAqIEBwcm9wZXJ0eSB7ZmxvYXR9IGxvbmdpdHVkZSBFYXN0LXdlc3QgcG9ydGlvbiBvZiB0aGUgY29vcmRpbmF0ZSwgaW4gcmFuZ2VcbiAgICogICBbLTE4MCwgMTgwXS4gIFRocm93cyBpZiBzZXQgb3V0IG9mIHJhbmdlIGluIGEgbW9kZXJuIGJyb3dzZXIuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBUaHJvd3MgYW4gZXhjZXB0aW9uIGlmIHRoZSBnaXZlbiBsYXQtbG9uZyBpcyBvdXQgb2YgYm91bmRzLlxuICAgKi9cbiAgQVYuR2VvUG9pbnQuX3ZhbGlkYXRlID0gZnVuY3Rpb24obGF0aXR1ZGUsIGxvbmdpdHVkZSkge1xuICAgIGlmIChsYXRpdHVkZSA8IC05MC4wKSB7XG4gICAgICB0aHJvdyBcIkFWLkdlb1BvaW50IGxhdGl0dWRlIFwiICsgbGF0aXR1ZGUgKyBcIiA8IC05MC4wLlwiO1xuICAgIH1cbiAgICBpZiAobGF0aXR1ZGUgPiA5MC4wKSB7XG4gICAgICB0aHJvdyBcIkFWLkdlb1BvaW50IGxhdGl0dWRlIFwiICsgbGF0aXR1ZGUgKyBcIiA+IDkwLjAuXCI7XG4gICAgfVxuICAgIGlmIChsb25naXR1ZGUgPCAtMTgwLjApIHtcbiAgICAgIHRocm93IFwiQVYuR2VvUG9pbnQgbG9uZ2l0dWRlIFwiICsgbG9uZ2l0dWRlICsgXCIgPCAtMTgwLjAuXCI7XG4gICAgfVxuICAgIGlmIChsb25naXR1ZGUgPiAxODAuMCkge1xuICAgICAgdGhyb3cgXCJBVi5HZW9Qb2ludCBsb25naXR1ZGUgXCIgKyBsb25naXR1ZGUgKyBcIiA+IDE4MC4wLlwiO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIEdlb1BvaW50IHdpdGggdGhlIHVzZXIncyBjdXJyZW50IGxvY2F0aW9uLCBpZiBhdmFpbGFibGUuXG4gICAqIENhbGxzIG9wdGlvbnMuc3VjY2VzcyB3aXRoIGEgbmV3IEdlb1BvaW50IGluc3RhbmNlIG9yIGNhbGxzIG9wdGlvbnMuZXJyb3IuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9iamVjdCB3aXRoIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrcy5cbiAgICovXG4gIEFWLkdlb1BvaW50LmN1cnJlbnQgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgQVYuUHJvbWlzZSgpO1xuICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oZnVuY3Rpb24obG9jYXRpb24pIHtcbiAgICAgIHByb21pc2UucmVzb2x2ZShuZXcgQVYuR2VvUG9pbnQoe1xuICAgICAgICBsYXRpdHVkZTogbG9jYXRpb24uY29vcmRzLmxhdGl0dWRlLFxuICAgICAgICBsb25naXR1ZGU6IGxvY2F0aW9uLmNvb3Jkcy5sb25naXR1ZGVcbiAgICAgIH0pKTtcblxuICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBwcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zKTtcbiAgfTtcblxuICBBVi5HZW9Qb2ludC5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIEdlb1BvaW50LCBzdWl0YWJsZSBmb3IgQVYuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICBBVi5HZW9Qb2ludC5fdmFsaWRhdGUodGhpcy5sYXRpdHVkZSwgdGhpcy5sb25naXR1ZGUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgXCJfX3R5cGVcIjogXCJHZW9Qb2ludFwiLFxuICAgICAgICBsYXRpdHVkZTogdGhpcy5sYXRpdHVkZSxcbiAgICAgICAgbG9uZ2l0dWRlOiB0aGlzLmxvbmdpdHVkZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdGFuY2UgZnJvbSB0aGlzIEdlb1BvaW50IHRvIGFub3RoZXIgaW4gcmFkaWFucy5cbiAgICAgKiBAcGFyYW0ge0FWLkdlb1BvaW50fSBwb2ludCB0aGUgb3RoZXIgQVYuR2VvUG9pbnQuXG4gICAgICogQHJldHVybiB7TnVtYmVyfVxuICAgICAqL1xuICAgIHJhZGlhbnNUbzogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgIHZhciBkMnIgPSBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICB2YXIgbGF0MXJhZCA9IHRoaXMubGF0aXR1ZGUgKiBkMnI7XG4gICAgICB2YXIgbG9uZzFyYWQgPSB0aGlzLmxvbmdpdHVkZSAqIGQycjtcbiAgICAgIHZhciBsYXQycmFkID0gcG9pbnQubGF0aXR1ZGUgKiBkMnI7XG4gICAgICB2YXIgbG9uZzJyYWQgPSBwb2ludC5sb25naXR1ZGUgKiBkMnI7XG4gICAgICB2YXIgZGVsdGFMYXQgPSBsYXQxcmFkIC0gbGF0MnJhZDtcbiAgICAgIHZhciBkZWx0YUxvbmcgPSBsb25nMXJhZCAtIGxvbmcycmFkO1xuICAgICAgdmFyIHNpbkRlbHRhTGF0RGl2MiA9IE1hdGguc2luKGRlbHRhTGF0IC8gMik7XG4gICAgICB2YXIgc2luRGVsdGFMb25nRGl2MiA9IE1hdGguc2luKGRlbHRhTG9uZyAvIDIpO1xuICAgICAgLy8gU3F1YXJlIG9mIGhhbGYgdGhlIHN0cmFpZ2h0IGxpbmUgY2hvcmQgZGlzdGFuY2UgYmV0d2VlbiBib3RoIHBvaW50cy5cbiAgICAgIHZhciBhID0gKChzaW5EZWx0YUxhdERpdjIgKiBzaW5EZWx0YUxhdERpdjIpICtcbiAgICAgICAgICAgICAgIChNYXRoLmNvcyhsYXQxcmFkKSAqIE1hdGguY29zKGxhdDJyYWQpICpcbiAgICAgICAgICAgICAgICBzaW5EZWx0YUxvbmdEaXYyICogc2luRGVsdGFMb25nRGl2MikpO1xuICAgICAgYSA9IE1hdGgubWluKDEuMCwgYSk7XG4gICAgICByZXR1cm4gMiAqIE1hdGguYXNpbihNYXRoLnNxcnQoYSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSBmcm9tIHRoaXMgR2VvUG9pbnQgdG8gYW5vdGhlciBpbiBraWxvbWV0ZXJzLlxuICAgICAqIEBwYXJhbSB7QVYuR2VvUG9pbnR9IHBvaW50IHRoZSBvdGhlciBBVi5HZW9Qb2ludC5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAga2lsb21ldGVyc1RvOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFkaWFuc1RvKHBvaW50KSAqIDYzNzEuMDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGlzdGFuY2UgZnJvbSB0aGlzIEdlb1BvaW50IHRvIGFub3RoZXIgaW4gbWlsZXMuXG4gICAgICogQHBhcmFtIHtBVi5HZW9Qb2ludH0gcG9pbnQgdGhlIG90aGVyIEFWLkdlb1BvaW50LlxuICAgICAqIEByZXR1cm4ge051bWJlcn1cbiAgICAgKi9cbiAgICBtaWxlc1RvOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgcmV0dXJuIHRoaXMucmFkaWFuc1RvKHBvaW50KSAqIDM5NTguODtcbiAgICB9XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9nZW9wb2ludC5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbi8qZ2xvYmFsIF86IGZhbHNlLCBkb2N1bWVudDogZmFsc2UsIHdpbmRvdzogZmFsc2UsIG5hdmlnYXRvcjogZmFsc2UgKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQVYpIHtcbiAgLyoqXG4gICAqIEhpc3Rvcnkgc2VydmVzIGFzIGEgZ2xvYmFsIHJvdXRlciAocGVyIGZyYW1lKSB0byBoYW5kbGUgaGFzaGNoYW5nZVxuICAgKiBldmVudHMgb3IgcHVzaFN0YXRlLCBtYXRjaCB0aGUgYXBwcm9wcmlhdGUgcm91dGUsIGFuZCB0cmlnZ2VyXG4gICAqIGNhbGxiYWNrcy4gWW91IHNob3VsZG4ndCBldmVyIGhhdmUgdG8gY3JlYXRlIG9uZSBvZiB0aGVzZSB5b3Vyc2VsZlxuICAgKiDigJQgeW91IHNob3VsZCB1c2UgdGhlIHJlZmVyZW5jZSB0byA8Y29kZT5BVi5oaXN0b3J5PC9jb2RlPlxuICAgKiB0aGF0IHdpbGwgYmUgY3JlYXRlZCBmb3IgeW91IGF1dG9tYXRpY2FsbHkgaWYgeW91IG1ha2UgdXNlIG9mXG4gICAqIFJvdXRlcnMgd2l0aCByb3V0ZXMuXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKiA8cD5BIGZvcmsgb2YgQmFja2JvbmUuSGlzdG9yeSwgcHJvdmlkZWQgZm9yIHlvdXIgY29udmVuaWVuY2UuICBJZiB5b3VcbiAgICogdXNlIHRoaXMgY2xhc3MsIHlvdSBtdXN0IGFsc28gaW5jbHVkZSBqUXVlcnksIG9yIGFub3RoZXIgbGlicmFyeVxuICAgKiB0aGF0IHByb3ZpZGVzIGEgalF1ZXJ5LWNvbXBhdGlibGUgJCBmdW5jdGlvbi4gIEZvciBtb3JlIGluZm9ybWF0aW9uLFxuICAgKiBzZWUgdGhlIDxhIGhyZWY9XCJodHRwOi8vZG9jdW1lbnRjbG91ZC5naXRodWIuY29tL2JhY2tib25lLyNIaXN0b3J5XCI+XG4gICAqIEJhY2tib25lIGRvY3VtZW50YXRpb248L2E+LjwvcD5cbiAgICogPHA+PHN0cm9uZz48ZW0+QXZhaWxhYmxlIGluIHRoZSBjbGllbnQgU0RLIG9ubHkuPC9lbT48L3N0cm9uZz48L3A+XG4gICAqL1xuICBBVi5IaXN0b3J5ID0gZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS53YXJuKFwiQVYuSGlzdG9yeSBpcyBkZXByZWNhdGVkLCBwbGVhc2UgZG9uJ3QgdXNlIGl0IGFueW1vcmUuXCIpO1xuICAgIHRoaXMuaGFuZGxlcnMgPSBbXTtcbiAgICBfLmJpbmRBbGwodGhpcywgJ2NoZWNrVXJsJyk7XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IGZvciBjbGVhbmluZyBsZWFkaW5nIGhhc2hlcyBhbmQgc2xhc2hlcyAuXG4gIHZhciByb3V0ZVN0cmlwcGVyID0gL15bI1xcL10vO1xuXG4gIC8vIENhY2hlZCByZWdleCBmb3IgZGV0ZWN0aW5nIE1TSUUuXG4gIHZhciBpc0V4cGxvcmVyID0gL21zaWUgW1xcdy5dKy87XG5cbiAgLy8gSGFzIHRoZSBoaXN0b3J5IGhhbmRsaW5nIGFscmVhZHkgYmVlbiBzdGFydGVkP1xuICBBVi5IaXN0b3J5LnN0YXJ0ZWQgPSBmYWxzZTtcblxuICAvLyBTZXQgdXAgYWxsIGluaGVyaXRhYmxlICoqQVYuSGlzdG9yeSoqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKEFWLkhpc3RvcnkucHJvdG90eXBlLCBBVi5FdmVudHMsXG4gICAgICAgICAgIC8qKiBAbGVuZHMgQVYuSGlzdG9yeS5wcm90b3R5cGUgKi8ge1xuXG4gICAgLy8gVGhlIGRlZmF1bHQgaW50ZXJ2YWwgdG8gcG9sbCBmb3IgaGFzaCBjaGFuZ2VzLCBpZiBuZWNlc3NhcnksIGlzXG4gICAgLy8gdHdlbnR5IHRpbWVzIGEgc2Vjb25kLlxuICAgIGludGVydmFsOiA1MCxcblxuICAgIC8vIEdldHMgdGhlIHRydWUgaGFzaCB2YWx1ZS4gQ2Fubm90IHVzZSBsb2NhdGlvbi5oYXNoIGRpcmVjdGx5IGR1ZSB0byBidWdcbiAgICAvLyBpbiBGaXJlZm94IHdoZXJlIGxvY2F0aW9uLmhhc2ggd2lsbCBhbHdheXMgYmUgZGVjb2RlZC5cbiAgICBnZXRIYXNoOiBmdW5jdGlvbih3aW5kb3dPdmVycmlkZSkge1xuICAgICAgdmFyIGxvYyA9IHdpbmRvd092ZXJyaWRlID8gd2luZG93T3ZlcnJpZGUubG9jYXRpb24gOiB3aW5kb3cubG9jYXRpb247XG4gICAgICB2YXIgbWF0Y2ggPSBsb2MuaHJlZi5tYXRjaCgvIyguKikkLyk7XG4gICAgICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGNyb3NzLWJyb3dzZXIgbm9ybWFsaXplZCBVUkwgZnJhZ21lbnQsIGVpdGhlciBmcm9tIHRoZSBVUkwsXG4gICAgLy8gdGhlIGhhc2gsIG9yIHRoZSBvdmVycmlkZS5cbiAgICBnZXRGcmFnbWVudDogZnVuY3Rpb24oZnJhZ21lbnQsIGZvcmNlUHVzaFN0YXRlKSB7XG4gICAgICBpZiAoQVYuX2lzTnVsbE9yVW5kZWZpbmVkKGZyYWdtZW50KSkge1xuICAgICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlIHx8IGZvcmNlUHVzaFN0YXRlKSB7XG4gICAgICAgICAgZnJhZ21lbnQgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICAgICAgdmFyIHNlYXJjaCA9IHdpbmRvdy5sb2NhdGlvbi5zZWFyY2g7XG4gICAgICAgICAgaWYgKHNlYXJjaCkge1xuICAgICAgICAgICAgZnJhZ21lbnQgKz0gc2VhcmNoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmcmFnbWVudCA9IHRoaXMuZ2V0SGFzaCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWZyYWdtZW50LmluZGV4T2YodGhpcy5vcHRpb25zLnJvb3QpKSB7XG4gICAgICAgIGZyYWdtZW50ID0gZnJhZ21lbnQuc3Vic3RyKHRoaXMub3B0aW9ucy5yb290Lmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnJhZ21lbnQucmVwbGFjZShyb3V0ZVN0cmlwcGVyLCAnJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFN0YXJ0IHRoZSBoYXNoIGNoYW5nZSBoYW5kbGluZywgcmV0dXJuaW5nIGB0cnVlYCBpZiB0aGUgY3VycmVudFxuICAgICAqIFVSTCBtYXRjaGVzIGFuIGV4aXN0aW5nIHJvdXRlLCBhbmQgYGZhbHNlYCBvdGhlcndpc2UuXG4gICAgICovXG4gICAgc3RhcnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChBVi5IaXN0b3J5LnN0YXJ0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQVYuaGlzdG9yeSBoYXMgYWxyZWFkeSBiZWVuIHN0YXJ0ZWRcIik7XG4gICAgICB9XG4gICAgICBBVi5IaXN0b3J5LnN0YXJ0ZWQgPSB0cnVlO1xuXG4gICAgICAvLyBGaWd1cmUgb3V0IHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24uIERvIHdlIG5lZWQgYW4gaWZyYW1lP1xuICAgICAgLy8gSXMgcHVzaFN0YXRlIGRlc2lyZWQgLi4uIGlzIGl0IGF2YWlsYWJsZT9cbiAgICAgIHRoaXMub3B0aW9ucyA9IF8uZXh0ZW5kKHt9LCB7cm9vdDogJy8nfSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuX3dhbnRzSGFzaENoYW5nZSA9IHRoaXMub3B0aW9ucy5oYXNoQ2hhbmdlICE9PSBmYWxzZTtcbiAgICAgIHRoaXMuX3dhbnRzUHVzaFN0YXRlID0gISF0aGlzLm9wdGlvbnMucHVzaFN0YXRlO1xuICAgICAgdGhpcy5faGFzUHVzaFN0YXRlID0gISEodGhpcy5vcHRpb25zLnB1c2hTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93Lmhpc3RvcnkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSk7XG4gICAgICB2YXIgZnJhZ21lbnQgPSB0aGlzLmdldEZyYWdtZW50KCk7XG4gICAgICB2YXIgZG9jTW9kZSA9IGRvY3VtZW50LmRvY3VtZW50TW9kZTtcbiAgICAgIHZhciBvbGRJRSA9IChpc0V4cGxvcmVyLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKSAmJlxuICAgICAgICAgICAgICAgICAgICghZG9jTW9kZSB8fCBkb2NNb2RlIDw9IDcpKTtcblxuICAgICAgaWYgKG9sZElFKSB7XG4gICAgICAgIHRoaXMuaWZyYW1lID0gQVYuJCgnPGlmcmFtZSBzcmM9XCJqYXZhc2NyaXB0OjBcIiB0YWJpbmRleD1cIi0xXCIgLz4nKVxuICAgICAgICAgICAgICAgICAgICAgIC5oaWRlKCkuYXBwZW5kVG8oJ2JvZHknKVswXS5jb250ZW50V2luZG93O1xuICAgICAgICB0aGlzLm5hdmlnYXRlKGZyYWdtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gRGVwZW5kaW5nIG9uIHdoZXRoZXIgd2UncmUgdXNpbmcgcHVzaFN0YXRlIG9yIGhhc2hlcywgYW5kIHdoZXRoZXJcbiAgICAgIC8vICdvbmhhc2hjaGFuZ2UnIGlzIHN1cHBvcnRlZCwgZGV0ZXJtaW5lIGhvdyB3ZSBjaGVjayB0aGUgVVJMIHN0YXRlLlxuICAgICAgaWYgKHRoaXMuX2hhc1B1c2hTdGF0ZSkge1xuICAgICAgICBBVi4kKHdpbmRvdykuYmluZCgncG9wc3RhdGUnLCB0aGlzLmNoZWNrVXJsKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlICYmXG4gICAgICAgICAgICAgICAgICgnb25oYXNoY2hhbmdlJyBpbiB3aW5kb3cpICYmXG4gICAgICAgICAgICAgICAgICFvbGRJRSkge1xuICAgICAgICBBVi4kKHdpbmRvdykuYmluZCgnaGFzaGNoYW5nZScsIHRoaXMuY2hlY2tVcmwpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl93YW50c0hhc2hDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tVcmxJbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbCh0aGlzLmNoZWNrVXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW50ZXJ2YWwpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBjaGFuZ2UgdGhlIGJhc2UgdXJsLCBmb3IgYSBwdXNoU3RhdGUgbGlua1xuICAgICAgLy8gb3BlbmVkIGJ5IGEgbm9uLXB1c2hTdGF0ZSBicm93c2VyLlxuICAgICAgdGhpcy5mcmFnbWVudCA9IGZyYWdtZW50O1xuICAgICAgdmFyIGxvYyA9IHdpbmRvdy5sb2NhdGlvbjtcbiAgICAgIHZhciBhdFJvb3QgID0gbG9jLnBhdGhuYW1lID09PSB0aGlzLm9wdGlvbnMucm9vdDtcblxuICAgICAgLy8gSWYgd2UndmUgc3RhcnRlZCBvZmYgd2l0aCBhIHJvdXRlIGZyb20gYSBgcHVzaFN0YXRlYC1lbmFibGVkIGJyb3dzZXIsXG4gICAgICAvLyBidXQgd2UncmUgY3VycmVudGx5IGluIGEgYnJvd3NlciB0aGF0IGRvZXNuJ3Qgc3VwcG9ydCBpdC4uLlxuICAgICAgaWYgKHRoaXMuX3dhbnRzSGFzaENoYW5nZSAmJlxuICAgICAgICAgIHRoaXMuX3dhbnRzUHVzaFN0YXRlICYmXG4gICAgICAgICAgIXRoaXMuX2hhc1B1c2hTdGF0ZSAmJlxuICAgICAgICAgICFhdFJvb3QpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQobnVsbCwgdHJ1ZSk7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZXBsYWNlKHRoaXMub3B0aW9ucy5yb290ICsgJyMnICsgdGhpcy5mcmFnbWVudCk7XG4gICAgICAgIC8vIFJldHVybiBpbW1lZGlhdGVseSBhcyBicm93c2VyIHdpbGwgZG8gcmVkaXJlY3QgdG8gbmV3IHVybFxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgLy8gT3IgaWYgd2UndmUgc3RhcnRlZCBvdXQgd2l0aCBhIGhhc2gtYmFzZWQgcm91dGUsIGJ1dCB3ZSdyZSBjdXJyZW50bHlcbiAgICAgIC8vIGluIGEgYnJvd3NlciB3aGVyZSBpdCBjb3VsZCBiZSBgcHVzaFN0YXRlYC1iYXNlZCBpbnN0ZWFkLi4uXG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX3dhbnRzUHVzaFN0YXRlICYmXG4gICAgICAgICAgICAgICAgIHRoaXMuX2hhc1B1c2hTdGF0ZSAmJlxuICAgICAgICAgICAgICAgICBhdFJvb3QgJiZcbiAgICAgICAgICAgICAgICAgbG9jLmhhc2gpIHtcbiAgICAgICAgdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0SGFzaCgpLnJlcGxhY2Uocm91dGVTdHJpcHBlciwgJycpO1xuICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoe30sIGRvY3VtZW50LnRpdGxlLFxuICAgICAgICAgICAgbG9jLnByb3RvY29sICsgJy8vJyArIGxvYy5ob3N0ICsgdGhpcy5vcHRpb25zLnJvb3QgKyB0aGlzLmZyYWdtZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRVcmwoKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gRGlzYWJsZSBBVi5oaXN0b3J5LCBwZXJoYXBzIHRlbXBvcmFyaWx5LiBOb3QgdXNlZnVsIGluIGEgcmVhbCBhcHAsXG4gICAgLy8gYnV0IHBvc3NpYmx5IHVzZWZ1bCBmb3IgdW5pdCB0ZXN0aW5nIFJvdXRlcnMuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBBVi4kKHdpbmRvdykudW5iaW5kKCdwb3BzdGF0ZScsIHRoaXMuY2hlY2tVcmwpXG4gICAgICAgICAgICAgICAgICAgICAudW5iaW5kKCdoYXNoY2hhbmdlJywgdGhpcy5jaGVja1VybCk7XG4gICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja1VybEludGVydmFsKTtcbiAgICAgIEFWLkhpc3Rvcnkuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYSByb3V0ZSB0byBiZSB0ZXN0ZWQgd2hlbiB0aGUgZnJhZ21lbnQgY2hhbmdlcy4gUm91dGVzIGFkZGVkIGxhdGVyXG4gICAgLy8gbWF5IG92ZXJyaWRlIHByZXZpb3VzIHJvdXRlcy5cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLmhhbmRsZXJzLnVuc2hpZnQoe3JvdXRlOiByb3V0ZSwgY2FsbGJhY2s6IGNhbGxiYWNrfSk7XG4gICAgfSxcblxuICAgIC8vIENoZWNrcyB0aGUgY3VycmVudCBVUkwgdG8gc2VlIGlmIGl0IGhhcyBjaGFuZ2VkLCBhbmQgaWYgaXQgaGFzLFxuICAgIC8vIGNhbGxzIGBsb2FkVXJsYCwgbm9ybWFsaXppbmcgYWNyb3NzIHRoZSBoaWRkZW4gaWZyYW1lLlxuICAgIGNoZWNrVXJsOiBmdW5jdGlvbihlKSB7XG4gICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoKTtcbiAgICAgIGlmIChjdXJyZW50ID09PSB0aGlzLmZyYWdtZW50ICYmIHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIGN1cnJlbnQgPSB0aGlzLmdldEZyYWdtZW50KHRoaXMuZ2V0SGFzaCh0aGlzLmlmcmFtZSkpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnQgPT09IHRoaXMuZnJhZ21lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaWZyYW1lKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGUoY3VycmVudCk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMubG9hZFVybCgpKSB7XG4gICAgICAgIHRoaXMubG9hZFVybCh0aGlzLmdldEhhc2goKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIEF0dGVtcHQgdG8gbG9hZCB0aGUgY3VycmVudCBVUkwgZnJhZ21lbnQuIElmIGEgcm91dGUgc3VjY2VlZHMgd2l0aCBhXG4gICAgLy8gbWF0Y2gsIHJldHVybnMgYHRydWVgLiBJZiBubyBkZWZpbmVkIHJvdXRlcyBtYXRjaGVzIHRoZSBmcmFnbWVudCxcbiAgICAvLyByZXR1cm5zIGBmYWxzZWAuXG4gICAgbG9hZFVybDogZnVuY3Rpb24oZnJhZ21lbnRPdmVycmlkZSkge1xuICAgICAgdmFyIGZyYWdtZW50ID0gdGhpcy5mcmFnbWVudCA9IHRoaXMuZ2V0RnJhZ21lbnQoZnJhZ21lbnRPdmVycmlkZSk7XG4gICAgICB2YXIgbWF0Y2hlZCA9IF8uYW55KHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uKGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIucm91dGUudGVzdChmcmFnbWVudCkpIHtcbiAgICAgICAgICBoYW5kbGVyLmNhbGxiYWNrKGZyYWdtZW50KTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbWF0Y2hlZDtcbiAgICB9LFxuXG4gICAgLy8gU2F2ZSBhIGZyYWdtZW50IGludG8gdGhlIGhhc2ggaGlzdG9yeSwgb3IgcmVwbGFjZSB0aGUgVVJMIHN0YXRlIGlmIHRoZVxuICAgIC8vICdyZXBsYWNlJyBvcHRpb24gaXMgcGFzc2VkLiBZb3UgYXJlIHJlc3BvbnNpYmxlIGZvciBwcm9wZXJseSBVUkwtZW5jb2RpbmdcbiAgICAvLyB0aGUgZnJhZ21lbnQgaW4gYWR2YW5jZS5cbiAgICAvL1xuICAgIC8vIFRoZSBvcHRpb25zIG9iamVjdCBjYW4gY29udGFpbiBgdHJpZ2dlcjogdHJ1ZWAgaWYgeW91IHdpc2ggdG8gaGF2ZSB0aGVcbiAgICAvLyByb3V0ZSBjYWxsYmFjayBiZSBmaXJlZCAobm90IHVzdWFsbHkgZGVzaXJhYmxlKSwgb3IgYHJlcGxhY2U6IHRydWVgLCBpZlxuICAgIC8vIHlvdSB3aXNoIHRvIG1vZGlmeSB0aGUgY3VycmVudCBVUkwgd2l0aG91dCBhZGRpbmcgYW4gZW50cnkgdG8gdGhlXG4gICAgLy8gaGlzdG9yeS5cbiAgICBuYXZpZ2F0ZTogZnVuY3Rpb24oZnJhZ21lbnQsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghQVYuSGlzdG9yeS5zdGFydGVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmICghb3B0aW9ucyB8fCBvcHRpb25zID09PSB0cnVlKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7dHJpZ2dlcjogb3B0aW9uc307XG4gICAgICB9XG4gICAgICB2YXIgZnJhZyA9IChmcmFnbWVudCB8fCAnJykucmVwbGFjZShyb3V0ZVN0cmlwcGVyLCAnJyk7XG4gICAgICBpZiAodGhpcy5mcmFnbWVudCA9PT0gZnJhZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHB1c2hTdGF0ZSBpcyBhdmFpbGFibGUsIHdlIHVzZSBpdCB0byBzZXQgdGhlIGZyYWdtZW50IGFzIGEgcmVhbCBVUkwuXG4gICAgICBpZiAodGhpcy5faGFzUHVzaFN0YXRlKSB7XG4gICAgICAgIGlmIChmcmFnLmluZGV4T2YodGhpcy5vcHRpb25zLnJvb3QpICE9PSAwKSB7XG4gICAgICAgICAgZnJhZyA9IHRoaXMub3B0aW9ucy5yb290ICsgZnJhZztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZztcbiAgICAgICAgdmFyIHJlcGxhY2VPclB1c2ggPSBvcHRpb25zLnJlcGxhY2UgPyAncmVwbGFjZVN0YXRlJyA6ICdwdXNoU3RhdGUnO1xuICAgICAgICB3aW5kb3cuaGlzdG9yeVtyZXBsYWNlT3JQdXNoXSh7fSwgZG9jdW1lbnQudGl0bGUsIGZyYWcpO1xuXG4gICAgICAvLyBJZiBoYXNoIGNoYW5nZXMgaGF2ZW4ndCBiZWVuIGV4cGxpY2l0bHkgZGlzYWJsZWQsIHVwZGF0ZSB0aGUgaGFzaFxuICAgICAgLy8gZnJhZ21lbnQgdG8gc3RvcmUgaGlzdG9yeS5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fd2FudHNIYXNoQ2hhbmdlKSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnO1xuICAgICAgICB0aGlzLl91cGRhdGVIYXNoKHdpbmRvdy5sb2NhdGlvbiwgZnJhZywgb3B0aW9ucy5yZXBsYWNlKTtcbiAgICAgICAgaWYgKHRoaXMuaWZyYW1lICYmXG4gICAgICAgICAgICAoZnJhZyAhPT0gdGhpcy5nZXRGcmFnbWVudCh0aGlzLmdldEhhc2godGhpcy5pZnJhbWUpKSkpIHtcbiAgICAgICAgICAvLyBPcGVuaW5nIGFuZCBjbG9zaW5nIHRoZSBpZnJhbWUgdHJpY2tzIElFNyBhbmQgZWFybGllclxuICAgICAgICAgIC8vIHRvIHB1c2ggYSBoaXN0b3J5IGVudHJ5IG9uIGhhc2gtdGFnIGNoYW5nZS5cbiAgICAgICAgICAvLyBXaGVuIHJlcGxhY2UgaXMgdHJ1ZSwgd2UgZG9uJ3Qgd2FudCB0aGlzLlxuICAgICAgICAgIGlmICghb3B0aW9ucy5yZXBsYWNlKSB7XG4gICAgICAgICAgICB0aGlzLmlmcmFtZS5kb2N1bWVudC5vcGVuKCkuY2xvc2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fdXBkYXRlSGFzaCh0aGlzLmlmcmFtZS5sb2NhdGlvbiwgZnJhZywgb3B0aW9ucy5yZXBsYWNlKTtcbiAgICAgICAgfVxuXG4gICAgICAvLyBJZiB5b3UndmUgdG9sZCB1cyB0aGF0IHlvdSBleHBsaWNpdGx5IGRvbid0IHdhbnQgZmFsbGJhY2sgaGFzaGNoYW5nZS1cbiAgICAgIC8vIGJhc2VkIGhpc3RvcnksIHRoZW4gYG5hdmlnYXRlYCBiZWNvbWVzIGEgcGFnZSByZWZyZXNoLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmFzc2lnbih0aGlzLm9wdGlvbnMucm9vdCArIGZyYWdtZW50KTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLnRyaWdnZXIpIHtcbiAgICAgICAgdGhpcy5sb2FkVXJsKGZyYWdtZW50KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLy8gVXBkYXRlIHRoZSBoYXNoIGxvY2F0aW9uLCBlaXRoZXIgcmVwbGFjaW5nIHRoZSBjdXJyZW50IGVudHJ5LCBvciBhZGRpbmdcbiAgICAvLyBhIG5ldyBvbmUgdG8gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICBfdXBkYXRlSGFzaDogZnVuY3Rpb24obG9jYXRpb24sIGZyYWdtZW50LCByZXBsYWNlKSB7XG4gICAgICBpZiAocmVwbGFjZSkge1xuICAgICAgICB2YXIgcyA9IGxvY2F0aW9uLnRvU3RyaW5nKCkucmVwbGFjZSgvKGphdmFzY3JpcHQ6fCMpLiokLywgJycpO1xuICAgICAgICBsb2NhdGlvbi5yZXBsYWNlKHMgKyAnIycgKyBmcmFnbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2NhdGlvbi5oYXNoID0gZnJhZ21lbnQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2hpc3RvcnkuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEFWKSB7XG4gIC8qKlxuICAgKiBAbmFtZXNwYWNlIOWMheWQq+S6huS9v+eUqOS6hiBMZWFuQ2xvdWRcbiAgICogIDxhIGhyZWY9Jy9kb2NzL2xlYW5pbnNpZ2h0X2d1aWRlLmh0bWwnPuemu+e6v+aVsOaNruWIhuaekOWKn+iDvTwvYT7nmoTlh73mlbDjgIJcbiAgICogPHA+PHN0cm9uZz48ZW0+XG4gICAqICAg6YOo5YiG5Ye95pWw5LuF5Zyo5LqR5byV5pOO6L+Q6KGM546v5aKD5LiL5pyJ5pWI44CCXG4gICAqIDwvZW0+PC9zdHJvbmc+PC9wPlxuICAgKi9cbiAgQVYuSW5zaWdodCA9IEFWLkluc2lnaHQgfHwge307XG5cbiAgXy5leHRlbmQoQVYuSW5zaWdodCwgLyoqIEBsZW5kcyBBVi5JbnNpZ2h0ICovIHtcblxuICAgIC8qKlxuICAgICAqIOW8gOWni+S4gOS4qiBJbnNpZ2h0IOS7u+WKoeOAgue7k+aenOmHjOWwhui/lOWbniBKb2IgaWTvvIzkvaDlj6/ku6Xmi7/lvpfliLDnmoQgaWQg5L2/55SoXG4gICAgICogQVYuSW5zaWdodC5Kb2JRdWVyeSDmn6Xor6Lku7vliqHnirbmgIHlkoznu5PmnpzjgIJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gam9iQ29uZmlnIOS7u+WKoemFjee9rueahCBKU09OIOWvueixoe+8jOS+i+Wmgu+8mjxjb2RlPjxwcmU+XG4gICAgICogICAgICAgICAgICAgICAgICAgeyBcInNxbFwiIDogXCJzZWxlY3QgY291bnQoKikgYXMgYyxnZW5kZXIgZnJvbSBfVXNlciBncm91cCBieSBnZW5kZXJcIixcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIFwic2F2ZUFzXCI6IHtcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzTmFtZVwiIDogXCJVc2VyR2VuZGVyXCIsXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgXCJsaW1pdFwiOiAxXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAqICAgICAgICAgICAgICAgICAgIH1cbiAgICAgKiAgICAgICAgICAgICAgICAgIDwvcHJlPjwvY29kZT5cbiAgICAgKiAgICAgICAgICAgICAgIHNxbCDmjIflrprku7vliqHmiafooYznmoQgU1FMIOivreWPpe+8jCBzYXZlQXPvvIjlj6/pgInvvIkg5oyH5a6a5bCG57uT5p6c5L+d5a2Y5Zyo5ZOq5byg6KGo6YeM77yMbGltaXQg5pyA5aSnIDEwMDDjgIJcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0XG4gICAgICogb3B0aW9ucy5zdWNjZXNzLCBpZiBzZXQsIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRvIGhhbmRsZSBhIHN1Y2Nlc3NmdWxcbiAgICAgKiBjYWxsIHRvIGEgY2xvdWQgZnVuY3Rpb24uICBvcHRpb25zLmVycm9yIHNob3VsZCBiZSBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBoYW5kbGVzIGFuIGVycm9yIHJ1bm5pbmcgdGhlIGNsb3VkIGZ1bmN0aW9uLiAgQm90aCBmdW5jdGlvbnMgYXJlXG4gICAgICogb3B0aW9uYWwuICBCb3RoIGZ1bmN0aW9ucyB0YWtlIGEgc2luZ2xlIGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0XG4gICAgICogb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXJ0Sm9iOiBmdW5jdGlvbihqb2JDb25maWcsIG9wdGlvbnMpIHtcbiAgICAgIGlmKCFqb2JDb25maWcgfHwgIWpvYkNvbmZpZy5zcWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSB0aGUgc3FsIHRvIHJ1biB0aGUgam9iLicpO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSB7XG4gICAgICAgIGpvYkNvbmZpZzogam9iQ29uZmlnLFxuICAgICAgICBhcHBJZDogQVYuYXBwbGljYXRpb25JZFxuICAgICAgfTtcbiAgICAgIHZhciByZXF1ZXN0ID0gQVYuX3JlcXVlc3QoXCJiaWdxdWVyeVwiLCAnam9icycsIG51bGwsICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQVYuX2VuY29kZShkYXRhLCBudWxsLCB0cnVlKSk7XG5cbiAgICAgIHJldHVybiByZXF1ZXN0LnRoZW4oZnVuY3Rpb24ocmVzcCkge1xuICAgICAgICByZXR1cm4gQVYuX2RlY29kZShudWxsLCByZXNwKS5pZDtcbiAgICAgIH0pLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiDnm5HlkKwgSW5zaWdodCDku7vliqHkuovku7bvvIznm67liY3ku4XmlK/mjIEgZW5kIOS6i+S7tu+8jOihqOekuuS7u+WKoeWujOaIkOOAglxuICAgICAqICA8cD48c3Ryb25nPjxlbT5cbiAgICAgKiAgICAg5LuF5Zyo5LqR5byV5pOO6L+Q6KGM546v5aKD5LiL5pyJ5pWI44CCXG4gICAgICogIDwvZW0+PC9zdHJvbmc+PC9wPlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCDnm5HlkKznmoTkuovku7bvvIznm67liY3ku4XmlK/mjIEgJ2VuZCcg77yM6KGo56S65Lu75Yqh5a6M5oiQXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0g55uR5ZCs5Zue6LCD5Ye95pWw77yM5o6l5pS2IChlcnIsIGlkKSDkuKTkuKrlj4LmlbDvvIxlcnIg6KGo56S66ZSZ6K+v5L+h5oGv77yMXG4gICAgICogICAgICAgICAgICAgICAgICAgaWQg6KGo56S65Lu75YqhIGlk44CC5o6l5LiL5p2l5L2g5Y+v5Lul5ou/6L+Z5LiqIGlkIOS9v+eUqEFWLkluc2lnaHQuSm9iUXVlcnkg5p+l6K+i5Lu75Yqh54q25oCB5ZKM57uT5p6c44CCXG4gICAgICpcbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24oZXZlbnQsIGNiKSB7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICog5Yib5bu65LiA5Liq5a+56LGh77yM55So5LqO5p+l6K+iIEluc2lnaHQg5Lu75Yqh54q25oCB5ZKM57uT5p6c44CCXG4gICAqIEBjbGFzc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQg5Lu75YqhIGlkXG4gICAqIEBzaW5jZSAwLjUuNVxuICAgKi9cbiAgQVYuSW5zaWdodC5Kb2JRdWVyeSA9IGZ1bmN0aW9uKGlkLCBjbGFzc05hbWUpIHtcbiAgICBpZighaWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIHByb3ZpZGUgdGhlIGpvYiBpZC4nKTtcbiAgICB9XG4gICAgdGhpcy5pZCA9IGlkO1xuICAgIHRoaXMuY2xhc3NOYW1lID0gY2xhc3NOYW1lO1xuICAgIHRoaXMuX3NraXAgPSAwO1xuICAgIHRoaXMuX2xpbWl0ID0gMTAwO1xuICB9O1xuXG4gIEFWLkluc2lnaHQuSm9iUXVlcnkucHJvdG90eXBlID0ge1xuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gc2tpcCBiZWZvcmUgcmV0dXJuaW5nIGFueSByZXN1bHRzLlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciBwYWdpbmF0aW9uLlxuICAgICAqIERlZmF1bHQgaXMgdG8gc2tpcCB6ZXJvIHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gdGhlIG51bWJlciBvZiByZXN1bHRzIHRvIHNraXAuXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBza2lwOiBmdW5jdGlvbihuKSB7XG4gICAgICB0aGlzLl9za2lwID0gbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaW1pdCBvZiB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuLiBUaGUgZGVmYXVsdCBsaW1pdCBpc1xuICAgICAqIDEwMCwgd2l0aCBhIG1heGltdW0gb2YgMTAwMCByZXN1bHRzIGJlaW5nIHJldHVybmVkIGF0IGEgdGltZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gbGltaXQgdG8uXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBsaW1pdDogZnVuY3Rpb24obikge1xuICAgICAgdGhpcy5fbGltaXQgPSBuO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIOafpeivouS7u+WKoeeKtuaAgeWSjOe7k+aenO+8jOS7u+WKoee7k+aenOS4uuS4gOS4qiBKU09OIOWvueixoe+8jOWMheaLrCBzdGF0dXMg6KGo56S65Lu75Yqh54q25oCB77yMIHRvdGFsQ291bnQg6KGo56S65oC75pWw77yMXG4gICAgICogcmVzdWx0cyDmlbDnu4TooajnpLrku7vliqHnu5PmnpzmlbDnu4TvvIxwcmV2aWV3Q291bnQg6KGo56S65Y+v5Lul6L+U5Zue55qE57uT5p6c5oC75pWw77yM5Lu75Yqh55qE5byA5aeL5ZKM5oiq5q2i5pe26Ze0XG4gICAgICogc3RhcnRUaW1l44CBZW5kVGltZSDnrYnkv6Hmga/jgIJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBvcHRpb25zLnN1Y2Nlc3MsIGlmIHNldCwgc2hvdWxkIGJlIGEgZnVuY3Rpb24gdG8gaGFuZGxlIGEgc3VjY2Vzc2Z1bFxuICAgICAqIGNhbGwgdG8gYSBjbG91ZCBmdW5jdGlvbi4gIG9wdGlvbnMuZXJyb3Igc2hvdWxkIGJlIGEgZnVuY3Rpb24gdGhhdFxuICAgICAqIGhhbmRsZXMgYW4gZXJyb3IgcnVubmluZyB0aGUgY2xvdWQgZnVuY3Rpb24uICBCb3RoIGZ1bmN0aW9ucyBhcmVcbiAgICAgKiBvcHRpb25hbC4gIEJvdGggZnVuY3Rpb25zIHRha2UgYSBzaW5nbGUgYXJndW1lbnQuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgKiBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKi9cbiAgICBmaW5kOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICBza2lwOiB0aGlzLl9za2lwLFxuICAgICAgICBsaW1pdDogdGhpcy5fbGltaXRcbiAgICAgIH07XG5cbiAgICAgIHZhciByZXF1ZXN0ID0gQVYuX3JlcXVlc3QoXCJiaWdxdWVyeVwiLCAnam9icycsIHRoaXMuaWQsIFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gcmVxdWVzdC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIGlmKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIEFWLlByb21pc2UuZXJyb3IobmV3IEFWLkVycm9yKHJlc3BvbnNlLmNvZGUsIHJlc3BvbnNlLmVycm9yKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFWLlByb21pc2UuYXMocmVzcG9uc2UpO1xuICAgICAgfSkuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gICAgfVxuXG4gIH07XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2luc2lnaHQuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xudmFyIFByb21pc2UgPSByZXF1aXJlKCcuL3Byb21pc2UnKTtcbnZhciBsb2NhbFN0b3JhZ2UgPSByZXF1aXJlKCcuL2Jyb3dzZXJpZnktd3JhcHBlci9sb2NhbFN0b3JhZ2UnKTtcblxudmFyIHN5bmNBcGlOYW1lcyA9IFtcbiAgJ2dldEl0ZW0nLFxuICAnc2V0SXRlbScsXG4gICdyZW1vdmVJdGVtJyxcbiAgJ2NsZWFyJ1xuXTtcblxuaWYgKCFsb2NhbFN0b3JhZ2UuYXN5bmMpIHtcbiAgLy8gd3JhcCBzeW5jIGFwaXMgd2l0aCBhc3luYyBvbmVzLlxuICBfKHN5bmNBcGlOYW1lcykuZWFjaChmdW5jdGlvbihhcGlOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2VbYXBpTmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxvY2FsU3RvcmFnZVthcGlOYW1lICsgJ0FzeW5jJ10gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYXMobG9jYWxTdG9yYWdlW2FwaU5hbWVdLmFwcGx5KGxvY2FsU3RvcmFnZSwgYXJndW1lbnRzKSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICBfKHN5bmNBcGlOYW1lcykuZWFjaChmdW5jdGlvbihhcGlOYW1lKSB7XG4gICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2VbYXBpTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGxvY2FsU3RvcmFnZVthcGlOYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N5bmNocm9ub3VzIEFQSSBbJyArIGFwaU5hbWUgKyAnXSBpcyBub3QgYXZhaWxhYmxlIGluIHRoaXMgcnVudGltZS4nKTtcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsb2NhbFN0b3JhZ2U7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL2xvY2Fsc3RvcmFnZS5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbi8vIEFWLk9iamVjdCBpcyBhbmFsb2dvdXMgdG8gdGhlIEphdmEgQVZPYmplY3QuXG4vLyBJdCBhbHNvIGltcGxlbWVudHMgdGhlIHNhbWUgaW50ZXJmYWNlIGFzIGEgQmFja2JvbmUgbW9kZWwuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQVYpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgbW9kZWwgd2l0aCBkZWZpbmVkIGF0dHJpYnV0ZXMuIEEgY2xpZW50IGlkIChjaWQpIGlzXG4gICAqIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVkIGFuZCBhc3NpZ25lZCBmb3IgeW91LlxuICAgKlxuICAgKiA8cD5Zb3Ugd29uJ3Qgbm9ybWFsbHkgY2FsbCB0aGlzIG1ldGhvZCBkaXJlY3RseS4gIEl0IGlzIHJlY29tbWVuZGVkIHRoYXRcbiAgICogeW91IHVzZSBhIHN1YmNsYXNzIG9mIDxjb2RlPkFWLk9iamVjdDwvY29kZT4gaW5zdGVhZCwgY3JlYXRlZCBieSBjYWxsaW5nXG4gICAqIDxjb2RlPmV4dGVuZDwvY29kZT4uPC9wPlxuICAgKlxuICAgKiA8cD5Ib3dldmVyLCBpZiB5b3UgZG9uJ3Qgd2FudCB0byB1c2UgYSBzdWJjbGFzcywgb3IgYXJlbid0IHN1cmUgd2hpY2hcbiAgICogc3ViY2xhc3MgaXMgYXBwcm9wcmlhdGUsIHlvdSBjYW4gdXNlIHRoaXMgZm9ybTo8cHJlPlxuICAgKiAgICAgdmFyIG9iamVjdCA9IG5ldyBBVi5PYmplY3QoXCJDbGFzc05hbWVcIik7XG4gICAqIDwvcHJlPlxuICAgKiBUaGF0IGlzIGJhc2ljYWxseSBlcXVpdmFsZW50IHRvOjxwcmU+XG4gICAqICAgICB2YXIgTXlDbGFzcyA9IEFWLk9iamVjdC5leHRlbmQoXCJDbGFzc05hbWVcIik7XG4gICAqICAgICB2YXIgb2JqZWN0ID0gbmV3IE15Q2xhc3MoKTtcbiAgICogPC9wcmU+PC9wPlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyBUaGUgaW5pdGlhbCBzZXQgb2YgZGF0YSB0byBzdG9yZSBpbiB0aGUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIHNldCBvZiBCYWNrYm9uZS1saWtlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZVxuICAgKiAgICAgb2JqZWN0LiAgVGhlIG9ubHkgb3B0aW9uIGN1cnJlbnRseSBzdXBwb3J0ZWQgaXMgXCJjb2xsZWN0aW9uXCIuXG4gICAqIEBzZWUgQVYuT2JqZWN0LmV4dGVuZFxuICAgKlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICogPHA+VGhlIGZ1bmRhbWVudGFsIHVuaXQgb2YgQVYgZGF0YSwgd2hpY2ggaW1wbGVtZW50cyB0aGUgQmFja2JvbmUgTW9kZWxcbiAgICogaW50ZXJmYWNlLjwvcD5cbiAgICovXG4gIEFWLk9iamVjdCA9IGZ1bmN0aW9uKGF0dHJpYnV0ZXMsIG9wdGlvbnMpIHtcbiAgICAvLyBBbGxvdyBuZXcgQVYuT2JqZWN0KFwiQ2xhc3NOYW1lXCIpIGFzIGEgc2hvcnRjdXQgdG8gX2NyZWF0ZS5cbiAgICBpZiAoXy5pc1N0cmluZyhhdHRyaWJ1dGVzKSkge1xuICAgICAgcmV0dXJuIEFWLk9iamVjdC5fY3JlYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuXG4gICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwge307XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXJzZSkge1xuICAgICAgYXR0cmlidXRlcyA9IHRoaXMucGFyc2UoYXR0cmlidXRlcyk7XG4gICAgfVxuICAgIHZhciBkZWZhdWx0cyA9IEFWLl9nZXRWYWx1ZSh0aGlzLCAnZGVmYXVsdHMnKTtcbiAgICBpZiAoZGVmYXVsdHMpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSBfLmV4dGVuZCh7fSwgZGVmYXVsdHMsIGF0dHJpYnV0ZXMpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNvbGxlY3Rpb24pIHtcbiAgICAgIHRoaXMuY29sbGVjdGlvbiA9IG9wdGlvbnMuY29sbGVjdGlvbjtcbiAgICB9XG5cbiAgICB0aGlzLl9zZXJ2ZXJEYXRhID0ge307ICAvLyBUaGUgbGFzdCBrbm93biBkYXRhIGZvciB0aGlzIG9iamVjdCBmcm9tIGNsb3VkLlxuICAgIHRoaXMuX29wU2V0UXVldWUgPSBbe31dOyAgLy8gTGlzdCBvZiBzZXRzIG9mIGNoYW5nZXMgdG8gdGhlIGRhdGEuXG4gICAgdGhpcy5hdHRyaWJ1dGVzID0ge307ICAvLyBUaGUgYmVzdCBlc3RpbWF0ZSBvZiB0aGlzJ3MgY3VycmVudCBkYXRhLlxuXG4gICAgdGhpcy5faGFzaGVkSlNPTiA9IHt9OyAgLy8gSGFzaCBvZiB2YWx1ZXMgb2YgY29udGFpbmVycyBhdCBsYXN0IHNhdmUuXG4gICAgdGhpcy5fZXNjYXBlZEF0dHJpYnV0ZXMgPSB7fTtcbiAgICB0aGlzLmNpZCA9IF8udW5pcXVlSWQoJ2MnKTtcbiAgICB0aGlzLmNoYW5nZWQgPSB7fTtcbiAgICB0aGlzLl9zaWxlbnQgPSB7fTtcbiAgICB0aGlzLl9wZW5kaW5nID0ge307XG4gICAgaWYgKCF0aGlzLnNldChhdHRyaWJ1dGVzLCB7c2lsZW50OiB0cnVlfSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IGNyZWF0ZSBhbiBpbnZhbGlkIEFWLk9iamVjdFwiKTtcbiAgICB9XG4gICAgdGhpcy5jaGFuZ2VkID0ge307XG4gICAgdGhpcy5fc2lsZW50ID0ge307XG4gICAgdGhpcy5fcGVuZGluZyA9IHt9O1xuICAgIHRoaXMuX2hhc0RhdGEgPSB0cnVlO1xuICAgIHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyA9IF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvKipcbiAgICogQGxlbmRzIEFWLk9iamVjdC5wcm90b3R5cGVcbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IGlkIFRoZSBvYmplY3RJZCBvZiB0aGUgQVYgT2JqZWN0LlxuICAgKi9cblxuICAvKipcbiAgICogU2F2ZXMgdGhlIGdpdmVuIGxpc3Qgb2YgQVYuT2JqZWN0LlxuICAgKiBJZiBhbnkgZXJyb3IgaXMgZW5jb3VudGVyZWQsIHN0b3BzIGFuZCBjYWxscyB0aGUgZXJyb3IgaGFuZGxlci5cbiAgICogVGhlcmUgYXJlIHR3byB3YXlzIHlvdSBjYW4gY2FsbCB0aGlzIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBUaGUgQmFja2JvbmUgd2F5OjxwcmU+XG4gICAqICAgQVYuT2JqZWN0LnNhdmVBbGwoW29iamVjdDEsIG9iamVjdDIsIC4uLl0sIHtcbiAgICogICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGxpc3QpIHtcbiAgICogICAgICAgLy8gQWxsIHRoZSBvYmplY3RzIHdlcmUgc2F2ZWQuXG4gICAqICAgICB9LFxuICAgKiAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAqICAgICAgIC8vIEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHNhdmluZyBvbmUgb2YgdGhlIG9iamVjdHMuXG4gICAqICAgICB9LFxuICAgKiAgIH0pO1xuICAgKiA8L3ByZT5cbiAgICogQSBzaW1wbGlmaWVkIHN5bnRheDo8cHJlPlxuICAgKiAgIEFWLk9iamVjdC5zYXZlQWxsKFtvYmplY3QxLCBvYmplY3QyLCAuLi5dLCBmdW5jdGlvbihsaXN0LCBlcnJvcikge1xuICAgKiAgICAgaWYgKGxpc3QpIHtcbiAgICogICAgICAgLy8gQWxsIHRoZSBvYmplY3RzIHdlcmUgc2F2ZWQuXG4gICAqICAgICB9IGVsc2Uge1xuICAgKiAgICAgICAvLyBBbiBlcnJvciBvY2N1cnJlZC5cbiAgICogICAgIH1cbiAgICogICB9KTtcbiAgICogPC9wcmU+XG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgQSBsaXN0IG9mIDxjb2RlPkFWLk9iamVjdDwvY29kZT4uXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgY2FsbGJhY2sgb2JqZWN0LlxuICAgKi9cbiAgQVYuT2JqZWN0LnNhdmVBbGwgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIEFWLk9iamVjdC5fZGVlcFNhdmVBc3luYyhsaXN0KS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zKTtcbiAgfTtcblxuICAvLyBBdHRhY2ggYWxsIGluaGVyaXRhYmxlIG1ldGhvZHMgdG8gdGhlIEFWLk9iamVjdCBwcm90b3R5cGUuXG4gIF8uZXh0ZW5kKEFWLk9iamVjdC5wcm90b3R5cGUsIEFWLkV2ZW50cyxcbiAgICAgICAgICAgLyoqIEBsZW5kcyBBVi5PYmplY3QucHJvdG90eXBlICovIHtcbiAgICBfZXhpc3RlZDogZmFsc2UsXG4gICAgX2ZldGNoV2hlblNhdmU6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBpcyBhbiBlbXB0eSBmdW5jdGlvbiBieSBkZWZhdWx0LiBPdmVycmlkZSBpdCB3aXRoIHlvdXIgb3duXG4gICAgICogaW5pdGlhbGl6YXRpb24gbG9naWMuXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKXt9LFxuXG4gICAvKipcbiAgICAgKiBTZXQgd2hldGhlciB0byBlbmFibGUgZmV0Y2hXaGVuU2F2ZSBvcHRpb24gd2hlbiB1cGRhdGluZyBvYmplY3QuXG4gICAgICogV2hlbiBzZXQgdHJ1ZSwgU0RLIHdvdWxkIGZldGNoIHRoZSBsYXRlc3Qgb2JqZWN0IGFmdGVyIHNhdmluZy5cbiAgICAgKiBEZWZhdWx0IGlzIGZhbHNlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlICB0cnVlIHRvIGVuYWJsZSBmZXRjaFdoZW5TYXZlIG9wdGlvbi5cbiAgICAgKi9cbiAgICBmZXRjaFdoZW5TYXZlOiBmdW5jdGlvbihlbmFibGUpe1xuICAgICAgaWYgKCFfLmlzQm9vbGVhbihlbmFibGUpKSB7XG4gICAgICAgIHRocm93IFwiRXhwZWN0IGJvb2xlYW4gdmFsdWUgZm9yIGZldGNoV2hlblNhdmVcIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2ZldGNoV2hlblNhdmUgPSBlbmFibGU7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBvYmplY3QncyBvYmplY3RJZC5cbiAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIG9iamVjdElkLlxuICAgICovXG4gICAgZ2V0T2JqZWN0SWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaWQ7XG4gICAgfSxcblxuICAgLyoqXG4gICAgKiBSZXR1cm5zIHRoZSBvYmplY3QncyBjcmVhdGVkQXQgYXR0cmlidXRlLlxuICAgICogQHJldHVybiB7RGF0ZX1cbiAgICAqL1xuICAgIGdldENyZWF0ZWRBdDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVkQXQgfHwgdGhpcy5nZXQoJ2NyZWF0ZWRBdCcpO1xuICAgIH0sXG5cbiAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgb2JqZWN0J3MgdXBkYXRlZEF0IGF0dHJpYnV0ZS5cbiAgICAqIEByZXR1cm4ge0RhdGV9XG4gICAgKi9cbiAgICBnZXRVcGRhdGVkQXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXBkYXRlZEF0IHx8IHRoaXMuZ2V0KCd1cGRhdGVkQXQnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTT04gdmVyc2lvbiBvZiB0aGUgb2JqZWN0IHN1aXRhYmxlIGZvciBzYXZpbmcgdG8gQVYuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIganNvbiA9IHRoaXMuX3RvRnVsbEpTT04oKTtcbiAgICAgIEFWLl9hcnJheUVhY2goW1wiX190eXBlXCIsIFwiY2xhc3NOYW1lXCJdLFxuICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihrZXkpIHsgZGVsZXRlIGpzb25ba2V5XTsgfSk7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuXG4gICAgX3RvRnVsbEpTT046IGZ1bmN0aW9uKHNlZW5PYmplY3RzKSB7XG4gICAgICB2YXIganNvbiA9IF8uY2xvbmUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgIEFWLl9vYmplY3RFYWNoKGpzb24sIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgIGpzb25ba2V5XSA9IEFWLl9lbmNvZGUodmFsLCBzZWVuT2JqZWN0cyk7XG4gICAgICB9KTtcbiAgICAgIEFWLl9vYmplY3RFYWNoKHRoaXMuX29wZXJhdGlvbnMsIGZ1bmN0aW9uKHZhbCwga2V5KSB7XG4gICAgICAgIGpzb25ba2V5XSA9IHZhbDtcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoXy5oYXModGhpcywgXCJpZFwiKSkge1xuICAgICAgICBqc29uLm9iamVjdElkID0gdGhpcy5pZDtcbiAgICAgIH1cbiAgICAgIGlmIChfLmhhcyh0aGlzLCBcImNyZWF0ZWRBdFwiKSkge1xuICAgICAgICBpZiAoXy5pc0RhdGUodGhpcy5jcmVhdGVkQXQpKSB7XG4gICAgICAgICAganNvbi5jcmVhdGVkQXQgPSB0aGlzLmNyZWF0ZWRBdC50b0pTT04oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqc29uLmNyZWF0ZWRBdCA9IHRoaXMuY3JlYXRlZEF0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChfLmhhcyh0aGlzLCBcInVwZGF0ZWRBdFwiKSkge1xuICAgICAgICBpZiAoXy5pc0RhdGUodGhpcy51cGRhdGVkQXQpKSB7XG4gICAgICAgICAganNvbi51cGRhdGVkQXQgPSB0aGlzLnVwZGF0ZWRBdC50b0pTT04oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqc29uLnVwZGF0ZWRBdCA9IHRoaXMudXBkYXRlZEF0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBqc29uLl9fdHlwZSA9IFwiT2JqZWN0XCI7XG4gICAgICBqc29uLmNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgX2hhc2hlZEpTT04gdG8gcmVmbGVjdCB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGlzIG9iamVjdC5cbiAgICAgKiBBZGRzIGFueSBjaGFuZ2VkIGhhc2ggdmFsdWVzIHRvIHRoZSBzZXQgb2YgcGVuZGluZyBjaGFuZ2VzLlxuICAgICAqL1xuICAgIF9yZWZyZXNoQ2FjaGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgaWYgKHNlbGYuX3JlZnJlc2hpbmdDYWNoZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWxmLl9yZWZyZXNoaW5nQ2FjaGUgPSB0cnVlO1xuICAgICAgQVYuX29iamVjdEVhY2godGhpcy5hdHRyaWJ1dGVzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFWLk9iamVjdCkge1xuICAgICAgICAgIHZhbHVlLl9yZWZyZXNoQ2FjaGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgIGlmIChzZWxmLl9yZXNldENhY2hlRm9yS2V5KGtleSkpIHtcbiAgICAgICAgICAgIHNlbGYuc2V0KGtleSwgbmV3IEFWLk9wLlNldCh2YWx1ZSksIHsgc2lsZW50OiB0cnVlIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBkZWxldGUgc2VsZi5fcmVmcmVzaGluZ0NhY2hlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBvYmplY3QgaGFzIGJlZW4gbW9kaWZpZWQgc2luY2UgaXRzIGxhc3RcbiAgICAgKiBzYXZlL3JlZnJlc2guICBJZiBhbiBhdHRyaWJ1dGUgaXMgc3BlY2lmaWVkLCBpdCByZXR1cm5zIHRydWUgb25seSBpZiB0aGF0XG4gICAgICogcGFydGljdWxhciBhdHRyaWJ1dGUgaGFzIGJlZW4gbW9kaWZpZWQgc2luY2UgdGhlIGxhc3Qgc2F2ZS9yZWZyZXNoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIEFuIGF0dHJpYnV0ZSBuYW1lIChvcHRpb25hbCkuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBkaXJ0eTogZnVuY3Rpb24oYXR0cikge1xuICAgICAgdGhpcy5fcmVmcmVzaENhY2hlKCk7XG5cbiAgICAgIHZhciBjdXJyZW50Q2hhbmdlcyA9IF8ubGFzdCh0aGlzLl9vcFNldFF1ZXVlKTtcblxuICAgICAgaWYgKGF0dHIpIHtcbiAgICAgICAgcmV0dXJuIChjdXJyZW50Q2hhbmdlc1thdHRyXSA/IHRydWUgOiBmYWxzZSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuaWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoXy5rZXlzKGN1cnJlbnRDaGFuZ2VzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgUG9pbnRlciByZWZlcmVuY2luZyB0aGlzIE9iamVjdC5cbiAgICAgKi9cbiAgICBfdG9Qb2ludGVyOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGlmICghdGhpcy5pZCkge1xuICAgICAgLy8gICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzZXJpYWxpemUgYW4gdW5zYXZlZCBBVi5PYmplY3RcIik7XG4gICAgICAvLyB9XG4gICAgICByZXR1cm4geyBfX3R5cGU6IFwiUG9pbnRlclwiLFxuICAgICAgICAgICAgICAgY2xhc3NOYW1lOiB0aGlzLmNsYXNzTmFtZSxcbiAgICAgICAgICAgICAgIG9iamVjdElkOiB0aGlzLmlkIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYXR0ciBUaGUgc3RyaW5nIG5hbWUgb2YgYW4gYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24oYXR0cikge1xuICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlc1thdHRyXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIHJlbGF0aW9uIG9uIHRoZSBnaXZlbiBjbGFzcyBmb3IgdGhlIGF0dHJpYnV0ZS5cbiAgICAgKiBAcGFyYW0gU3RyaW5nIGF0dHIgVGhlIGF0dHJpYnV0ZSB0byBnZXQgdGhlIHJlbGF0aW9uIGZvci5cbiAgICAgKi9cbiAgICByZWxhdGlvbjogZnVuY3Rpb24oYXR0cikge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoYXR0cik7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCEodmFsdWUgaW5zdGFuY2VvZiBBVi5SZWxhdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBcIkNhbGxlZCByZWxhdGlvbigpIG9uIG5vbi1yZWxhdGlvbiBmaWVsZCBcIiArIGF0dHI7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUuX2Vuc3VyZVBhcmVudEFuZEtleSh0aGlzLCBhdHRyKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBVi5SZWxhdGlvbih0aGlzLCBhdHRyKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgSFRNTC1lc2NhcGVkIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZS5cbiAgICAgKi9cbiAgICBlc2NhcGU6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHZhciBodG1sID0gdGhpcy5fZXNjYXBlZEF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICBpZiAoaHRtbCkge1xuICAgICAgICByZXR1cm4gaHRtbDtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSB0aGlzLmF0dHJpYnV0ZXNbYXR0cl07XG4gICAgICB2YXIgZXNjYXBlZDtcbiAgICAgIGlmIChBVi5faXNOdWxsT3JVbmRlZmluZWQodmFsKSkge1xuICAgICAgICBlc2NhcGVkID0gJyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlc2NhcGVkID0gXy5lc2NhcGUodmFsLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZXNjYXBlZEF0dHJpYnV0ZXNbYXR0cl0gPSBlc2NhcGVkO1xuICAgICAgcmV0dXJuIGVzY2FwZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgPGNvZGU+dHJ1ZTwvY29kZT4gaWYgdGhlIGF0dHJpYnV0ZSBjb250YWlucyBhIHZhbHVlIHRoYXQgaXMgbm90XG4gICAgICogbnVsbCBvciB1bmRlZmluZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgVGhlIHN0cmluZyBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXM6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiAhQVYuX2lzTnVsbE9yVW5kZWZpbmVkKHRoaXMuYXR0cmlidXRlc1thdHRyXSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFB1bGxzIFwic3BlY2lhbFwiIGZpZWxkcyBsaWtlIG9iamVjdElkLCBjcmVhdGVkQXQsIGV0Yy4gb3V0IG9mIGF0dHJzXG4gICAgICogYW5kIHB1dHMgdGhlbSBvbiBcInRoaXNcIiBkaXJlY3RseS4gIFJlbW92ZXMgdGhlbSBmcm9tIGF0dHJzLlxuICAgICAqIEBwYXJhbSBhdHRycyAtIEEgZGljdGlvbmFyeSB3aXRoIHRoZSBkYXRhIGZvciB0aGlzIEFWLk9iamVjdC5cbiAgICAgKi9cbiAgICBfbWVyZ2VNYWdpY0ZpZWxkczogZnVuY3Rpb24oYXR0cnMpIHtcbiAgICAgIC8vIENoZWNrIGZvciBjaGFuZ2VzIG9mIG1hZ2ljIGZpZWxkcy5cbiAgICAgIHZhciBtb2RlbCA9IHRoaXM7XG4gICAgICB2YXIgc3BlY2lhbEZpZWxkcyA9IFtcImlkXCIsIFwib2JqZWN0SWRcIiwgXCJjcmVhdGVkQXRcIiwgXCJ1cGRhdGVkQXRcIl07XG4gICAgICBBVi5fYXJyYXlFYWNoKHNwZWNpYWxGaWVsZHMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgaWYgKGF0dHJzW2F0dHJdKSB7XG4gICAgICAgICAgaWYgKGF0dHIgPT09IFwib2JqZWN0SWRcIikge1xuICAgICAgICAgICAgbW9kZWwuaWQgPSBhdHRyc1thdHRyXTtcbiAgICAgICAgICB9IGVsc2UgaWYgKChhdHRyID09PSBcImNyZWF0ZWRBdFwiIHx8IGF0dHIgPT09IFwidXBkYXRlZEF0XCIpICYmXG4gICAgICAgICAgICAgICAgICAgICAhXy5pc0RhdGUoYXR0cnNbYXR0cl0pKSB7XG4gICAgICAgICAgICBtb2RlbFthdHRyXSA9IEFWLl9wYXJzZURhdGUoYXR0cnNbYXR0cl0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtb2RlbFthdHRyXSA9IGF0dHJzW2F0dHJdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWxldGUgYXR0cnNbYXR0cl07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBqc29uIHRvIGJlIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBfc3RhcnRTYXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuX29wU2V0UXVldWUucHVzaCh7fSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgc2F2ZSBmYWlscyBiZWNhdXNlIG9mIGFuIGVycm9yLiBBbnkgY2hhbmdlcyB0aGF0IHdlcmUgcGFydFxuICAgICAqIG9mIHRoZSBzYXZlIG5lZWQgdG8gYmUgbWVyZ2VkIHdpdGggY2hhbmdlcyBtYWRlIGFmdGVyIHRoZSBzYXZlLiBUaGlzXG4gICAgICogbWlnaHQgdGhyb3cgYW4gZXhjZXB0aW9uIGlzIHlvdSBkbyBjb25mbGljdGluZyBvcGVyYXRpb25zLiBGb3IgZXhhbXBsZSxcbiAgICAgKiBpZiB5b3UgZG86XG4gICAgICogICBvYmplY3Quc2V0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgICAqICAgb2JqZWN0LnNldChcImludmFsaWQgZmllbGQgbmFtZVwiLCBcImJhelwiKTtcbiAgICAgKiAgIG9iamVjdC5zYXZlKCk7XG4gICAgICogICBvYmplY3QuaW5jcmVtZW50KFwiZm9vXCIpO1xuICAgICAqIHRoZW4gdGhpcyB3aWxsIHRocm93IHdoZW4gdGhlIHNhdmUgZmFpbHMgYW5kIHRoZSBjbGllbnQgdHJpZXMgdG8gbWVyZ2VcbiAgICAgKiBcImJhclwiIHdpdGggdGhlICsxLlxuICAgICAqL1xuICAgIF9jYW5jZWxTYXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciBmYWlsZWRDaGFuZ2VzID0gXy5maXJzdCh0aGlzLl9vcFNldFF1ZXVlKTtcbiAgICAgIHRoaXMuX29wU2V0UXVldWUgPSBfLnJlc3QodGhpcy5fb3BTZXRRdWV1ZSk7XG4gICAgICB2YXIgbmV4dENoYW5nZXMgPSBfLmZpcnN0KHRoaXMuX29wU2V0UXVldWUpO1xuICAgICAgQVYuX29iamVjdEVhY2goZmFpbGVkQ2hhbmdlcywgZnVuY3Rpb24ob3AsIGtleSkge1xuICAgICAgICB2YXIgb3AxID0gZmFpbGVkQ2hhbmdlc1trZXldO1xuICAgICAgICB2YXIgb3AyID0gbmV4dENoYW5nZXNba2V5XTtcbiAgICAgICAgaWYgKG9wMSAmJiBvcDIpIHtcbiAgICAgICAgICBuZXh0Q2hhbmdlc1trZXldID0gb3AyLl9tZXJnZVdpdGhQcmV2aW91cyhvcDEpO1xuICAgICAgICB9IGVsc2UgaWYgKG9wMSkge1xuICAgICAgICAgIG5leHRDaGFuZ2VzW2tleV0gPSBvcDE7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2F2aW5nID0gdGhpcy5fc2F2aW5nIC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBzYXZlIGNvbXBsZXRlcyBzdWNjZXNzZnVsbHkuIFRoaXMgbWVyZ2VzIHRoZSBjaGFuZ2VzIHRoYXRcbiAgICAgKiB3ZXJlIHNhdmVkIGludG8gdGhlIGtub3duIHNlcnZlciBkYXRhLCBhbmQgb3ZlcnJpZGVzIGl0IHdpdGggYW55IGRhdGFcbiAgICAgKiBzZW50IGRpcmVjdGx5IGZyb20gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBfZmluaXNoU2F2ZTogZnVuY3Rpb24oc2VydmVyRGF0YSkge1xuICAgICAgLy8gR3JhYiBhIGNvcHkgb2YgYW55IG9iamVjdCByZWZlcmVuY2VkIGJ5IHRoaXMgb2JqZWN0LiBUaGVzZSBpbnN0YW5jZXNcbiAgICAgIC8vIG1heSBoYXZlIGFscmVhZHkgYmVlbiBmZXRjaGVkLCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBsb3NlIHRoZWlyIGRhdGEuXG4gICAgICAvLyBOb3RlIHRoYXQgZG9pbmcgaXQgbGlrZSB0aGlzIG1lYW5zIHdlIHdpbGwgdW5pZnkgc2VwYXJhdGUgY29waWVzIG9mIHRoZVxuICAgICAgLy8gc2FtZSBvYmplY3QsIGJ1dCB0aGF0J3MgYSByaXNrIHdlIGhhdmUgdG8gdGFrZS5cbiAgICAgIHZhciBmZXRjaGVkT2JqZWN0cyA9IHt9O1xuICAgICAgQVYuX3RyYXZlcnNlKHRoaXMuYXR0cmlidXRlcywgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBVi5PYmplY3QgJiYgb2JqZWN0LmlkICYmIG9iamVjdC5faGFzRGF0YSkge1xuICAgICAgICAgIGZldGNoZWRPYmplY3RzW29iamVjdC5pZF0gPSBvYmplY3Q7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICB2YXIgc2F2ZWRDaGFuZ2VzID0gXy5maXJzdCh0aGlzLl9vcFNldFF1ZXVlKTtcbiAgICAgIHRoaXMuX29wU2V0UXVldWUgPSBfLnJlc3QodGhpcy5fb3BTZXRRdWV1ZSk7XG4gICAgICB0aGlzLl9hcHBseU9wU2V0KHNhdmVkQ2hhbmdlcywgdGhpcy5fc2VydmVyRGF0YSk7XG4gICAgICB0aGlzLl9tZXJnZU1hZ2ljRmllbGRzKHNlcnZlckRhdGEpO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgQVYuX29iamVjdEVhY2goc2VydmVyRGF0YSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICBzZWxmLl9zZXJ2ZXJEYXRhW2tleV0gPSBBVi5fZGVjb2RlKGtleSwgdmFsdWUpO1xuXG4gICAgICAgIC8vIExvb2sgZm9yIGFueSBvYmplY3RzIHRoYXQgbWlnaHQgaGF2ZSBiZWNvbWUgdW5mZXRjaGVkIGFuZCBmaXggdGhlbVxuICAgICAgICAvLyBieSByZXBsYWNpbmcgdGhlaXIgdmFsdWVzIHdpdGggdGhlIHByZXZpb3VzbHkgb2JzZXJ2ZWQgdmFsdWVzLlxuICAgICAgICB2YXIgZmV0Y2hlZCA9IEFWLl90cmF2ZXJzZShzZWxmLl9zZXJ2ZXJEYXRhW2tleV0sIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBVi5PYmplY3QgJiYgZmV0Y2hlZE9iamVjdHNbb2JqZWN0LmlkXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoZWRPYmplY3RzW29iamVjdC5pZF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGZldGNoZWQpIHtcbiAgICAgICAgICBzZWxmLl9zZXJ2ZXJEYXRhW2tleV0gPSBmZXRjaGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3JlYnVpbGRBbGxFc3RpbWF0ZWREYXRhKCk7XG4gICAgICB0aGlzLl9zYXZpbmcgPSB0aGlzLl9zYXZpbmcgLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIGZldGNoIG9yIGxvZ2luIGlzIGNvbXBsZXRlIHRvIHNldCB0aGUga25vd24gc2VydmVyIGRhdGEgdG9cbiAgICAgKiB0aGUgZ2l2ZW4gb2JqZWN0LlxuICAgICAqL1xuICAgIF9maW5pc2hGZXRjaDogZnVuY3Rpb24oc2VydmVyRGF0YSwgaGFzRGF0YSkge1xuICAgICAgLy8gQ2xlYXIgb3V0IGFueSBjaGFuZ2VzIHRoZSB1c2VyIG1pZ2h0IGhhdmUgbWFkZSBwcmV2aW91c2x5LlxuICAgICAgdGhpcy5fb3BTZXRRdWV1ZSA9IFt7fV07XG5cbiAgICAgIC8vIEJyaW5nIGluIGFsbCB0aGUgbmV3IHNlcnZlciBkYXRhLlxuICAgICAgdGhpcy5fbWVyZ2VNYWdpY0ZpZWxkcyhzZXJ2ZXJEYXRhKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIEFWLl9vYmplY3RFYWNoKHNlcnZlckRhdGEsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgc2VsZi5fc2VydmVyRGF0YVtrZXldID0gQVYuX2RlY29kZShrZXksIHZhbHVlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZWZyZXNoIHRoZSBhdHRyaWJ1dGVzLlxuICAgICAgdGhpcy5fcmVidWlsZEFsbEVzdGltYXRlZERhdGEoKTtcblxuICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBjYWNoZSBvZiBtdXRhYmxlIGNvbnRhaW5lcnMuXG4gICAgICB0aGlzLl9yZWZyZXNoQ2FjaGUoKTtcbiAgICAgIHRoaXMuX29wU2V0UXVldWUgPSBbe31dO1xuXG4gICAgICB0aGlzLl9oYXNEYXRhID0gaGFzRGF0YTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXBwbGllcyB0aGUgc2V0IG9mIEFWLk9wIGluIG9wU2V0IHRvIHRoZSBvYmplY3QgdGFyZ2V0LlxuICAgICAqL1xuICAgIF9hcHBseU9wU2V0OiBmdW5jdGlvbihvcFNldCwgdGFyZ2V0KSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBBVi5fb2JqZWN0RWFjaChvcFNldCwgZnVuY3Rpb24oY2hhbmdlLCBrZXkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBjaGFuZ2UuX2VzdGltYXRlKHRhcmdldFtrZXldLCBzZWxmLCBrZXkpO1xuICAgICAgICBpZiAodGFyZ2V0W2tleV0gPT09IEFWLk9wLl9VTlNFVCkge1xuICAgICAgICAgIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIHRoZSBjYWNoZWQgdmFsdWUgZm9yIGtleSB3aXRoIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgbmV3IHZhbHVlIGlzIGRpZmZlcmVudCB0aGFuIHRoZSBvbGQgdmFsdWUuXG4gICAgICovXG4gICAgX3Jlc2V0Q2FjaGVGb3JLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5hdHRyaWJ1dGVzW2tleV07XG4gICAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkgJiZcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgQVYuT2JqZWN0KSAmJlxuICAgICAgICAgICEodmFsdWUgaW5zdGFuY2VvZiBBVi5GaWxlKSkge1xuXG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OID8gdmFsdWUudG9KU09OKCkgOiB2YWx1ZTtcbiAgICAgICAgdmFyIGpzb24gPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgIGlmICh0aGlzLl9oYXNoZWRKU09OW2tleV0gIT09IGpzb24pIHtcbiAgICAgICAgICB2YXIgd2FzU2V0ID0gISEgdGhpcy5faGFzaGVkSlNPTltrZXldO1xuICAgICAgICAgIHRoaXMuX2hhc2hlZEpTT05ba2V5XSA9IGpzb247XG4gICAgICAgICAgcmV0dXJuIHdhc1NldDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZXMgYXR0cmlidXRlc1trZXldIGJ5IHN0YXJ0aW5nIHdpdGggdGhlIGxhc3Qga25vd24gZGF0YSBmcm9tIHRoZVxuICAgICAqIHNlcnZlciwgYW5kIGFwcGx5aW5nIGFsbCBvZiB0aGUgbG9jYWwgY2hhbmdlcyB0aGF0IGhhdmUgYmVlbiBtYWRlIHRvIHRoYXRcbiAgICAgKiBrZXkgc2luY2UgdGhlbi5cbiAgICAgKi9cbiAgICBfcmVidWlsZEVzdGltYXRlZERhdGFGb3JLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgZGVsZXRlIHRoaXMuYXR0cmlidXRlc1trZXldO1xuICAgICAgaWYgKHRoaXMuX3NlcnZlckRhdGFba2V5XSkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNba2V5XSA9IHRoaXMuX3NlcnZlckRhdGFba2V5XTtcbiAgICAgIH1cbiAgICAgIEFWLl9hcnJheUVhY2godGhpcy5fb3BTZXRRdWV1ZSwgZnVuY3Rpb24ob3BTZXQpIHtcbiAgICAgICAgdmFyIG9wID0gb3BTZXRba2V5XTtcbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgc2VsZi5hdHRyaWJ1dGVzW2tleV0gPSBvcC5fZXN0aW1hdGUoc2VsZi5hdHRyaWJ1dGVzW2tleV0sIHNlbGYsIGtleSk7XG4gICAgICAgICAgaWYgKHNlbGYuYXR0cmlidXRlc1trZXldID09PSBBVi5PcC5fVU5TRVQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZWxmLmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5fcmVzZXRDYWNoZUZvcktleShrZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBvcHVsYXRlcyBhdHRyaWJ1dGVzIGJ5IHN0YXJ0aW5nIHdpdGggdGhlIGxhc3Qga25vd24gZGF0YSBmcm9tIHRoZVxuICAgICAqIHNlcnZlciwgYW5kIGFwcGx5aW5nIGFsbCBvZiB0aGUgbG9jYWwgY2hhbmdlcyB0aGF0IGhhdmUgYmVlbiBtYWRlIHNpbmNlXG4gICAgICogdGhlbi5cbiAgICAgKi9cbiAgICBfcmVidWlsZEFsbEVzdGltYXRlZERhdGE6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgcHJldmlvdXNBdHRyaWJ1dGVzID0gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMgPSBfLmNsb25lKHRoaXMuX3NlcnZlckRhdGEpO1xuICAgICAgQVYuX2FycmF5RWFjaCh0aGlzLl9vcFNldFF1ZXVlLCBmdW5jdGlvbihvcFNldCkge1xuICAgICAgICBzZWxmLl9hcHBseU9wU2V0KG9wU2V0LCBzZWxmLmF0dHJpYnV0ZXMpO1xuICAgICAgICBBVi5fb2JqZWN0RWFjaChvcFNldCwgZnVuY3Rpb24ob3AsIGtleSkge1xuICAgICAgICAgIHNlbGYuX3Jlc2V0Q2FjaGVGb3JLZXkoa2V5KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gVHJpZ2dlciBjaGFuZ2UgZXZlbnRzIGZvciBhbnl0aGluZyB0aGF0IGNoYW5nZWQgYmVjYXVzZSBvZiB0aGUgZmV0Y2guXG4gICAgICBBVi5fb2JqZWN0RWFjaChwcmV2aW91c0F0dHJpYnV0ZXMsIGZ1bmN0aW9uKG9sZFZhbHVlLCBrZXkpIHtcbiAgICAgICAgaWYgKHNlbGYuYXR0cmlidXRlc1trZXldICE9PSBvbGRWYWx1ZSkge1xuICAgICAgICAgIHNlbGYudHJpZ2dlcignY2hhbmdlOicgKyBrZXksIHNlbGYsIHNlbGYuYXR0cmlidXRlc1trZXldLCB7fSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgQVYuX29iamVjdEVhY2godGhpcy5hdHRyaWJ1dGVzLCBmdW5jdGlvbihuZXdWYWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICghXy5oYXMocHJldmlvdXNBdHRyaWJ1dGVzLCBrZXkpKSB7XG4gICAgICAgICAgc2VsZi50cmlnZ2VyKCdjaGFuZ2U6JyArIGtleSwgc2VsZiwgbmV3VmFsdWUsIHt9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgYSBoYXNoIG9mIG1vZGVsIGF0dHJpYnV0ZXMgb24gdGhlIG9iamVjdCwgZmlyaW5nXG4gICAgICogPGNvZGU+XCJjaGFuZ2VcIjwvY29kZT4gdW5sZXNzIHlvdSBjaG9vc2UgdG8gc2lsZW5jZSBpdC5cbiAgICAgKlxuICAgICAqIDxwPllvdSBjYW4gY2FsbCBpdCB3aXRoIGFuIG9iamVjdCBjb250YWluaW5nIGtleXMgYW5kIHZhbHVlcywgb3Igd2l0aCBvbmVcbiAgICAgKiBrZXkgYW5kIHZhbHVlLiAgRm9yIGV4YW1wbGU6PHByZT5cbiAgICAgKiAgIGdhbWVUdXJuLnNldCh7XG4gICAgICogICAgIHBsYXllcjogcGxheWVyMSxcbiAgICAgKiAgICAgZGljZVJvbGw6IDJcbiAgICAgKiAgIH0sIHtcbiAgICAgKiAgICAgZXJyb3I6IGZ1bmN0aW9uKGdhbWVUdXJuQWdhaW4sIGVycm9yKSB7XG4gICAgICogICAgICAgLy8gVGhlIHNldCBmYWlsZWQgdmFsaWRhdGlvbi5cbiAgICAgKiAgICAgfVxuICAgICAqICAgfSk7XG4gICAgICpcbiAgICAgKiAgIGdhbWUuc2V0KFwiY3VycmVudFBsYXllclwiLCBwbGF5ZXIyLCB7XG4gICAgICogICAgIGVycm9yOiBmdW5jdGlvbihnYW1lVHVybkFnYWluLCBlcnJvcikge1xuICAgICAqICAgICAgIC8vIFRoZSBzZXQgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAgICogICAgIH1cbiAgICAgKiAgIH0pO1xuICAgICAqXG4gICAgICogICBnYW1lLnNldChcImZpbmlzaGVkXCIsIHRydWUpOzwvcHJlPjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0byBzZXQuXG4gICAgICogQHBhcmFtIHt9IHZhbHVlIFRoZSB2YWx1ZSB0byBnaXZlIGl0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgc2V0IG9mIEJhY2tib25lLWxpa2Ugb3B0aW9ucyBmb3IgdGhlIHNldC5cbiAgICAgKiAgICAgVGhlIG9ubHkgc3VwcG9ydGVkIG9wdGlvbnMgYXJlIDxjb2RlPnNpbGVudDwvY29kZT4sXG4gICAgICogICAgIDxjb2RlPmVycm9yPC9jb2RlPiwgYW5kIDxjb2RlPnByb21pc2U8L2NvZGU+LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhlIHNldCBzdWNjZWVkZWQuXG4gICAgICogQHNlZSBBVi5PYmplY3QjdmFsaWRhdGVcbiAgICAgKiBAc2VlIEFWLkVycm9yXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgYXR0cnMsIGF0dHI7XG4gICAgICBpZiAoXy5pc09iamVjdChrZXkpIHx8IEFWLl9pc051bGxPclVuZGVmaW5lZChrZXkpKSB7XG4gICAgICAgIGF0dHJzID0ga2V5O1xuICAgICAgICBBVi5fb2JqZWN0RWFjaChhdHRycywgZnVuY3Rpb24odiwgaykge1xuICAgICAgICAgIGF0dHJzW2tdID0gQVYuX2RlY29kZShrLCB2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMgPSB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzID0ge307XG4gICAgICAgIGF0dHJzW2tleV0gPSBBVi5fZGVjb2RlKGtleSwgdmFsdWUpO1xuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IGF0dHJpYnV0ZXMgYW5kIG9wdGlvbnMuXG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIGlmICghYXR0cnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBpZiAoYXR0cnMgaW5zdGFuY2VvZiBBVi5PYmplY3QpIHtcbiAgICAgICAgYXR0cnMgPSBhdHRycy5hdHRyaWJ1dGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgdW5zZXQgb3B0aW9uIGlzIHVzZWQsIGV2ZXJ5IGF0dHJpYnV0ZSBzaG91bGQgYmUgYSBVbnNldC5cbiAgICAgIGlmIChvcHRpb25zLnVuc2V0KSB7XG4gICAgICAgIEFWLl9vYmplY3RFYWNoKGF0dHJzLCBmdW5jdGlvbih1bnVzZWRfdmFsdWUsIGtleSkge1xuICAgICAgICAgIGF0dHJzW2tleV0gPSBuZXcgQVYuT3AuVW5zZXQoKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IGFsbCB0aGUgYXR0cmlidXRlcyB0byBnZXQgdGhlIGVzdGltYXRlZCB2YWx1ZXMuXG4gICAgICB2YXIgZGF0YVRvVmFsaWRhdGUgPSBfLmNsb25lKGF0dHJzKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIEFWLl9vYmplY3RFYWNoKGRhdGFUb1ZhbGlkYXRlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFWLk9wKSB7XG4gICAgICAgICAgZGF0YVRvVmFsaWRhdGVba2V5XSA9IHZhbHVlLl9lc3RpbWF0ZShzZWxmLmF0dHJpYnV0ZXNba2V5XSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYsIGtleSk7XG4gICAgICAgICAgaWYgKGRhdGFUb1ZhbGlkYXRlW2tleV0gPT09IEFWLk9wLl9VTlNFVCkge1xuICAgICAgICAgICAgZGVsZXRlIGRhdGFUb1ZhbGlkYXRlW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gUnVuIHZhbGlkYXRpb24uXG4gICAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX21lcmdlTWFnaWNGaWVsZHMoYXR0cnMpO1xuXG4gICAgICBvcHRpb25zLmNoYW5nZXMgPSB7fTtcbiAgICAgIHZhciBlc2NhcGVkID0gdGhpcy5fZXNjYXBlZEF0dHJpYnV0ZXM7XG4gICAgICB2YXIgcHJldiA9IHRoaXMuX3ByZXZpb3VzQXR0cmlidXRlcyB8fCB7fTtcblxuICAgICAgLy8gVXBkYXRlIGF0dHJpYnV0ZXMuXG4gICAgICBBVi5fYXJyYXlFYWNoKF8ua2V5cyhhdHRycyksIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGF0dHJzW2F0dHJdO1xuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSByZWxhdGlvbiBvYmplY3Qgd2UgbmVlZCB0byBzZXQgdGhlIHBhcmVudCBjb3JyZWN0bHksXG4gICAgICAgIC8vIHNpbmNlIHRoZSBsb2NhdGlvbiB3aGVyZSBpdCB3YXMgcGFyc2VkIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvXG4gICAgICAgIC8vIHRoaXMgb2JqZWN0LlxuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgQVYuUmVsYXRpb24pIHtcbiAgICAgICAgICB2YWwucGFyZW50ID0gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghKHZhbCBpbnN0YW5jZW9mIEFWLk9wKSkge1xuICAgICAgICAgIHZhbCA9IG5ldyBBVi5PcC5TZXQodmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNlZSBpZiB0aGlzIGNoYW5nZSB3aWxsIGFjdHVhbGx5IGhhdmUgYW55IGVmZmVjdC5cbiAgICAgICAgdmFyIGlzUmVhbENoYW5nZSA9IHRydWU7XG4gICAgICAgIGlmICh2YWwgaW5zdGFuY2VvZiBBVi5PcC5TZXQgJiZcbiAgICAgICAgICAgIF8uaXNFcXVhbChzZWxmLmF0dHJpYnV0ZXNbYXR0cl0sIHZhbC52YWx1ZSkpIHtcbiAgICAgICAgICBpc1JlYWxDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1JlYWxDaGFuZ2UpIHtcbiAgICAgICAgICBkZWxldGUgZXNjYXBlZFthdHRyXTtcbiAgICAgICAgICBpZiAob3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIHNlbGYuX3NpbGVudFthdHRyXSA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMuY2hhbmdlc1thdHRyXSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGN1cnJlbnRDaGFuZ2VzID0gXy5sYXN0KHNlbGYuX29wU2V0UXVldWUpO1xuICAgICAgICBjdXJyZW50Q2hhbmdlc1thdHRyXSA9IHZhbC5fbWVyZ2VXaXRoUHJldmlvdXMoY3VycmVudENoYW5nZXNbYXR0cl0pO1xuICAgICAgICBzZWxmLl9yZWJ1aWxkRXN0aW1hdGVkRGF0YUZvcktleShhdHRyKTtcblxuICAgICAgICBpZiAoaXNSZWFsQ2hhbmdlKSB7XG4gICAgICAgICAgc2VsZi5jaGFuZ2VkW2F0dHJdID0gc2VsZi5hdHRyaWJ1dGVzW2F0dHJdO1xuICAgICAgICAgIGlmICghb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIHNlbGYuX3BlbmRpbmdbYXR0cl0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgc2VsZi5jaGFuZ2VkW2F0dHJdO1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLl9wZW5kaW5nW2F0dHJdO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKCFvcHRpb25zLnNpbGVudCkge1xuICAgICAgICB0aGlzLmNoYW5nZShvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYW4gYXR0cmlidXRlIGZyb20gdGhlIG1vZGVsLCBmaXJpbmcgPGNvZGU+XCJjaGFuZ2VcIjwvY29kZT4gdW5sZXNzXG4gICAgICogeW91IGNob29zZSB0byBzaWxlbmNlIGl0LiBUaGlzIGlzIGEgbm9vcCBpZiB0aGUgYXR0cmlidXRlIGRvZXNuJ3RcbiAgICAgKiBleGlzdC5cbiAgICAgKi9cbiAgICB1bnNldDogZnVuY3Rpb24oYXR0ciwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLnVuc2V0ID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLnNldChhdHRyLCBudWxsLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXRvbWljYWxseSBpbmNyZW1lbnRzIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gYXR0cmlidXRlIHRoZSBuZXh0IHRpbWUgdGhlXG4gICAgICogb2JqZWN0IGlzIHNhdmVkLiBJZiBubyBhbW91bnQgaXMgc3BlY2lmaWVkLCAxIGlzIHVzZWQgYnkgZGVmYXVsdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdHRyIHtTdHJpbmd9IFRoZSBrZXkuXG4gICAgICogQHBhcmFtIGFtb3VudCB7TnVtYmVyfSBUaGUgYW1vdW50IHRvIGluY3JlbWVudCBieS5cbiAgICAgKi9cbiAgICBpbmNyZW1lbnQ6IGZ1bmN0aW9uKGF0dHIsIGFtb3VudCkge1xuICAgICAgaWYgKF8uaXNVbmRlZmluZWQoYW1vdW50KSB8fCBfLmlzTnVsbChhbW91bnQpKSB7XG4gICAgICAgIGFtb3VudCA9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zZXQoYXR0ciwgbmV3IEFWLk9wLkluY3JlbWVudChhbW91bnQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQXRvbWljYWxseSBhZGQgYW4gb2JqZWN0IHRvIHRoZSBlbmQgb2YgdGhlIGFycmF5IGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuXG4gICAgICoga2V5LlxuICAgICAqIEBwYXJhbSBhdHRyIHtTdHJpbmd9IFRoZSBrZXkuXG4gICAgICogQHBhcmFtIGl0ZW0ge30gVGhlIGl0ZW0gdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24oYXR0ciwgaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIG5ldyBBVi5PcC5BZGQoW2l0ZW1dKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0b21pY2FsbHkgYWRkIGFuIG9iamVjdCB0byB0aGUgYXJyYXkgYXNzb2NpYXRlZCB3aXRoIGEgZ2l2ZW4ga2V5LCBvbmx5XG4gICAgICogaWYgaXQgaXMgbm90IGFscmVhZHkgcHJlc2VudCBpbiB0aGUgYXJyYXkuIFRoZSBwb3NpdGlvbiBvZiB0aGUgaW5zZXJ0IGlzXG4gICAgICogbm90IGd1YXJhbnRlZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXR0ciB7U3RyaW5nfSBUaGUga2V5LlxuICAgICAqIEBwYXJhbSBpdGVtIHt9IFRoZSBvYmplY3QgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZFVuaXF1ZTogZnVuY3Rpb24oYXR0ciwgaXRlbSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KGF0dHIsIG5ldyBBVi5PcC5BZGRVbmlxdWUoW2l0ZW1dKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEF0b21pY2FsbHkgcmVtb3ZlIGFsbCBpbnN0YW5jZXMgb2YgYW4gb2JqZWN0IGZyb20gdGhlIGFycmF5IGFzc29jaWF0ZWRcbiAgICAgKiB3aXRoIGEgZ2l2ZW4ga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtIGF0dHIge1N0cmluZ30gVGhlIGtleS5cbiAgICAgKiBAcGFyYW0gaXRlbSB7fSBUaGUgb2JqZWN0IHRvIHJlbW92ZS5cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKGF0dHIsIGl0ZW0pIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChhdHRyLCBuZXcgQVYuT3AuUmVtb3ZlKFtpdGVtXSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIGEgc3ViY2xhc3Mgb2YgQVYuT3AgZGVzY3JpYmluZyB3aGF0IGtpbmQgb2ZcbiAgICAgKiBtb2RpZmljYXRpb24gaGFzIGJlZW4gcGVyZm9ybWVkIG9uIHRoaXMgZmllbGQgc2luY2UgdGhlIGxhc3QgdGltZSBpdCB3YXNcbiAgICAgKiBzYXZlZC4gRm9yIGV4YW1wbGUsIGFmdGVyIGNhbGxpbmcgb2JqZWN0LmluY3JlbWVudChcInhcIiksIGNhbGxpbmdcbiAgICAgKiBvYmplY3Qub3AoXCJ4XCIpIHdvdWxkIHJldHVybiBhbiBpbnN0YW5jZSBvZiBBVi5PcC5JbmNyZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXR0ciB7U3RyaW5nfSBUaGUga2V5LlxuICAgICAqIEByZXR1cm5zIHtBVi5PcH0gVGhlIG9wZXJhdGlvbiwgb3IgdW5kZWZpbmVkIGlmIG5vbmUuXG4gICAgICovXG4gICAgb3A6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIHJldHVybiBfLmxhc3QodGhpcy5fb3BTZXRRdWV1ZSlbYXR0cl07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBhdHRyaWJ1dGVzIG9uIHRoZSBtb2RlbCwgZmlyaW5nIDxjb2RlPlwiY2hhbmdlXCI8L2NvZGU+IHVubGVzc1xuICAgICAqIHlvdSBjaG9vc2UgdG8gc2lsZW5jZSBpdC5cbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICBvcHRpb25zLnVuc2V0ID0gdHJ1ZTtcbiAgICAgIHZhciBrZXlzVG9DbGVhciA9IF8uZXh0ZW5kKHRoaXMuYXR0cmlidXRlcywgdGhpcy5fb3BlcmF0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoa2V5c1RvQ2xlYXIsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSlNPTi1lbmNvZGVkIHNldCBvZiBvcGVyYXRpb25zIHRvIGJlIHNlbnQgd2l0aCB0aGUgbmV4dCBzYXZlXG4gICAgICogcmVxdWVzdC5cbiAgICAgKi9cbiAgICBfZ2V0U2F2ZUpTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGpzb24gPSBfLmNsb25lKF8uZmlyc3QodGhpcy5fb3BTZXRRdWV1ZSkpO1xuICAgICAgQVYuX29iamVjdEVhY2goanNvbiwgZnVuY3Rpb24ob3AsIGtleSkge1xuICAgICAgICBqc29uW2tleV0gPSBvcC50b0pTT04oKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGpzb247XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIG9iamVjdCBjYW4gYmUgc2VyaWFsaXplZCBmb3Igc2F2aW5nLlxuICAgICAqL1xuICAgIF9jYW5CZVNlcmlhbGl6ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFWLk9iamVjdC5fY2FuQmVTZXJpYWxpemVkQXNWYWx1ZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgbW9kZWwgZnJvbSB0aGUgc2VydmVyLiBJZiB0aGUgc2VydmVyJ3MgcmVwcmVzZW50YXRpb24gb2YgdGhlXG4gICAgICogbW9kZWwgZGlmZmVycyBmcm9tIGl0cyBjdXJyZW50IGF0dHJpYnV0ZXMsIHRoZXkgd2lsbCBiZSBvdmVycmlkZW4sXG4gICAgICogdHJpZ2dlcmluZyBhIDxjb2RlPlwiY2hhbmdlXCI8L2NvZGU+IGV2ZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmZXRjaE9wdGlvbnMgT3B0aW9uYWwgb3B0aW9ucyB0byBzZXQgJ2tleXMnIGFuZFxuICAgICAqICAgICAgJ2luY2x1ZGUnIG9wdGlvbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25hbCBCYWNrYm9uZS1saWtlIG9wdGlvbnMgb2JqZWN0IHRvIGJlXG4gICAgICogICAgIHBhc3NlZCBpbiB0byBzZXQuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gdGhlIGZldGNoXG4gICAgICogICAgIGNvbXBsZXRlcy5cbiAgICAgKi9cbiAgICBmZXRjaDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IG51bGw7XG4gICAgICB2YXIgZmV0Y2hPcHRpb25zID0ge307XG4gICAgICBpZihhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICB9IGVsc2UgaWYoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBmZXRjaE9wdGlvbnMgPSBhcmd1bWVudHNbMF07XG4gICAgICAgIG9wdGlvbnMgPSBhcmd1bWVudHNbMV07XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHZhciByZXF1ZXN0ID0gQVYuX3JlcXVlc3QoXCJjbGFzc2VzXCIsIHRoaXMuY2xhc3NOYW1lLCB0aGlzLmlkLCAnR0VUJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hPcHRpb25zKTtcbiAgICAgIHJldHVybiByZXF1ZXN0LnRoZW4oZnVuY3Rpb24ocmVzcG9uc2UsIHN0YXR1cywgeGhyKSB7XG4gICAgICAgIHNlbGYuX2ZpbmlzaEZldGNoKHNlbGYucGFyc2UocmVzcG9uc2UsIHN0YXR1cywgeGhyKSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBzZWxmO1xuICAgICAgfSkuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucywgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCBhIGhhc2ggb2YgbW9kZWwgYXR0cmlidXRlcywgYW5kIHNhdmUgdGhlIG1vZGVsIHRvIHRoZSBzZXJ2ZXIuXG4gICAgICogdXBkYXRlZEF0IHdpbGwgYmUgdXBkYXRlZCB3aGVuIHRoZSByZXF1ZXN0IHJldHVybnMuXG4gICAgICogWW91IGNhbiBlaXRoZXIgY2FsbCBpdCBhczo8cHJlPlxuICAgICAqICAgb2JqZWN0LnNhdmUoKTs8L3ByZT5cbiAgICAgKiBvcjxwcmU+XG4gICAgICogICBvYmplY3Quc2F2ZShudWxsLCBvcHRpb25zKTs8L3ByZT5cbiAgICAgKiBvcjxwcmU+XG4gICAgICogICBvYmplY3Quc2F2ZShhdHRycywgb3B0aW9ucyk7PC9wcmU+XG4gICAgICogb3I8cHJlPlxuICAgICAqICAgb2JqZWN0LnNhdmUoa2V5LCB2YWx1ZSwgb3B0aW9ucyk7PC9wcmU+XG4gICAgICpcbiAgICAgKiBGb3IgZXhhbXBsZSwgPHByZT5cbiAgICAgKiAgIGdhbWVUdXJuLnNhdmUoe1xuICAgICAqICAgICBwbGF5ZXI6IFwiSmFrZSBDdXR0ZXJcIixcbiAgICAgKiAgICAgZGljZVJvbGw6IDJcbiAgICAgKiAgIH0sIHtcbiAgICAgKiAgICAgc3VjY2VzczogZnVuY3Rpb24oZ2FtZVR1cm5BZ2Fpbikge1xuICAgICAqICAgICAgIC8vIFRoZSBzYXZlIHdhcyBzdWNjZXNzZnVsLlxuICAgICAqICAgICB9LFxuICAgICAqICAgICBlcnJvcjogZnVuY3Rpb24oZ2FtZVR1cm5BZ2FpbiwgZXJyb3IpIHtcbiAgICAgKiAgICAgICAvLyBUaGUgc2F2ZSBmYWlsZWQuICBFcnJvciBpcyBhbiBpbnN0YW5jZSBvZiBBVi5FcnJvci5cbiAgICAgKiAgICAgfVxuICAgICAqICAgfSk7PC9wcmU+XG4gICAgICogb3Igd2l0aCBwcm9taXNlczo8cHJlPlxuICAgICAqICAgZ2FtZVR1cm4uc2F2ZSh7XG4gICAgICogICAgIHBsYXllcjogXCJKYWtlIEN1dHRlclwiLFxuICAgICAqICAgICBkaWNlUm9sbDogMlxuICAgICAqICAgfSkudGhlbihmdW5jdGlvbihnYW1lVHVybkFnYWluKSB7XG4gICAgICogICAgIC8vIFRoZSBzYXZlIHdhcyBzdWNjZXNzZnVsLlxuICAgICAqICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgKiAgICAgLy8gVGhlIHNhdmUgZmFpbGVkLiAgRXJyb3IgaXMgYW4gaW5zdGFuY2Ugb2YgQVYuRXJyb3IuXG4gICAgICogICB9KTs8L3ByZT5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIHRoZSBzYXZlXG4gICAgICogICAgIGNvbXBsZXRlcy5cbiAgICAgKiBAc2VlIEFWLkVycm9yXG4gICAgICovXG4gICAgc2F2ZTogZnVuY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgdmFyIGksIGF0dHJzLCBjdXJyZW50LCBvcHRpb25zLCBzYXZlZDtcbiAgICAgIGlmIChfLmlzT2JqZWN0KGFyZzEpIHx8IEFWLl9pc051bGxPclVuZGVmaW5lZChhcmcxKSkge1xuICAgICAgICBhdHRycyA9IGFyZzE7XG4gICAgICAgIG9wdGlvbnMgPSBhcmcyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXR0cnMgPSB7fTtcbiAgICAgICAgYXR0cnNbYXJnMV0gPSBhcmcyO1xuICAgICAgICBvcHRpb25zID0gYXJnMztcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzYXZlKHsgc3VjY2VzczogZnVuY3Rpb24oKSB7fSB9KSB3b3JrLlxuICAgICAgaWYgKCFvcHRpb25zICYmIGF0dHJzKSB7XG4gICAgICAgIHZhciBleHRyYV9rZXlzID0gXy5yZWplY3QoYXR0cnMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXR1cm4gXy5pbmNsdWRlKFtcInN1Y2Nlc3NcIiwgXCJlcnJvclwiLCBcIndhaXRcIl0sIGtleSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZXh0cmFfa2V5cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB2YXIgYWxsX2Z1bmN0aW9ucyA9IHRydWU7XG4gICAgICAgICAgaWYgKF8uaGFzKGF0dHJzLCBcInN1Y2Nlc3NcIikgJiYgIV8uaXNGdW5jdGlvbihhdHRycy5zdWNjZXNzKSkge1xuICAgICAgICAgICAgYWxsX2Z1bmN0aW9ucyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXy5oYXMoYXR0cnMsIFwiZXJyb3JcIikgJiYgIV8uaXNGdW5jdGlvbihhdHRycy5lcnJvcikpIHtcbiAgICAgICAgICAgIGFsbF9mdW5jdGlvbnMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFsbF9mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgYXR0cnMgb2JqZWN0IGxvb2tzIGxpa2UgaXQncyByZWFsbHkgYW4gb3B0aW9ucyBvYmplY3QsXG4gICAgICAgICAgICAvLyBhbmQgdGhlcmUncyBubyBvdGhlciBvcHRpb25zIG9iamVjdCwgc28gbGV0J3MganVzdCB1c2UgaXQuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zYXZlKG51bGwsIGF0dHJzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgb3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucykgfHwge307XG4gICAgICBpZiAob3B0aW9ucy53YWl0KSB7XG4gICAgICAgIGN1cnJlbnQgPSBfLmNsb25lKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZXRPcHRpb25zID0gXy5jbG9uZShvcHRpb25zKSB8fCB7fTtcbiAgICAgIGlmIChzZXRPcHRpb25zLndhaXQpIHtcbiAgICAgICAgc2V0T3B0aW9ucy5zaWxlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIHNldEVycm9yO1xuICAgICAgc2V0T3B0aW9ucy5lcnJvciA9IGZ1bmN0aW9uKG1vZGVsLCBlcnJvcikge1xuICAgICAgICBzZXRFcnJvciA9IGVycm9yO1xuICAgICAgfTtcbiAgICAgIGlmIChhdHRycyAmJiAhdGhpcy5zZXQoYXR0cnMsIHNldE9wdGlvbnMpKSB7XG4gICAgICAgIHJldHVybiBBVi5Qcm9taXNlLmVycm9yKHNldEVycm9yKS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zLCB0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1vZGVsID0gdGhpcztcblxuICAgICAgLy8gSWYgdGhlcmUgaXMgYW55IHVuc2F2ZWQgY2hpbGQsIHNhdmUgaXQgZmlyc3QuXG4gICAgICBtb2RlbC5fcmVmcmVzaENhY2hlKCk7XG5cblxuXG4gICAgICB2YXIgdW5zYXZlZENoaWxkcmVuID0gW107XG4gICAgICB2YXIgdW5zYXZlZEZpbGVzID0gW107XG4gICAgICBBVi5PYmplY3QuX2ZpbmRVbnNhdmVkQ2hpbGRyZW4obW9kZWwuYXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bnNhdmVkQ2hpbGRyZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5zYXZlZEZpbGVzKTtcbiAgICAgIGlmICh1bnNhdmVkQ2hpbGRyZW4ubGVuZ3RoICsgdW5zYXZlZEZpbGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcmV0dXJuIEFWLk9iamVjdC5fZGVlcFNhdmVBc3luYyh0aGlzLmF0dHJpYnV0ZXMsIG1vZGVsKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBtb2RlbC5zYXZlKG51bGwsIG9wdGlvbnMpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIHJldHVybiBBVi5Qcm9taXNlLmVycm9yKGVycm9yKS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zLCBtb2RlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9zdGFydFNhdmUoKTtcbiAgICAgIHRoaXMuX3NhdmluZyA9ICh0aGlzLl9zYXZpbmcgfHwgMCkgKyAxO1xuXG4gICAgICB0aGlzLl9hbGxQcmV2aW91c1NhdmVzID0gdGhpcy5fYWxsUHJldmlvdXNTYXZlcyB8fCBBVi5Qcm9taXNlLmFzKCk7XG4gICAgICB0aGlzLl9hbGxQcmV2aW91c1NhdmVzID0gdGhpcy5fYWxsUHJldmlvdXNTYXZlcy5fY29udGludWVXaXRoKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbWV0aG9kID0gbW9kZWwuaWQgPyAnUFVUJyA6ICdQT1NUJztcblxuICAgICAgICB2YXIganNvbiA9IG1vZGVsLl9nZXRTYXZlSlNPTigpO1xuXG4gICAgICAgIGlmKG1vZGVsLl9mZXRjaFdoZW5TYXZlKXtcbiAgICAgICAgICAvL1NlcGNpYWwtY2FzZSBmZXRjaFdoZW5TYXZlIHdoZW4gdXBkYXRpbmcgb2JqZWN0LlxuICAgICAgICAgIGpzb24uX2ZldGNoV2hlblNhdmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJvdXRlID0gXCJjbGFzc2VzXCI7XG4gICAgICAgIHZhciBjbGFzc05hbWUgPSBtb2RlbC5jbGFzc05hbWU7XG4gICAgICAgIGlmIChtb2RlbC5jbGFzc05hbWUgPT09IFwiX1VzZXJcIiAmJiAhbW9kZWwuaWQpIHtcbiAgICAgICAgICAvLyBTcGVjaWFsLWNhc2UgdXNlciBzaWduLXVwLlxuICAgICAgICAgIHJvdXRlID0gXCJ1c2Vyc1wiO1xuICAgICAgICAgIGNsYXNzTmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy9ob29rIG1ha2VSZXF1ZXN0IGluIG9wdGlvbnMuXG4gICAgICAgIHZhciBtYWtlUmVxdWVzdCA9IG9wdGlvbnMuX21ha2VSZXF1ZXN0IHx8IEFWLl9yZXF1ZXN0O1xuICAgICAgICB2YXIgcmVxdWVzdCA9IG1ha2VSZXF1ZXN0KHJvdXRlLCBjbGFzc05hbWUsIG1vZGVsLmlkLCBtZXRob2QsIGpzb24pO1xuXG4gICAgICAgIHJlcXVlc3QgPSByZXF1ZXN0LnRoZW4oZnVuY3Rpb24ocmVzcCwgc3RhdHVzLCB4aHIpIHtcbiAgICAgICAgICB2YXIgc2VydmVyQXR0cnMgPSBtb2RlbC5wYXJzZShyZXNwLCBzdGF0dXMsIHhocik7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2FpdCkge1xuICAgICAgICAgICAgc2VydmVyQXR0cnMgPSBfLmV4dGVuZChhdHRycyB8fCB7fSwgc2VydmVyQXR0cnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtb2RlbC5fZmluaXNoU2F2ZShzZXJ2ZXJBdHRycyk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMud2FpdCkge1xuICAgICAgICAgICAgbW9kZWwuc2V0KGN1cnJlbnQsIHNldE9wdGlvbnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbW9kZWw7XG5cbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBtb2RlbC5fY2FuY2VsU2F2ZSgpO1xuICAgICAgICAgIHJldHVybiBBVi5Qcm9taXNlLmVycm9yKGVycm9yKTtcblxuICAgICAgICB9KS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zLCBtb2RlbCk7XG5cbiAgICAgICAgcmV0dXJuIHJlcXVlc3Q7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzLl9hbGxQcmV2aW91c1NhdmVzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXN0cm95IHRoaXMgbW9kZWwgb24gdGhlIHNlcnZlciBpZiBpdCB3YXMgYWxyZWFkeSBwZXJzaXN0ZWQuXG4gICAgICogT3B0aW1pc3RpY2FsbHkgcmVtb3ZlcyB0aGUgbW9kZWwgZnJvbSBpdHMgY29sbGVjdGlvbiwgaWYgaXQgaGFzIG9uZS5cbiAgICAgKiBJZiBgd2FpdDogdHJ1ZWAgaXMgcGFzc2VkLCB3YWl0cyBmb3IgdGhlIHNlcnZlciB0byByZXNwb25kXG4gICAgICogYmVmb3JlIHJlbW92YWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiB0aGUgZGVzdHJveVxuICAgICAqICAgICBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgbW9kZWwgPSB0aGlzO1xuXG4gICAgICB2YXIgdHJpZ2dlckRlc3Ryb3kgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbW9kZWwudHJpZ2dlcignZGVzdHJveScsIG1vZGVsLCBtb2RlbC5jb2xsZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgIH07XG5cbiAgICAgIGlmICghdGhpcy5pZCkge1xuICAgICAgICByZXR1cm4gdHJpZ2dlckRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFvcHRpb25zLndhaXQpIHtcbiAgICAgICAgdHJpZ2dlckRlc3Ryb3koKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlcXVlc3QgPVxuICAgICAgICAgIEFWLl9yZXF1ZXN0KFwiY2xhc3Nlc1wiLCB0aGlzLmNsYXNzTmFtZSwgdGhpcy5pZCwgJ0RFTEVURScpO1xuICAgICAgcmV0dXJuIHJlcXVlc3QudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMud2FpdCkge1xuICAgICAgICAgIHRyaWdnZXJEZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgfSkuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucywgdGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGEgcmVzcG9uc2UgaW50byB0aGUgaGFzaCBvZiBhdHRyaWJ1dGVzIHRvIGJlIHNldCBvbiB0aGUgbW9kZWwuXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbihyZXNwLCBzdGF0dXMsIHhocikge1xuICAgICAgdmFyIG91dHB1dCA9IF8uY2xvbmUocmVzcCk7XG4gICAgICBfKFtcImNyZWF0ZWRBdFwiLCBcInVwZGF0ZWRBdFwiXSkuZWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKG91dHB1dFtrZXldKSB7XG4gICAgICAgICAgb3V0cHV0W2tleV0gPSBBVi5fcGFyc2VEYXRlKG91dHB1dFtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIW91dHB1dC51cGRhdGVkQXQpIHtcbiAgICAgICAgb3V0cHV0LnVwZGF0ZWRBdCA9IG91dHB1dC5jcmVhdGVkQXQ7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMuX2V4aXN0ZWQgPSAoc3RhdHVzICE9PSAyMDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBtb2RlbCB3aXRoIGlkZW50aWNhbCBhdHRyaWJ1dGVzIHRvIHRoaXMgb25lLlxuICAgICAqIEByZXR1cm4ge0FWLk9iamVjdH1cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoaXMgb2JqZWN0IGhhcyBuZXZlciBiZWVuIHNhdmVkIHRvIEFWLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNOZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuICF0aGlzLmlkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIG1hbnVhbGx5IGZpcmUgYSBgXCJjaGFuZ2VcImAgZXZlbnQgZm9yIHRoaXMgbW9kZWwgYW5kXG4gICAgICogYSBgXCJjaGFuZ2U6YXR0cmlidXRlXCJgIGV2ZW50IGZvciBlYWNoIGNoYW5nZWQgYXR0cmlidXRlLlxuICAgICAqIENhbGxpbmcgdGhpcyB3aWxsIGNhdXNlIGFsbCBvYmplY3RzIG9ic2VydmluZyB0aGUgbW9kZWwgdG8gdXBkYXRlLlxuICAgICAqL1xuICAgIGNoYW5nZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICB2YXIgY2hhbmdpbmcgPSB0aGlzLl9jaGFuZ2luZztcbiAgICAgIHRoaXMuX2NoYW5naW5nID0gdHJ1ZTtcblxuICAgICAgLy8gU2lsZW50IGNoYW5nZXMgYmVjb21lIHBlbmRpbmcgY2hhbmdlcy5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIEFWLl9vYmplY3RFYWNoKHRoaXMuX3NpbGVudCwgZnVuY3Rpb24oYXR0cikge1xuICAgICAgICBzZWxmLl9wZW5kaW5nW2F0dHJdID0gdHJ1ZTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTaWxlbnQgY2hhbmdlcyBhcmUgdHJpZ2dlcmVkLlxuICAgICAgdmFyIGNoYW5nZXMgPSBfLmV4dGVuZCh7fSwgb3B0aW9ucy5jaGFuZ2VzLCB0aGlzLl9zaWxlbnQpO1xuICAgICAgdGhpcy5fc2lsZW50ID0ge307XG4gICAgICBBVi5fb2JqZWN0RWFjaChjaGFuZ2VzLCBmdW5jdGlvbih1bnVzZWRfdmFsdWUsIGF0dHIpIHtcbiAgICAgICAgc2VsZi50cmlnZ2VyKCdjaGFuZ2U6JyArIGF0dHIsIHNlbGYsIHNlbGYuZ2V0KGF0dHIpLCBvcHRpb25zKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKGNoYW5naW5nKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGlzIGlzIHRvIGdldCBhcm91bmQgbGludCBub3QgbGV0dGluZyB1cyBtYWtlIGEgZnVuY3Rpb24gaW4gYSBsb29wLlxuICAgICAgdmFyIGRlbGV0ZUNoYW5nZWQgPSBmdW5jdGlvbih2YWx1ZSwgYXR0cikge1xuICAgICAgICBpZiAoIXNlbGYuX3BlbmRpbmdbYXR0cl0gJiYgIXNlbGYuX3NpbGVudFthdHRyXSkge1xuICAgICAgICAgIGRlbGV0ZSBzZWxmLmNoYW5nZWRbYXR0cl07XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIENvbnRpbnVlIGZpcmluZyBgXCJjaGFuZ2VcImAgZXZlbnRzIHdoaWxlIHRoZXJlIGFyZSBwZW5kaW5nIGNoYW5nZXMuXG4gICAgICB3aGlsZSAoIV8uaXNFbXB0eSh0aGlzLl9wZW5kaW5nKSkge1xuICAgICAgICB0aGlzLl9wZW5kaW5nID0ge307XG4gICAgICAgIHRoaXMudHJpZ2dlcignY2hhbmdlJywgdGhpcywgb3B0aW9ucyk7XG4gICAgICAgIC8vIFBlbmRpbmcgYW5kIHNpbGVudCBjaGFuZ2VzIHN0aWxsIHJlbWFpbi5cbiAgICAgICAgQVYuX29iamVjdEVhY2godGhpcy5jaGFuZ2VkLCBkZWxldGVDaGFuZ2VkKTtcbiAgICAgICAgc2VsZi5fcHJldmlvdXNBdHRyaWJ1dGVzID0gXy5jbG9uZSh0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jaGFuZ2luZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIG9iamVjdCB3YXMgY3JlYXRlZCBieSB0aGUgQVYgc2VydmVyIHdoZW4gdGhlXG4gICAgICogb2JqZWN0IG1pZ2h0IGhhdmUgYWxyZWFkeSBiZWVuIHRoZXJlIChlLmcuIGluIHRoZSBjYXNlIG9mIGEgRmFjZWJvb2tcbiAgICAgKiBsb2dpbilcbiAgICAgKi9cbiAgICBleGlzdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9leGlzdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgaWYgdGhlIG1vZGVsIGhhcyBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IDxjb2RlPlwiY2hhbmdlXCI8L2NvZGU+XG4gICAgICogZXZlbnQuICBJZiB5b3Ugc3BlY2lmeSBhbiBhdHRyaWJ1dGUgbmFtZSwgZGV0ZXJtaW5lIGlmIHRoYXQgYXR0cmlidXRlXG4gICAgICogaGFzIGNoYW5nZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgT3B0aW9uYWwgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqL1xuICAgIGhhc0NoYW5nZWQ6IGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gIV8uaXNFbXB0eSh0aGlzLmNoYW5nZWQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY2hhbmdlZCAmJiBfLmhhcyh0aGlzLmNoYW5nZWQsIGF0dHIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIG9iamVjdCBjb250YWluaW5nIGFsbCB0aGUgYXR0cmlidXRlcyB0aGF0IGhhdmUgY2hhbmdlZCwgb3JcbiAgICAgKiBmYWxzZSBpZiB0aGVyZSBhcmUgbm8gY2hhbmdlZCBhdHRyaWJ1dGVzLiBVc2VmdWwgZm9yIGRldGVybWluaW5nIHdoYXRcbiAgICAgKiBwYXJ0cyBvZiBhIHZpZXcgbmVlZCB0byBiZSB1cGRhdGVkIGFuZC9vciB3aGF0IGF0dHJpYnV0ZXMgbmVlZCB0byBiZVxuICAgICAqIHBlcnNpc3RlZCB0byB0aGUgc2VydmVyLiBVbnNldCBhdHRyaWJ1dGVzIHdpbGwgYmUgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICAgKiBZb3UgY2FuIGFsc28gcGFzcyBhbiBhdHRyaWJ1dGVzIG9iamVjdCB0byBkaWZmIGFnYWluc3QgdGhlIG1vZGVsLFxuICAgICAqIGRldGVybWluaW5nIGlmIHRoZXJlICp3b3VsZCBiZSogYSBjaGFuZ2UuXG4gICAgICovXG4gICAgY2hhbmdlZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uKGRpZmYpIHtcbiAgICAgIGlmICghZGlmZikge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNDaGFuZ2VkKCkgPyBfLmNsb25lKHRoaXMuY2hhbmdlZCkgOiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFuZ2VkID0ge307XG4gICAgICB2YXIgb2xkID0gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzO1xuICAgICAgQVYuX29iamVjdEVhY2goZGlmZiwgZnVuY3Rpb24oZGlmZlZhbCwgYXR0cikge1xuICAgICAgICBpZiAoIV8uaXNFcXVhbChvbGRbYXR0cl0sIGRpZmZWYWwpKSB7XG4gICAgICAgICAgY2hhbmdlZFthdHRyXSA9IGRpZmZWYWw7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNoYW5nZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByZXZpb3VzIHZhbHVlIG9mIGFuIGF0dHJpYnV0ZSwgcmVjb3JkZWQgYXQgdGhlIHRpbWUgdGhlIGxhc3RcbiAgICAgKiA8Y29kZT5cImNoYW5nZVwiPC9jb2RlPiBldmVudCB3YXMgZmlyZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGF0dHIgTmFtZSBvZiB0aGUgYXR0cmlidXRlIHRvIGdldC5cbiAgICAgKi9cbiAgICBwcmV2aW91czogZnVuY3Rpb24oYXR0cikge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8ICF0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmlvdXNBdHRyaWJ1dGVzW2F0dHJdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGFsbCBvZiB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbW9kZWwgYXQgdGhlIHRpbWUgb2YgdGhlIHByZXZpb3VzXG4gICAgICogPGNvZGU+XCJjaGFuZ2VcIjwvY29kZT4gZXZlbnQuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHByZXZpb3VzQXR0cmlidXRlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXy5jbG9uZSh0aGlzLl9wcmV2aW91c0F0dHJpYnV0ZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgdGhlIG1vZGVsIGlzIGN1cnJlbnRseSBpbiBhIHZhbGlkIHN0YXRlLiBJdCdzIG9ubHkgcG9zc2libGUgdG9cbiAgICAgKiBnZXQgaW50byBhbiAqaW52YWxpZCogc3RhdGUgaWYgeW91J3JlIHVzaW5nIHNpbGVudCBjaGFuZ2VzLlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNWYWxpZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXRoaXMudmFsaWRhdGUodGhpcy5hdHRyaWJ1dGVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogWW91IHNob3VsZCBub3QgY2FsbCB0aGlzIGZ1bmN0aW9uIGRpcmVjdGx5IHVubGVzcyB5b3Ugc3ViY2xhc3NcbiAgICAgKiA8Y29kZT5BVi5PYmplY3Q8L2NvZGU+LCBpbiB3aGljaCBjYXNlIHlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2RcbiAgICAgKiB0byBwcm92aWRlIGFkZGl0aW9uYWwgdmFsaWRhdGlvbiBvbiA8Y29kZT5zZXQ8L2NvZGU+IGFuZFxuICAgICAqIDxjb2RlPnNhdmU8L2NvZGU+LiAgWW91ciBpbXBsZW1lbnRhdGlvbiBzaG91bGQgcmV0dXJuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cnMgVGhlIGN1cnJlbnQgZGF0YSB0byB2YWxpZGF0ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLWxpa2Ugb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7fSBGYWxzZSBpZiB0aGUgZGF0YSBpcyB2YWxpZC4gIEFuIGVycm9yIG9iamVjdCBvdGhlcndpc2UuXG4gICAgICogQHNlZSBBVi5PYmplY3Qjc2V0XG4gICAgICovXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoXy5oYXMoYXR0cnMsIFwiQUNMXCIpICYmICEoYXR0cnMuQUNMIGluc3RhbmNlb2YgQVYuQUNMKSkge1xuICAgICAgICByZXR1cm4gbmV3IEFWLkVycm9yKEFWLkVycm9yLk9USEVSX0NBVVNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiQUNMIG11c3QgYmUgYSBBVi5BQ0wuXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSdW4gdmFsaWRhdGlvbiBhZ2FpbnN0IGEgc2V0IG9mIGluY29taW5nIGF0dHJpYnV0ZXMsIHJldHVybmluZyBgdHJ1ZWBcbiAgICAgKiBpZiBhbGwgaXMgd2VsbC4gSWYgYSBzcGVjaWZpYyBgZXJyb3JgIGNhbGxiYWNrIGhhcyBiZWVuIHBhc3NlZCxcbiAgICAgKiBjYWxsIHRoYXQgaW5zdGVhZCBvZiBmaXJpbmcgdGhlIGdlbmVyYWwgYFwiZXJyb3JcImAgZXZlbnQuXG4gICAgICovXG4gICAgX3ZhbGlkYXRlOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgaWYgKG9wdGlvbnMuc2lsZW50IHx8ICF0aGlzLnZhbGlkYXRlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgYXR0cnMgPSBfLmV4dGVuZCh7fSwgdGhpcy5hdHRyaWJ1dGVzLCBhdHRycyk7XG4gICAgICB2YXIgZXJyb3IgPSB0aGlzLnZhbGlkYXRlKGF0dHJzLCBvcHRpb25zKTtcbiAgICAgIGlmICghZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVycm9yKSB7XG4gICAgICAgIG9wdGlvbnMuZXJyb3IodGhpcywgZXJyb3IsIG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdlcnJvcicsIHRoaXMsIGVycm9yLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgQUNMIGZvciB0aGlzIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7QVYuQUNMfSBBbiBpbnN0YW5jZSBvZiBBVi5BQ0wuXG4gICAgICogQHNlZSBBVi5PYmplY3QjZ2V0XG4gICAgICovXG4gICAgZ2V0QUNMOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChcIkFDTFwiKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgQUNMIHRvIGJlIHVzZWQgZm9yIHRoaXMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7QVYuQUNMfSBhY2wgQW4gaW5zdGFuY2Ugb2YgQVYuQUNMLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbmFsIEJhY2tib25lLWxpa2Ugb3B0aW9ucyBvYmplY3QgdG8gYmVcbiAgICAgKiAgICAgcGFzc2VkIGluIHRvIHNldC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIHRoZSBzZXQgcGFzc2VkIHZhbGlkYXRpb24uXG4gICAgICogQHNlZSBBVi5PYmplY3Qjc2V0XG4gICAgICovXG4gICAgc2V0QUNMOiBmdW5jdGlvbihhY2wsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChcIkFDTFwiLCBhY2wsIG9wdGlvbnMpO1xuICAgIH1cblxuICB9KTtcblxuICAgLyoqXG4gICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIGEgc3ViY2xhc3Mgb2YgQVYuT2JqZWN0IGZvciB0aGUgZ2l2ZSBjbGFzc25hbWVcbiAgICAqIGFuZCBpZC5cbiAgICAqIEBwYXJhbSAge1N0cmluZ30gY2xhc3NOYW1lIFRoZSBuYW1lIG9mIHRoZSBBViBjbGFzcyBiYWNraW5nIHRoaXMgbW9kZWwuXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgVGhlIG9iamVjdCBpZCBvZiB0aGlzIG1vZGVsLlxuICAgICogQHJldHVybiB7QVYuT2JqZWN0fSBBIG5ldyBzdWJjbGFzcyBpbnN0YW5jZSBvZiBBVi5PYmplY3QuXG4gICAgKi9cbiAgIEFWLk9iamVjdC5jcmVhdGVXaXRob3V0RGF0YSA9IGZ1bmN0aW9uKGNsYXNzTmFtZSwgaWQsIGhhc0RhdGEpe1xuICAgICB2YXIgcmVzdWx0ID0gbmV3IEFWLk9iamVjdChjbGFzc05hbWUpO1xuICAgICByZXN1bHQuaWQgPSBpZDtcbiAgICAgcmVzdWx0Ll9oYXNEYXRhID0gaGFzRGF0YTtcbiAgICAgcmV0dXJuIHJlc3VsdDtcbiAgIH07XG4gICAvKipcbiAgICAqIERlbGV0ZSBvYmplY3RzIGluIGJhdGNoLlRoZSBvYmplY3RzIGNsYXNzTmFtZSBtdXN0IGJlIHRoZSBzYW1lLlxuICAgICogQHBhcmFtIHtBcnJheX0gVGhlIFBhcnNlT2JqZWN0IGFycmF5IHRvIGJlIGRlbGV0ZWQuXG4gICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBTdGFuZGFyZCBvcHRpb25zIG9iamVjdCB3aXRoIHN1Y2Nlc3MgYW5kIGVycm9yXG4gICAgKiAgICAgY2FsbGJhY2tzLlxuICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gdGhlIHNhdmVcbiAgICAqICAgICBjb21wbGV0ZXMuXG4gICAgKi9cbiAgIEFWLk9iamVjdC5kZXN0cm95QWxsID0gZnVuY3Rpb24ob2JqZWN0cywgb3B0aW9ucyl7XG4gICAgICBpZihvYmplY3RzID09IG51bGwgfHwgb2JqZWN0cy5sZW5ndGggPT0gMCl7XG5cdFx0ICByZXR1cm4gQVYuUHJvbWlzZS5hcygpLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgdmFyIGNsYXNzTmFtZSA9IG9iamVjdHNbMF0uY2xhc3NOYW1lO1xuICAgICAgdmFyIGlkID0gXCJcIjtcbiAgICAgIHZhciB3YXNGaXJzdCA9IHRydWU7XG4gICAgICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqKXtcbiAgICAgICAgaWYob2JqLmNsYXNzTmFtZSAhPSBjbGFzc05hbWUpXG5cdFx0XHQgIHRocm93IFwiQVYuT2JqZWN0LmRlc3Ryb3lBbGwgcmVxdWlyZXMgdGhlIGFyZ3VtZW50IG9iamVjdCBhcnJheSdzIGNsYXNzTmFtZXMgbXVzdCBiZSB0aGUgc2FtZVwiO1xuICAgICAgICAgIGlmKCFvYmouaWQpXG4gICAgICAgICAgICAgIHRocm93IFwiQ291bGQgbm90IGRlbGV0ZSB1bnNhdmVkIG9iamVjdFwiO1xuICAgICAgICAgIGlmKHdhc0ZpcnN0KXtcbiAgICAgICAgICAgICAgaWQgPSBvYmouaWQ7XG4gICAgICAgICAgICAgIHdhc0ZpcnN0ID0gZmFsc2U7XG4gICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIGlkID0gaWQgKyAnLCcgKyBvYmouaWQ7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgcmVxdWVzdCA9XG4gICAgICAgICAgQVYuX3JlcXVlc3QoXCJjbGFzc2VzXCIsIGNsYXNzTmFtZSwgaWQsICdERUxFVEUnKTtcbiAgICAgIHJldHVybiByZXF1ZXN0Ll90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgc3ViY2xhc3MgZm9yIG1ha2luZyBuZXcgaW5zdGFuY2VzIG9mIHRoZSBnaXZlblxuICAgKiBjbGFzc05hbWUgc3RyaW5nLlxuICAgKi9cbiAgQVYuT2JqZWN0Ll9nZXRTdWJjbGFzcyA9IGZ1bmN0aW9uKGNsYXNzTmFtZSkge1xuICAgIGlmICghXy5pc1N0cmluZyhjbGFzc05hbWUpKSB7XG4gICAgICB0aHJvdyBcIkFWLk9iamVjdC5fZ2V0U3ViY2xhc3MgcmVxdWlyZXMgYSBzdHJpbmcgYXJndW1lbnQuXCI7XG4gICAgfVxuICAgIHZhciBPYmplY3RDbGFzcyA9IEFWLk9iamVjdC5fY2xhc3NNYXBbY2xhc3NOYW1lXTtcbiAgICBpZiAoIU9iamVjdENsYXNzKSB7XG4gICAgICBPYmplY3RDbGFzcyA9IEFWLk9iamVjdC5leHRlbmQoY2xhc3NOYW1lKTtcbiAgICAgIEFWLk9iamVjdC5fY2xhc3NNYXBbY2xhc3NOYW1lXSA9IE9iamVjdENsYXNzO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0Q2xhc3M7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBzdWJjbGFzcyBvZiBBVi5PYmplY3QgZm9yIHRoZSBnaXZlbiBjbGFzc25hbWUuXG4gICAqL1xuICBBVi5PYmplY3QuX2NyZWF0ZSA9IGZ1bmN0aW9uKGNsYXNzTmFtZSwgYXR0cmlidXRlcywgb3B0aW9ucykge1xuICAgIHZhciBPYmplY3RDbGFzcyA9IEFWLk9iamVjdC5fZ2V0U3ViY2xhc3MoY2xhc3NOYW1lKTtcbiAgICByZXR1cm4gbmV3IE9iamVjdENsYXNzKGF0dHJpYnV0ZXMsIG9wdGlvbnMpO1xuICB9O1xuXG4gIC8vIFNldCB1cCBhIG1hcCBvZiBjbGFzc05hbWUgdG8gY2xhc3Mgc28gdGhhdCB3ZSBjYW4gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb2ZcbiAgLy8gQVYgT2JqZWN0cyBmcm9tIEpTT04gYXV0b21hdGljYWxseS5cbiAgQVYuT2JqZWN0Ll9jbGFzc01hcCA9IHt9O1xuXG4gIEFWLk9iamVjdC5fZXh0ZW5kID0gQVYuX2V4dGVuZDtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBtb2RlbCB3aXRoIGRlZmluZWQgYXR0cmlidXRlcyxcbiAgICogSXQncyB0aGUgc2FtZSB3aXRoXG4gICAqIDxwcmU+XG4gICAqICAgbmV3IEFWLk9iamVjdChhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgICogIDwvcHJlPlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXR0cmlidXRlcyBUaGUgaW5pdGlhbCBzZXQgb2YgZGF0YSB0byBzdG9yZSBpbiB0aGUgb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIHNldCBvZiBCYWNrYm9uZS1saWtlIG9wdGlvbnMgZm9yIGNyZWF0aW5nIHRoZVxuICAgKiAgICAgb2JqZWN0LiAgVGhlIG9ubHkgb3B0aW9uIGN1cnJlbnRseSBzdXBwb3J0ZWQgaXMgXCJjb2xsZWN0aW9uXCIuXG4gICAqIEByZXR1cm4ge0FWLk9iamVjdH1cbiAgICogQHNpbmNlIHYwLjQuNFxuICAgKiBAc2VlIEFWLk9iamVjdFxuICAgKiBAc2VlIEFWLk9iamVjdC5leHRlbmRcbiAgICovXG4gIEFWLk9iamVjdC5uZXcgPSBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKXtcbiAgICByZXR1cm4gbmV3IEFWLk9iamVjdChhdHRyaWJ1dGVzLCBvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdWJjbGFzcyBvZiBBVi5PYmplY3QgZm9yIHRoZSBnaXZlbiBBViBjbGFzcyBuYW1lLlxuICAgKlxuICAgKiA8cD5FdmVyeSBleHRlbnNpb24gb2YgYSBBViBjbGFzcyB3aWxsIGluaGVyaXQgZnJvbSB0aGUgbW9zdCByZWNlbnRcbiAgICogcHJldmlvdXMgZXh0ZW5zaW9uIG9mIHRoYXQgY2xhc3MuIFdoZW4gYSBBVi5PYmplY3QgaXMgYXV0b21hdGljYWxseVxuICAgKiBjcmVhdGVkIGJ5IHBhcnNpbmcgSlNPTiwgaXQgd2lsbCB1c2UgdGhlIG1vc3QgcmVjZW50IGV4dGVuc2lvbiBvZiB0aGF0XG4gICAqIGNsYXNzLjwvcD5cbiAgICpcbiAgICogPHA+WW91IHNob3VsZCBjYWxsIGVpdGhlcjo8cHJlPlxuICAgKiAgICAgdmFyIE15Q2xhc3MgPSBBVi5PYmplY3QuZXh0ZW5kKFwiTXlDbGFzc1wiLCB7XG4gICAqICAgICAgICAgPGk+SW5zdGFuY2UgcHJvcGVydGllczwvaT5cbiAgICogICAgIH0sIHtcbiAgICogICAgICAgICA8aT5DbGFzcyBwcm9wZXJ0aWVzPC9pPlxuICAgKiAgICAgfSk7PC9wcmU+XG4gICAqIG9yLCBmb3IgQmFja2JvbmUgY29tcGF0aWJpbGl0eTo8cHJlPlxuICAgKiAgICAgdmFyIE15Q2xhc3MgPSBBVi5PYmplY3QuZXh0ZW5kKHtcbiAgICogICAgICAgICBjbGFzc05hbWU6IFwiTXlDbGFzc1wiLFxuICAgKiAgICAgICAgIDxpPk90aGVyIGluc3RhbmNlIHByb3BlcnRpZXM8L2k+XG4gICAqICAgICB9LCB7XG4gICAqICAgICAgICAgPGk+Q2xhc3MgcHJvcGVydGllczwvaT5cbiAgICogICAgIH0pOzwvcHJlPjwvcD5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNsYXNzTmFtZSBUaGUgbmFtZSBvZiB0aGUgQVYgY2xhc3MgYmFja2luZyB0aGlzIG1vZGVsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvdG9Qcm9wcyBJbnN0YW5jZSBwcm9wZXJ0aWVzIHRvIGFkZCB0byBpbnN0YW5jZXMgb2YgdGhlXG4gICAqICAgICBjbGFzcyByZXR1cm5lZCBmcm9tIHRoaXMgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2xhc3NQcm9wcyBDbGFzcyBwcm9wZXJ0aWVzIHRvIGFkZCB0aGUgY2xhc3MgcmV0dXJuZWQgZnJvbVxuICAgKiAgICAgdGhpcyBtZXRob2QuXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIG5ldyBzdWJjbGFzcyBvZiBBVi5PYmplY3QuXG4gICAqL1xuICBBVi5PYmplY3QuZXh0ZW5kID0gZnVuY3Rpb24oY2xhc3NOYW1lLCBwcm90b1Byb3BzLCBjbGFzc1Byb3BzKSB7XG4gICAgLy8gSGFuZGxlIHRoZSBjYXNlIHdpdGggb25seSB0d28gYXJncy5cbiAgICBpZiAoIV8uaXNTdHJpbmcoY2xhc3NOYW1lKSkge1xuICAgICAgaWYgKGNsYXNzTmFtZSAmJiBfLmhhcyhjbGFzc05hbWUsIFwiY2xhc3NOYW1lXCIpKSB7XG4gICAgICAgIHJldHVybiBBVi5PYmplY3QuZXh0ZW5kKGNsYXNzTmFtZS5jbGFzc05hbWUsIGNsYXNzTmFtZSwgcHJvdG9Qcm9wcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBcIkFWLk9iamVjdC5leHRlbmQncyBmaXJzdCBhcmd1bWVudCBzaG91bGQgYmUgdGhlIGNsYXNzTmFtZS5cIik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgc29tZW9uZSB0cmllcyB0byBzdWJjbGFzcyBcIlVzZXJcIiwgY29lcmNlIGl0IHRvIHRoZSByaWdodCB0eXBlLlxuICAgIGlmIChjbGFzc05hbWUgPT09IFwiVXNlclwiKSB7XG4gICAgICBjbGFzc05hbWUgPSBcIl9Vc2VyXCI7XG4gICAgfVxuXG4gICAgdmFyIE5ld0NsYXNzT2JqZWN0ID0gbnVsbDtcbiAgICBpZiAoXy5oYXMoQVYuT2JqZWN0Ll9jbGFzc01hcCwgY2xhc3NOYW1lKSkge1xuICAgICAgdmFyIE9sZENsYXNzT2JqZWN0ID0gQVYuT2JqZWN0Ll9jbGFzc01hcFtjbGFzc05hbWVdO1xuICAgICAgLy8gVGhpcyBuZXcgc3ViY2xhc3MgaGFzIGJlZW4gdG9sZCB0byBleHRlbmQgYm90aCBmcm9tIFwidGhpc1wiIGFuZCBmcm9tXG4gICAgICAvLyBPbGRDbGFzc09iamVjdC4gVGhpcyBpcyBtdWx0aXBsZSBpbmhlcml0YW5jZSwgd2hpY2ggaXNuJ3Qgc3VwcG9ydGVkLlxuICAgICAgLy8gRm9yIG5vdywgbGV0J3MganVzdCBwaWNrIG9uZS5cbiAgICAgIE5ld0NsYXNzT2JqZWN0ID0gT2xkQ2xhc3NPYmplY3QuX2V4dGVuZChwcm90b1Byb3BzLCBjbGFzc1Byb3BzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvdG9Qcm9wcyA9IHByb3RvUHJvcHMgfHwge307XG4gICAgICBwcm90b1Byb3BzLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcbiAgICAgIE5ld0NsYXNzT2JqZWN0ID0gdGhpcy5fZXh0ZW5kKHByb3RvUHJvcHMsIGNsYXNzUHJvcHMpO1xuICAgIH1cbiAgICAvLyBFeHRlbmRpbmcgYSBzdWJjbGFzcyBzaG91bGQgcmV1c2UgdGhlIGNsYXNzbmFtZSBhdXRvbWF0aWNhbGx5LlxuICAgIE5ld0NsYXNzT2JqZWN0LmV4dGVuZCA9IGZ1bmN0aW9uKGFyZzApIHtcbiAgICAgIGlmIChfLmlzU3RyaW5nKGFyZzApIHx8IChhcmcwICYmIF8uaGFzKGFyZzAsIFwiY2xhc3NOYW1lXCIpKSkge1xuICAgICAgICByZXR1cm4gQVYuT2JqZWN0LmV4dGVuZC5hcHBseShOZXdDbGFzc09iamVjdCwgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXdBcmd1bWVudHMgPSBbY2xhc3NOYW1lXS5jb25jYXQoQVYuXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgICAgcmV0dXJuIEFWLk9iamVjdC5leHRlbmQuYXBwbHkoTmV3Q2xhc3NPYmplY3QsIG5ld0FyZ3VtZW50cyk7XG4gICAgfTtcbiAgICBOZXdDbGFzc09iamVjdC5uZXcgPSBmdW5jdGlvbihhdHRyaWJ1dGVzLCBvcHRpb25zKXtcbiAgICAgIHJldHVybiBuZXcgTmV3Q2xhc3NPYmplY3QoYXR0cmlidXRlcywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBBVi5PYmplY3QuX2NsYXNzTWFwW2NsYXNzTmFtZV0gPSBOZXdDbGFzc09iamVjdDtcbiAgICByZXR1cm4gTmV3Q2xhc3NPYmplY3Q7XG4gIH07XG5cbiAgQVYuT2JqZWN0Ll9maW5kVW5zYXZlZENoaWxkcmVuID0gZnVuY3Rpb24ob2JqZWN0LCBjaGlsZHJlbiwgZmlsZXMpIHtcbiAgICBBVi5fdHJhdmVyc2Uob2JqZWN0LCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBVi5PYmplY3QpIHtcbiAgICAgICAgb2JqZWN0Ll9yZWZyZXNoQ2FjaGUoKTtcbiAgICAgICAgaWYgKG9iamVjdC5kaXJ0eSgpKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFWLkZpbGUpIHtcbiAgICAgICAgaWYgKCFvYmplY3QudXJsKCkgJiYgIW9iamVjdC5pZCkge1xuICAgICAgICAgIGZpbGVzLnB1c2gob2JqZWN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgQVYuT2JqZWN0Ll9jYW5CZVNlcmlhbGl6ZWRBc1ZhbHVlID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIGNhbkJlU2VyaWFsaXplZEFzVmFsdWUgPSB0cnVlO1xuXG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFWLk9iamVjdCB8fCBvYmplY3QgaW5zdGFuY2VvZiBBVi5GaWxlKSB7XG4gICAgICBjYW5CZVNlcmlhbGl6ZWRBc1ZhbHVlID0gISFvYmplY3QuaWQ7XG5cbiAgICB9IGVsc2UgaWYgKF8uaXNBcnJheShvYmplY3QpKSB7XG4gICAgICBBVi5fYXJyYXlFYWNoKG9iamVjdCwgZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgaWYgKCFBVi5PYmplY3QuX2NhbkJlU2VyaWFsaXplZEFzVmFsdWUoY2hpbGQpKSB7XG4gICAgICAgICAgY2FuQmVTZXJpYWxpemVkQXNWYWx1ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIH0gZWxzZSBpZiAoXy5pc09iamVjdChvYmplY3QpKSB7XG4gICAgICBBVi5fb2JqZWN0RWFjaChvYmplY3QsIGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgIGlmICghQVYuT2JqZWN0Ll9jYW5CZVNlcmlhbGl6ZWRBc1ZhbHVlKGNoaWxkKSkge1xuICAgICAgICAgIGNhbkJlU2VyaWFsaXplZEFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNhbkJlU2VyaWFsaXplZEFzVmFsdWU7XG4gIH07XG5cbiAgQVYuT2JqZWN0Ll9kZWVwU2F2ZUFzeW5jID0gZnVuY3Rpb24ob2JqZWN0LCBtb2RlbCkge1xuICAgIHZhciB1bnNhdmVkQ2hpbGRyZW4gPSBbXTtcbiAgICB2YXIgdW5zYXZlZEZpbGVzID0gW107XG4gICAgQVYuT2JqZWN0Ll9maW5kVW5zYXZlZENoaWxkcmVuKG9iamVjdCwgdW5zYXZlZENoaWxkcmVuLCB1bnNhdmVkRmlsZXMpO1xuICAgIGlmKG1vZGVsKSB7XG4gICAgICB1bnNhdmVkQ2hpbGRyZW4gPSBfLmZpbHRlcih1bnNhdmVkQ2hpbGRyZW4sIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ICE9IG1vZGVsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHByb21pc2UgPSBBVi5Qcm9taXNlLmFzKCk7XG4gICAgXy5lYWNoKHVuc2F2ZWRGaWxlcywgZnVuY3Rpb24oZmlsZSkge1xuICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZpbGUuc2F2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgb2JqZWN0cyA9IF8udW5pcSh1bnNhdmVkQ2hpbGRyZW4pO1xuICAgIHZhciByZW1haW5pbmcgPSBfLnVuaXEob2JqZWN0cyk7XG5cbiAgICByZXR1cm4gcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFWLlByb21pc2UuX2NvbnRpbnVlV2hpbGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZW1haW5pbmcubGVuZ3RoID4gMDtcbiAgICAgIH0sIGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIC8vIEdhdGhlciB1cCBhbGwgdGhlIG9iamVjdHMgdGhhdCBjYW4gYmUgc2F2ZWQgaW4gdGhpcyBiYXRjaC5cbiAgICAgICAgdmFyIGJhdGNoID0gW107XG4gICAgICAgIHZhciBuZXdSZW1haW5pbmcgPSBbXTtcbiAgICAgICAgQVYuX2FycmF5RWFjaChyZW1haW5pbmcsIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICAgIC8vIExpbWl0IGJhdGNoZXMgdG8gMjAgb2JqZWN0cy5cbiAgICAgICAgICBpZiAoYmF0Y2gubGVuZ3RoID4gMjApIHtcbiAgICAgICAgICAgIG5ld1JlbWFpbmluZy5wdXNoKG9iamVjdCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9iamVjdC5fY2FuQmVTZXJpYWxpemVkKCkpIHtcbiAgICAgICAgICAgIGJhdGNoLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3UmVtYWluaW5nLnB1c2gob2JqZWN0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZW1haW5pbmcgPSBuZXdSZW1haW5pbmc7XG5cbiAgICAgICAgLy8gSWYgd2UgY2FuJ3Qgc2F2ZSBhbnkgb2JqZWN0cywgdGhlcmUgbXVzdCBiZSBhIGNpcmN1bGFyIHJlZmVyZW5jZS5cbiAgICAgICAgaWYgKGJhdGNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBBVi5Qcm9taXNlLmVycm9yKFxuICAgICAgICAgICAgbmV3IEFWLkVycm9yKEFWLkVycm9yLk9USEVSX0NBVVNFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiVHJpZWQgdG8gc2F2ZSBhIGJhdGNoIHdpdGggYSBjeWNsZS5cIikpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVzZXJ2ZSBhIHNwb3QgaW4gZXZlcnkgb2JqZWN0J3Mgc2F2ZSBxdWV1ZS5cbiAgICAgICAgdmFyIHJlYWR5VG9TdGFydCA9IEFWLlByb21pc2Uud2hlbihfLm1hcChiYXRjaCwgZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdC5fYWxsUHJldmlvdXNTYXZlcyB8fCBBVi5Qcm9taXNlLmFzKCk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgdmFyIGJhdGNoRmluaXNoZWQgPSBuZXcgQVYuUHJvbWlzZSgpO1xuICAgICAgICBBVi5fYXJyYXlFYWNoKGJhdGNoLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICBvYmplY3QuX2FsbFByZXZpb3VzU2F2ZXMgPSBiYXRjaEZpbmlzaGVkO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTYXZlIGEgc2luZ2xlIGJhdGNoLCB3aGV0aGVyIHByZXZpb3VzIHNhdmVzIHN1Y2NlZWRlZCBvciBmYWlsZWQuXG4gICAgICAgIHJldHVybiByZWFkeVRvU3RhcnQuX2NvbnRpbnVlV2l0aChmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gQVYuX3JlcXVlc3QoXCJiYXRjaFwiLCBudWxsLCBudWxsLCBcIlBPU1RcIiwge1xuICAgICAgICAgICAgcmVxdWVzdHM6IF8ubWFwKGJhdGNoLCBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgICAgICAgdmFyIGpzb24gPSBvYmplY3QuX2dldFNhdmVKU09OKCk7XG4gICAgICAgICAgICAgIHZhciBtZXRob2QgPSBcIlBPU1RcIjtcblxuICAgICAgICAgICAgICB2YXIgcGF0aCA9IFwiLzEuMS9jbGFzc2VzL1wiICsgb2JqZWN0LmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgaWYgKG9iamVjdC5pZCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBwYXRoICsgXCIvXCIgKyBvYmplY3QuaWQ7XG4gICAgICAgICAgICAgICAgbWV0aG9kID0gXCJQVVRcIjtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIG9iamVjdC5fc3RhcnRTYXZlKCk7XG5cbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIGJvZHk6IGpzb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlLCBzdGF0dXMsIHhocikge1xuICAgICAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAgICAgQVYuX2FycmF5RWFjaChiYXRjaCwgZnVuY3Rpb24ob2JqZWN0LCBpKSB7XG4gICAgICAgICAgICAgIGlmIChyZXNwb25zZVtpXS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgb2JqZWN0Ll9maW5pc2hTYXZlKFxuICAgICAgICAgICAgICAgICAgb2JqZWN0LnBhcnNlKHJlc3BvbnNlW2ldLnN1Y2Nlc3MsIHN0YXR1cywgeGhyKSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSBlcnJvciB8fCByZXNwb25zZVtpXS5lcnJvcjtcbiAgICAgICAgICAgICAgICBvYmplY3QuX2NhbmNlbFNhdmUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIEFWLlByb21pc2UuZXJyb3IoXG4gICAgICAgICAgICAgICAgbmV3IEFWLkVycm9yKGVycm9yLmNvZGUsIGVycm9yLmVycm9yKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGJhdGNoRmluaXNoZWQucmVzb2x2ZShyZXN1bHRzKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBiYXRjaEZpbmlzaGVkLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gQVYuUHJvbWlzZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSk7XG4gIH07XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL29iamVjdC5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEFWKSB7XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBBIEFWLk9wIGlzIGFuIGF0b21pYyBvcGVyYXRpb24gdGhhdCBjYW4gYmUgYXBwbGllZCB0byBhIGZpZWxkIGluIGFcbiAgICogQVYuT2JqZWN0LiBGb3IgZXhhbXBsZSwgY2FsbGluZyA8Y29kZT5vYmplY3Quc2V0KFwiZm9vXCIsIFwiYmFyXCIpPC9jb2RlPlxuICAgKiBpcyBhbiBleGFtcGxlIG9mIGEgQVYuT3AuU2V0LiBDYWxsaW5nIDxjb2RlPm9iamVjdC51bnNldChcImZvb1wiKTwvY29kZT5cbiAgICogaXMgYSBBVi5PcC5VbnNldC4gVGhlc2Ugb3BlcmF0aW9ucyBhcmUgc3RvcmVkIGluIGEgQVYuT2JqZWN0IGFuZFxuICAgKiBzZW50IHRvIHRoZSBzZXJ2ZXIgYXMgcGFydCBvZiA8Y29kZT5vYmplY3Quc2F2ZSgpPC9jb2RlPiBvcGVyYXRpb25zLlxuICAgKiBJbnN0YW5jZXMgb2YgQVYuT3Agc2hvdWxkIGJlIGltbXV0YWJsZS5cbiAgICpcbiAgICogWW91IHNob3VsZCBub3QgY3JlYXRlIHN1YmNsYXNzZXMgb2YgQVYuT3Agb3IgaW5zdGFudGlhdGUgQVYuT3BcbiAgICogZGlyZWN0bHkuXG4gICAqL1xuICBBVi5PcCA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX2luaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICBBVi5PcC5wcm90b3R5cGUgPSB7XG4gICAgX2luaXRpYWxpemU6IGZ1bmN0aW9uKCkge31cbiAgfTtcblxuICBfLmV4dGVuZChBVi5PcCwge1xuICAgIC8qKlxuICAgICAqIFRvIGNyZWF0ZSBhIG5ldyBPcCwgY2FsbCBBVi5PcC5fZXh0ZW5kKCk7XG4gICAgICovXG4gICAgX2V4dGVuZDogQVYuX2V4dGVuZCxcblxuICAgIC8vIEEgbWFwIG9mIF9fb3Agc3RyaW5nIHRvIGRlY29kZXIgZnVuY3Rpb24uXG4gICAgX29wRGVjb2Rlck1hcDoge30sXG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlcnMgYSBmdW5jdGlvbiB0byBjb252ZXJ0IGEganNvbiBvYmplY3Qgd2l0aCBhbiBfX29wIGZpZWxkIGludG8gYW5cbiAgICAgKiBpbnN0YW5jZSBvZiBhIHN1YmNsYXNzIG9mIEFWLk9wLlxuICAgICAqL1xuICAgIF9yZWdpc3RlckRlY29kZXI6IGZ1bmN0aW9uKG9wTmFtZSwgZGVjb2Rlcikge1xuICAgICAgQVYuT3AuX29wRGVjb2Rlck1hcFtvcE5hbWVdID0gZGVjb2RlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYSBqc29uIG9iamVjdCBpbnRvIGFuIGluc3RhbmNlIG9mIGEgc3ViY2xhc3Mgb2YgQVYuT3AuXG4gICAgICovXG4gICAgX2RlY29kZTogZnVuY3Rpb24oanNvbikge1xuICAgICAgdmFyIGRlY29kZXIgPSBBVi5PcC5fb3BEZWNvZGVyTWFwW2pzb24uX19vcF07XG4gICAgICBpZiAoZGVjb2Rlcikge1xuICAgICAgICByZXR1cm4gZGVjb2Rlcihqc29uKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvKlxuICAgKiBBZGQgYSBoYW5kbGVyIGZvciBCYXRjaCBvcHMuXG4gICAqL1xuICBBVi5PcC5fcmVnaXN0ZXJEZWNvZGVyKFwiQmF0Y2hcIiwgZnVuY3Rpb24oanNvbikge1xuICAgIHZhciBvcCA9IG51bGw7XG4gICAgQVYuX2FycmF5RWFjaChqc29uLm9wcywgZnVuY3Rpb24obmV4dE9wKSB7XG4gICAgICBuZXh0T3AgPSBBVi5PcC5fZGVjb2RlKG5leHRPcCk7XG4gICAgICBvcCA9IG5leHRPcC5fbWVyZ2VXaXRoUHJldmlvdXMob3ApO1xuICAgIH0pO1xuICAgIHJldHVybiBvcDtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBBIFNldCBvcGVyYXRpb24gaW5kaWNhdGVzIHRoYXQgZWl0aGVyIHRoZSBmaWVsZCB3YXMgY2hhbmdlZCB1c2luZ1xuICAgKiBBVi5PYmplY3Quc2V0LCBvciBpdCBpcyBhIG11dGFibGUgY29udGFpbmVyIHRoYXQgd2FzIGRldGVjdGVkIGFzIGJlaW5nXG4gICAqIGNoYW5nZWQuXG4gICAqL1xuICBBVi5PcC5TZXQgPSBBVi5PcC5fZXh0ZW5kKC8qKiBAbGVuZHMgQVYuT3AuU2V0LnByb3RvdHlwZSAqLyB7XG4gICAgX2luaXRpYWxpemU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuZXcgdmFsdWUgb2YgdGhpcyBmaWVsZCBhZnRlciB0aGUgc2V0LlxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTT04gdmVyc2lvbiBvZiB0aGUgb3BlcmF0aW9uIHN1aXRhYmxlIGZvciBzZW5kaW5nIHRvIEFWLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEFWLl9lbmNvZGUodGhpcy52YWx1ZSgpKTtcbiAgICB9LFxuXG4gICAgX21lcmdlV2l0aFByZXZpb3VzOiBmdW5jdGlvbihwcmV2aW91cykge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9lc3RpbWF0ZTogZnVuY3Rpb24ob2xkVmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlKCk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogQSBzZW50aW5lbCB2YWx1ZSB0aGF0IGlzIHJldHVybmVkIGJ5IEFWLk9wLlVuc2V0Ll9lc3RpbWF0ZSB0b1xuICAgKiBpbmRpY2F0ZSB0aGUgZmllbGQgc2hvdWxkIGJlIGRlbGV0ZWQuIEJhc2ljYWxseSwgaWYgeW91IGZpbmQgX1VOU0VUIGFzIGFcbiAgICogdmFsdWUgaW4geW91ciBvYmplY3QsIHlvdSBzaG91bGQgcmVtb3ZlIHRoYXQga2V5LlxuICAgKi9cbiAgQVYuT3AuX1VOU0VUID0ge307XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBBbiBVbnNldCBvcGVyYXRpb24gaW5kaWNhdGVzIHRoYXQgdGhpcyBmaWVsZCBoYXMgYmVlbiBkZWxldGVkIGZyb20gdGhlXG4gICAqIG9iamVjdC5cbiAgICovXG4gIEFWLk9wLlVuc2V0ID0gQVYuT3AuX2V4dGVuZCgvKiogQGxlbmRzIEFWLk9wLlVuc2V0LnByb3RvdHlwZSAqLyB7XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTT04gdmVyc2lvbiBvZiB0aGUgb3BlcmF0aW9uIHN1aXRhYmxlIGZvciBzZW5kaW5nIHRvIEFWLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgX19vcDogXCJEZWxldGVcIiB9O1xuICAgIH0sXG5cbiAgICBfbWVyZ2VXaXRoUHJldmlvdXM6IGZ1bmN0aW9uKHByZXZpb3VzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgX2VzdGltYXRlOiBmdW5jdGlvbihvbGRWYWx1ZSkge1xuICAgICAgcmV0dXJuIEFWLk9wLl9VTlNFVDtcbiAgICB9XG4gIH0pO1xuXG4gIEFWLk9wLl9yZWdpc3RlckRlY29kZXIoXCJEZWxldGVcIiwgZnVuY3Rpb24oanNvbikge1xuICAgIHJldHVybiBuZXcgQVYuT3AuVW5zZXQoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBBbiBJbmNyZW1lbnQgaXMgYW4gYXRvbWljIG9wZXJhdGlvbiB3aGVyZSB0aGUgbnVtZXJpYyB2YWx1ZSBmb3IgdGhlIGZpZWxkXG4gICAqIHdpbGwgYmUgaW5jcmVhc2VkIGJ5IGEgZ2l2ZW4gYW1vdW50LlxuICAgKi9cbiAgQVYuT3AuSW5jcmVtZW50ID0gQVYuT3AuX2V4dGVuZChcbiAgICAgIC8qKiBAbGVuZHMgQVYuT3AuSW5jcmVtZW50LnByb3RvdHlwZSAqLyB7XG5cbiAgICBfaW5pdGlhbGl6ZTogZnVuY3Rpb24oYW1vdW50KSB7XG4gICAgICB0aGlzLl9hbW91bnQgPSBhbW91bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGFtb3VudCB0byBpbmNyZW1lbnQgYnkuXG4gICAgICogQHJldHVybiB7TnVtYmVyfSB0aGUgYW1vdW50IHRvIGluY3JlbWVudCBieS5cbiAgICAgKi9cbiAgICBhbW91bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2Ftb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTT04gdmVyc2lvbiBvZiB0aGUgb3BlcmF0aW9uIHN1aXRhYmxlIGZvciBzZW5kaW5nIHRvIEFWLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgX19vcDogXCJJbmNyZW1lbnRcIiwgYW1vdW50OiB0aGlzLl9hbW91bnQgfTtcbiAgICB9LFxuXG4gICAgX21lcmdlV2l0aFByZXZpb3VzOiBmdW5jdGlvbihwcmV2aW91cykge1xuICAgICAgaWYgKCFwcmV2aW91cykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXMgaW5zdGFuY2VvZiBBVi5PcC5VbnNldCkge1xuICAgICAgICByZXR1cm4gbmV3IEFWLk9wLlNldCh0aGlzLmFtb3VudCgpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXMgaW5zdGFuY2VvZiBBVi5PcC5TZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBVi5PcC5TZXQocHJldmlvdXMudmFsdWUoKSArIHRoaXMuYW1vdW50KCkpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2aW91cyBpbnN0YW5jZW9mIEFWLk9wLkluY3JlbWVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEFWLk9wLkluY3JlbWVudCh0aGlzLmFtb3VudCgpICsgcHJldmlvdXMuYW1vdW50KCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJPcCBpcyBpbnZhbGlkIGFmdGVyIHByZXZpb3VzIG9wLlwiO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZXN0aW1hdGU6IGZ1bmN0aW9uKG9sZFZhbHVlKSB7XG4gICAgICBpZiAoIW9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFtb3VudCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9sZFZhbHVlICsgdGhpcy5hbW91bnQoKTtcbiAgICB9XG4gIH0pO1xuXG4gIEFWLk9wLl9yZWdpc3RlckRlY29kZXIoXCJJbmNyZW1lbnRcIiwgZnVuY3Rpb24oanNvbikge1xuICAgIHJldHVybiBuZXcgQVYuT3AuSW5jcmVtZW50KGpzb24uYW1vdW50KTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBjbGFzc1xuICAgKiBBZGQgaXMgYW4gYXRvbWljIG9wZXJhdGlvbiB3aGVyZSB0aGUgZ2l2ZW4gb2JqZWN0cyB3aWxsIGJlIGFwcGVuZGVkIHRvIHRoZVxuICAgKiBhcnJheSB0aGF0IGlzIHN0b3JlZCBpbiB0aGlzIGZpZWxkLlxuICAgKi9cbiAgQVYuT3AuQWRkID0gQVYuT3AuX2V4dGVuZCgvKiogQGxlbmRzIEFWLk9wLkFkZC5wcm90b3R5cGUgKi8ge1xuICAgIF9pbml0aWFsaXplOiBmdW5jdGlvbihvYmplY3RzKSB7XG4gICAgICB0aGlzLl9vYmplY3RzID0gb2JqZWN0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgb2JqZWN0cyB0byBiZSBhZGRlZCB0byB0aGUgYXJyYXkuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvYmplY3RzIHRvIGJlIGFkZGVkIHRvIHRoZSBhcnJheS5cbiAgICAgKi9cbiAgICBvYmplY3RzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9vYmplY3RzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgSlNPTiB2ZXJzaW9uIG9mIHRoZSBvcGVyYXRpb24gc3VpdGFibGUgZm9yIHNlbmRpbmcgdG8gQVYuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geyBfX29wOiBcIkFkZFwiLCBvYmplY3RzOiBBVi5fZW5jb2RlKHRoaXMub2JqZWN0cygpKSB9O1xuICAgIH0sXG5cbiAgICBfbWVyZ2VXaXRoUHJldmlvdXM6IGZ1bmN0aW9uKHByZXZpb3VzKSB7XG4gICAgICBpZiAoIXByZXZpb3VzKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBlbHNlIGlmIChwcmV2aW91cyBpbnN0YW5jZW9mIEFWLk9wLlVuc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQVYuT3AuU2V0KHRoaXMub2JqZWN0cygpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXMgaW5zdGFuY2VvZiBBVi5PcC5TZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBVi5PcC5TZXQodGhpcy5fZXN0aW1hdGUocHJldmlvdXMudmFsdWUoKSkpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2aW91cyBpbnN0YW5jZW9mIEFWLk9wLkFkZCkge1xuICAgICAgICByZXR1cm4gbmV3IEFWLk9wLkFkZChwcmV2aW91cy5vYmplY3RzKCkuY29uY2F0KHRoaXMub2JqZWN0cygpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIk9wIGlzIGludmFsaWQgYWZ0ZXIgcHJldmlvdXMgb3AuXCI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9lc3RpbWF0ZTogZnVuY3Rpb24ob2xkVmFsdWUpIHtcbiAgICAgIGlmICghb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF8uY2xvbmUodGhpcy5vYmplY3RzKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9sZFZhbHVlLmNvbmNhdCh0aGlzLm9iamVjdHMoKSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBBVi5PcC5fcmVnaXN0ZXJEZWNvZGVyKFwiQWRkXCIsIGZ1bmN0aW9uKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IEFWLk9wLkFkZChBVi5fZGVjb2RlKHVuZGVmaW5lZCwganNvbi5vYmplY3RzKSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQWRkVW5pcXVlIGlzIGFuIGF0b21pYyBvcGVyYXRpb24gd2hlcmUgdGhlIGdpdmVuIGl0ZW1zIHdpbGwgYmUgYXBwZW5kZWQgdG9cbiAgICogdGhlIGFycmF5IHRoYXQgaXMgc3RvcmVkIGluIHRoaXMgZmllbGQgb25seSBpZiB0aGV5IHdlcmUgbm90IGFscmVhZHlcbiAgICogcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gICAqL1xuICBBVi5PcC5BZGRVbmlxdWUgPSBBVi5PcC5fZXh0ZW5kKFxuICAgICAgLyoqIEBsZW5kcyBBVi5PcC5BZGRVbmlxdWUucHJvdG90eXBlICovIHtcblxuICAgIF9pbml0aWFsaXplOiBmdW5jdGlvbihvYmplY3RzKSB7XG4gICAgICB0aGlzLl9vYmplY3RzID0gXy51bmlxKG9iamVjdHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3RzIHRvIGJlIGFkZGVkIHRvIHRoZSBhcnJheS5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9iamVjdHMgdG8gYmUgYWRkZWQgdG8gdGhlIGFycmF5LlxuICAgICAqL1xuICAgIG9iamVjdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX29iamVjdHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIHZlcnNpb24gb2YgdGhlIG9wZXJhdGlvbiBzdWl0YWJsZSBmb3Igc2VuZGluZyB0byBBVi5cbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9XG4gICAgICovXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7IF9fb3A6IFwiQWRkVW5pcXVlXCIsIG9iamVjdHM6IEFWLl9lbmNvZGUodGhpcy5vYmplY3RzKCkpIH07XG4gICAgfSxcblxuICAgIF9tZXJnZVdpdGhQcmV2aW91czogZnVuY3Rpb24ocHJldmlvdXMpIHtcbiAgICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzIGluc3RhbmNlb2YgQVYuT3AuVW5zZXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBVi5PcC5TZXQodGhpcy5vYmplY3RzKCkpO1xuICAgICAgfSBlbHNlIGlmIChwcmV2aW91cyBpbnN0YW5jZW9mIEFWLk9wLlNldCkge1xuICAgICAgICByZXR1cm4gbmV3IEFWLk9wLlNldCh0aGlzLl9lc3RpbWF0ZShwcmV2aW91cy52YWx1ZSgpKSk7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzIGluc3RhbmNlb2YgQVYuT3AuQWRkVW5pcXVlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQVYuT3AuQWRkVW5pcXVlKHRoaXMuX2VzdGltYXRlKHByZXZpb3VzLm9iamVjdHMoKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJPcCBpcyBpbnZhbGlkIGFmdGVyIHByZXZpb3VzIG9wLlwiO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfZXN0aW1hdGU6IGZ1bmN0aW9uKG9sZFZhbHVlKSB7XG4gICAgICBpZiAoIW9sZFZhbHVlKSB7XG4gICAgICAgIHJldHVybiBfLmNsb25lKHRoaXMub2JqZWN0cygpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGNhbid0IGp1c3QgdGFrZSB0aGUgXy51bmlxKF8udW5pb24oLi4uKSkgb2Ygb2xkVmFsdWUgYW5kXG4gICAgICAgIC8vIHRoaXMub2JqZWN0cywgYmVjYXVzZSB0aGUgdW5pcXVlbmVzcyBtYXkgbm90IGFwcGx5IHRvIG9sZFZhbHVlXG4gICAgICAgIC8vIChlc3BlY2lhbGx5IGlmIHRoZSBvbGRWYWx1ZSB3YXMgc2V0IHZpYSAuc2V0KCkpXG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IF8uY2xvbmUob2xkVmFsdWUpO1xuICAgICAgICBBVi5fYXJyYXlFYWNoKHRoaXMub2JqZWN0cygpLCBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICBpZiAob2JqIGluc3RhbmNlb2YgQVYuT2JqZWN0ICYmIG9iai5pZCkge1xuICAgICAgICAgICAgdmFyIG1hdGNoaW5nT2JqID0gXy5maW5kKG5ld1ZhbHVlLCBmdW5jdGlvbihhbk9iaikge1xuICAgICAgICAgICAgICByZXR1cm4gKGFuT2JqIGluc3RhbmNlb2YgQVYuT2JqZWN0KSAmJiAoYW5PYmouaWQgPT09IG9iai5pZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghbWF0Y2hpbmdPYmopIHtcbiAgICAgICAgICAgICAgbmV3VmFsdWUucHVzaChvYmopO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gXy5pbmRleE9mKG5ld1ZhbHVlLCBtYXRjaGluZ09iaik7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlW2luZGV4XSA9IG9iajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKCFfLmNvbnRhaW5zKG5ld1ZhbHVlLCBvYmopKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZS5wdXNoKG9iaik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ld1ZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgQVYuT3AuX3JlZ2lzdGVyRGVjb2RlcihcIkFkZFVuaXF1ZVwiLCBmdW5jdGlvbihqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBBVi5PcC5BZGRVbmlxdWUoQVYuX2RlY29kZSh1bmRlZmluZWQsIGpzb24ub2JqZWN0cykpO1xuICB9KTtcblxuICAvKipcbiAgICogQGNsYXNzXG4gICAqIFJlbW92ZSBpcyBhbiBhdG9taWMgb3BlcmF0aW9uIHdoZXJlIHRoZSBnaXZlbiBvYmplY3RzIHdpbGwgYmUgcmVtb3ZlZCBmcm9tXG4gICAqIHRoZSBhcnJheSB0aGF0IGlzIHN0b3JlZCBpbiB0aGlzIGZpZWxkLlxuICAgKi9cbiAgQVYuT3AuUmVtb3ZlID0gQVYuT3AuX2V4dGVuZCgvKiogQGxlbmRzIEFWLk9wLlJlbW92ZS5wcm90b3R5cGUgKi8ge1xuICAgIF9pbml0aWFsaXplOiBmdW5jdGlvbihvYmplY3RzKSB7XG4gICAgICB0aGlzLl9vYmplY3RzID0gXy51bmlxKG9iamVjdHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBvYmplY3RzIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgYXJyYXkuXG4gICAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvYmplY3RzIHRvIGJlIHJlbW92ZWQgZnJvbSB0aGUgYXJyYXkuXG4gICAgICovXG4gICAgb2JqZWN0czogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb2JqZWN0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTT04gdmVyc2lvbiBvZiB0aGUgb3BlcmF0aW9uIHN1aXRhYmxlIGZvciBzZW5kaW5nIHRvIEFWLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHsgX19vcDogXCJSZW1vdmVcIiwgb2JqZWN0czogQVYuX2VuY29kZSh0aGlzLm9iamVjdHMoKSkgfTtcbiAgICB9LFxuXG4gICAgX21lcmdlV2l0aFByZXZpb3VzOiBmdW5jdGlvbihwcmV2aW91cykge1xuICAgICAgaWYgKCFwcmV2aW91cykge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXMgaW5zdGFuY2VvZiBBVi5PcC5VbnNldCkge1xuICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzIGluc3RhbmNlb2YgQVYuT3AuU2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgQVYuT3AuU2V0KHRoaXMuX2VzdGltYXRlKHByZXZpb3VzLnZhbHVlKCkpKTtcbiAgICAgIH0gZWxzZSBpZiAocHJldmlvdXMgaW5zdGFuY2VvZiBBVi5PcC5SZW1vdmUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBVi5PcC5SZW1vdmUoXy51bmlvbihwcmV2aW91cy5vYmplY3RzKCksIHRoaXMub2JqZWN0cygpKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIk9wIGlzIGludmFsaWQgYWZ0ZXIgcHJldmlvdXMgb3AuXCI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9lc3RpbWF0ZTogZnVuY3Rpb24ob2xkVmFsdWUpIHtcbiAgICAgIGlmICghb2xkVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gXy5kaWZmZXJlbmNlKG9sZFZhbHVlLCB0aGlzLm9iamVjdHMoKSk7XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBzYXZlZCBBViBPYmplY3RzIGJlaW5nIHJlbW92ZWQsIGFsc28gcmVtb3ZlIHRoZW0uXG4gICAgICAgIEFWLl9hcnJheUVhY2godGhpcy5vYmplY3RzKCksIGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBBVi5PYmplY3QgJiYgb2JqLmlkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IF8ucmVqZWN0KG5ld1ZhbHVlLCBmdW5jdGlvbihvdGhlcikge1xuICAgICAgICAgICAgICByZXR1cm4gKG90aGVyIGluc3RhbmNlb2YgQVYuT2JqZWN0KSAmJiAob3RoZXIuaWQgPT09IG9iai5pZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3VmFsdWU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBBVi5PcC5fcmVnaXN0ZXJEZWNvZGVyKFwiUmVtb3ZlXCIsIGZ1bmN0aW9uKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IEFWLk9wLlJlbW92ZShBVi5fZGVjb2RlKHVuZGVmaW5lZCwganNvbi5vYmplY3RzKSk7XG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICogQSBSZWxhdGlvbiBvcGVyYXRpb24gaW5kaWNhdGVzIHRoYXQgdGhlIGZpZWxkIGlzIGFuIGluc3RhbmNlIG9mXG4gICAqIEFWLlJlbGF0aW9uLCBhbmQgb2JqZWN0cyBhcmUgYmVpbmcgYWRkZWQgdG8sIG9yIHJlbW92ZWQgZnJvbSwgdGhhdFxuICAgKiByZWxhdGlvbi5cbiAgICovXG4gIEFWLk9wLlJlbGF0aW9uID0gQVYuT3AuX2V4dGVuZChcbiAgICAgIC8qKiBAbGVuZHMgQVYuT3AuUmVsYXRpb24ucHJvdG90eXBlICovIHtcblxuICAgIF9pbml0aWFsaXplOiBmdW5jdGlvbihhZGRzLCByZW1vdmVzKSB7XG4gICAgICB0aGlzLl90YXJnZXRDbGFzc05hbWUgPSBudWxsO1xuXG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHZhciBwb2ludGVyVG9JZCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICBpZiAob2JqZWN0IGluc3RhbmNlb2YgQVYuT2JqZWN0KSB7XG4gICAgICAgICAgaWYgKCFvYmplY3QuaWQpIHtcbiAgICAgICAgICAgIHRocm93IFwiWW91IGNhbid0IGFkZCBhbiB1bnNhdmVkIEFWLk9iamVjdCB0byBhIHJlbGF0aW9uLlwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXNlbGYuX3RhcmdldENsYXNzTmFtZSkge1xuICAgICAgICAgICAgc2VsZi5fdGFyZ2V0Q2xhc3NOYW1lID0gb2JqZWN0LmNsYXNzTmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNlbGYuX3RhcmdldENsYXNzTmFtZSAhPT0gb2JqZWN0LmNsYXNzTmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgXCJUcmllZCB0byBjcmVhdGUgYSBBVi5SZWxhdGlvbiB3aXRoIDIgZGlmZmVyZW50IHR5cGVzOiBcIiArXG4gICAgICAgICAgICAgICAgICBzZWxmLl90YXJnZXRDbGFzc05hbWUgKyBcIiBhbmQgXCIgKyBvYmplY3QuY2xhc3NOYW1lICsgXCIuXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBvYmplY3QuaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH07XG5cbiAgICAgIHRoaXMucmVsYXRpb25zVG9BZGQgPSBfLnVuaXEoXy5tYXAoYWRkcywgcG9pbnRlclRvSWQpKTtcbiAgICAgIHRoaXMucmVsYXRpb25zVG9SZW1vdmUgPSBfLnVuaXEoXy5tYXAocmVtb3ZlcywgcG9pbnRlclRvSWQpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB1bmZldGNoZWQgQVYuT2JqZWN0IHRoYXQgYXJlIGJlaW5nIGFkZGVkIHRvIHRoZVxuICAgICAqIHJlbGF0aW9uLlxuICAgICAqIEByZXR1cm4ge0FycmF5fVxuICAgICAqL1xuICAgIGFkZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBfLm1hcCh0aGlzLnJlbGF0aW9uc1RvQWRkLCBmdW5jdGlvbihvYmplY3RJZCkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gQVYuT2JqZWN0Ll9jcmVhdGUoc2VsZi5fdGFyZ2V0Q2xhc3NOYW1lKTtcbiAgICAgICAgb2JqZWN0LmlkID0gb2JqZWN0SWQ7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiB1bmZldGNoZWQgQVYuT2JqZWN0IHRoYXQgYXJlIGJlaW5nIHJlbW92ZWQgZnJvbVxuICAgICAqIHRoZSByZWxhdGlvbi5cbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICByZW1vdmVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHJldHVybiBfLm1hcCh0aGlzLnJlbGF0aW9uc1RvUmVtb3ZlLCBmdW5jdGlvbihvYmplY3RJZCkge1xuICAgICAgICB2YXIgb2JqZWN0ID0gQVYuT2JqZWN0Ll9jcmVhdGUoc2VsZi5fdGFyZ2V0Q2xhc3NOYW1lKTtcbiAgICAgICAgb2JqZWN0LmlkID0gb2JqZWN0SWQ7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIEpTT04gdmVyc2lvbiBvZiB0aGUgb3BlcmF0aW9uIHN1aXRhYmxlIGZvciBzZW5kaW5nIHRvIEFWLlxuICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFkZHMgPSBudWxsO1xuICAgICAgdmFyIHJlbW92ZXMgPSBudWxsO1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgdmFyIGlkVG9Qb2ludGVyID0gZnVuY3Rpb24oaWQpIHtcbiAgICAgICAgcmV0dXJuIHsgX190eXBlOiAnUG9pbnRlcicsXG4gICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogc2VsZi5fdGFyZ2V0Q2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICBvYmplY3RJZDogaWQgfTtcbiAgICAgIH07XG4gICAgICB2YXIgcG9pbnRlcnMgPSBudWxsO1xuICAgICAgaWYgKHRoaXMucmVsYXRpb25zVG9BZGQubGVuZ3RoID4gMCkge1xuICAgICAgICBwb2ludGVycyA9IF8ubWFwKHRoaXMucmVsYXRpb25zVG9BZGQsIGlkVG9Qb2ludGVyKTtcbiAgICAgICAgYWRkcyA9IHsgXCJfX29wXCI6IFwiQWRkUmVsYXRpb25cIiwgXCJvYmplY3RzXCI6IHBvaW50ZXJzIH07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlbGF0aW9uc1RvUmVtb3ZlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcG9pbnRlcnMgPSBfLm1hcCh0aGlzLnJlbGF0aW9uc1RvUmVtb3ZlLCBpZFRvUG9pbnRlcik7XG4gICAgICAgIHJlbW92ZXMgPSB7IFwiX19vcFwiOiBcIlJlbW92ZVJlbGF0aW9uXCIsIFwib2JqZWN0c1wiOiBwb2ludGVycyB9O1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkcyAmJiByZW1vdmVzKSB7XG4gICAgICAgIHJldHVybiB7IFwiX19vcFwiOiBcIkJhdGNoXCIsIFwib3BzXCI6IFthZGRzLCByZW1vdmVzXX07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZGRzIHx8IHJlbW92ZXMgfHwge307XG4gICAgfSxcblxuICAgIF9tZXJnZVdpdGhQcmV2aW91czogZnVuY3Rpb24ocHJldmlvdXMpIHtcbiAgICAgIGlmICghcHJldmlvdXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzIGluc3RhbmNlb2YgQVYuT3AuVW5zZXQpIHtcbiAgICAgICAgdGhyb3cgXCJZb3UgY2FuJ3QgbW9kaWZ5IGEgcmVsYXRpb24gYWZ0ZXIgZGVsZXRpbmcgaXQuXCI7XG4gICAgICB9IGVsc2UgaWYgKHByZXZpb3VzIGluc3RhbmNlb2YgQVYuT3AuUmVsYXRpb24pIHtcbiAgICAgICAgaWYgKHByZXZpb3VzLl90YXJnZXRDbGFzc05hbWUgJiZcbiAgICAgICAgICAgIHByZXZpb3VzLl90YXJnZXRDbGFzc05hbWUgIT09IHRoaXMuX3RhcmdldENsYXNzTmFtZSkge1xuICAgICAgICAgIHRocm93IFwiUmVsYXRlZCBvYmplY3QgbXVzdCBiZSBvZiBjbGFzcyBcIiArIHByZXZpb3VzLl90YXJnZXRDbGFzc05hbWUgK1xuICAgICAgICAgICAgICBcIiwgYnV0IFwiICsgdGhpcy5fdGFyZ2V0Q2xhc3NOYW1lICsgXCIgd2FzIHBhc3NlZCBpbi5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3QWRkID0gXy51bmlvbihfLmRpZmZlcmVuY2UocHJldmlvdXMucmVsYXRpb25zVG9BZGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aW9uc1RvUmVtb3ZlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGlvbnNUb0FkZCk7XG4gICAgICAgIHZhciBuZXdSZW1vdmUgPSBfLnVuaW9uKF8uZGlmZmVyZW5jZShwcmV2aW91cy5yZWxhdGlvbnNUb1JlbW92ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpb25zVG9BZGQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aW9uc1RvUmVtb3ZlKTtcblxuICAgICAgICB2YXIgbmV3UmVsYXRpb24gPSBuZXcgQVYuT3AuUmVsYXRpb24obmV3QWRkLCBuZXdSZW1vdmUpO1xuICAgICAgICBuZXdSZWxhdGlvbi5fdGFyZ2V0Q2xhc3NOYW1lID0gdGhpcy5fdGFyZ2V0Q2xhc3NOYW1lO1xuICAgICAgICByZXR1cm4gbmV3UmVsYXRpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBcIk9wIGlzIGludmFsaWQgYWZ0ZXIgcHJldmlvdXMgb3AuXCI7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9lc3RpbWF0ZTogZnVuY3Rpb24ob2xkVmFsdWUsIG9iamVjdCwga2V5KSB7XG4gICAgICBpZiAoIW9sZFZhbHVlKSB7XG4gICAgICAgIHZhciByZWxhdGlvbiA9IG5ldyBBVi5SZWxhdGlvbihvYmplY3QsIGtleSk7XG4gICAgICAgIHJlbGF0aW9uLnRhcmdldENsYXNzTmFtZSA9IHRoaXMuX3RhcmdldENsYXNzTmFtZTtcbiAgICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgaW5zdGFuY2VvZiBBVi5SZWxhdGlvbikge1xuICAgICAgICBpZiAodGhpcy5fdGFyZ2V0Q2xhc3NOYW1lKSB7XG4gICAgICAgICAgaWYgKG9sZFZhbHVlLnRhcmdldENsYXNzTmFtZSkge1xuICAgICAgICAgICAgaWYgKG9sZFZhbHVlLnRhcmdldENsYXNzTmFtZSAhPT0gdGhpcy5fdGFyZ2V0Q2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgIHRocm93IFwiUmVsYXRlZCBvYmplY3QgbXVzdCBiZSBhIFwiICsgb2xkVmFsdWUudGFyZ2V0Q2xhc3NOYW1lICtcbiAgICAgICAgICAgICAgICAgIFwiLCBidXQgYSBcIiArIHRoaXMuX3RhcmdldENsYXNzTmFtZSArIFwiIHdhcyBwYXNzZWQgaW4uXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9sZFZhbHVlLnRhcmdldENsYXNzTmFtZSA9IHRoaXMuX3RhcmdldENsYXNzTmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZFZhbHVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgXCJPcCBpcyBpbnZhbGlkIGFmdGVyIHByZXZpb3VzIG9wLlwiO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgQVYuT3AuX3JlZ2lzdGVyRGVjb2RlcihcIkFkZFJlbGF0aW9uXCIsIGZ1bmN0aW9uKGpzb24pIHtcbiAgICByZXR1cm4gbmV3IEFWLk9wLlJlbGF0aW9uKEFWLl9kZWNvZGUodW5kZWZpbmVkLCBqc29uLm9iamVjdHMpLCBbXSk7XG4gIH0pO1xuICBBVi5PcC5fcmVnaXN0ZXJEZWNvZGVyKFwiUmVtb3ZlUmVsYXRpb25cIiwgZnVuY3Rpb24oanNvbikge1xuICAgIHJldHVybiBuZXcgQVYuT3AuUmVsYXRpb24oW10sIEFWLl9kZWNvZGUodW5kZWZpbmVkLCBqc29uLm9iamVjdHMpKTtcbiAgfSk7XG5cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL29wLmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbnZhciBQcm9taXNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBQcm9taXNlKGZuKSB7XG4gIC8qKlxuICAgKiBBIFByb21pc2UgaXMgcmV0dXJuZWQgYnkgYXN5bmMgbWV0aG9kcyBhcyBhIGhvb2sgdG8gcHJvdmlkZSBjYWxsYmFja3MgdG8gYmVcbiAgICogY2FsbGVkIHdoZW4gdGhlIGFzeW5jIHRhc2sgaXMgZnVsZmlsbGVkLlxuICAgKlxuICAgKiA8cD5UeXBpY2FsIHVzYWdlIHdvdWxkIGJlIGxpa2U6PHByZT5cbiAgICogICAgcXVlcnkuZmluZCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgKiAgICAgIHJlc3VsdHNbMF0uc2V0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICAgKiAgICAgIHJldHVybiByZXN1bHRzWzBdLnNhdmVBc3luYygpO1xuICAgKiAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgKiAgICAgIGNvbnNvbGUubG9nKFwiVXBkYXRlZCBcIiArIHJlc3VsdC5pZCk7XG4gICAqICAgIH0pO1xuICAgKiA8L3ByZT48L3A+XG4gICAqIDxwPkFub3RoZXIgZXhhbXBsZTo8cHJlPlxuICAgKiAgICB2YXIgcHJvbWlzZSA9IG5ldyBBVi5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgKiAgICAgIHJlc29sdmUoNDIpO1xuICAgKiAgICB9KTtcbiAgICogICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICogICAgICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAqICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycm9yKXtcbiAgICogICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICogICAgfSk7XG4gICAqIDwvcHJlPjwvcD5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gQW4gb3B0aW9uYWwgZnVuY3Rpb24gd2l0aCB0d28gYXJndW1lbnRzIHJlc29sdmVcbiAgICogICAgICAgICAgICAgICAgICAgYW5kIHJlamVjdC5UaGUgZmlyc3QgYXJndW1lbnQgZnVsZmlsbHMgdGhlIHByb21pc2UsXG4gICAqICAgICAgICAgICAgICAgICAgIHRoZSBzZWNvbmQgYXJndW1lbnQgcmVqZWN0cyBpdC4gV2UgY2FuIGNhbGwgdGhlc2VcbiAgICAqICAgICAgICAgICAgICAgICAgZnVuY3Rpb25zLCBvbmNlIG91ciBvcGVyYXRpb24gaXMgY29tcGxldGVkLlxuICAgKiBAc2VlIEFWLlByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgICogQGNsYXNzXG4gICAqL1xuICAgIHRoaXMuX3Jlc29sdmVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVqZWN0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXNvbHZlZENhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMuX3JlamVjdGVkQ2FsbGJhY2tzID0gW107XG5cbiAgICB0aGlzLmRvUmVzb2x2ZShmbik7XG59O1xuXG52YXIgX2lzTnVsbE9yVW5kZWZpbmVkID0gZnVuY3Rpb24gX2lzTnVsbE9yVW5kZWZpbmVkKHgpIHtcbiAgcmV0dXJuIF8uaXNOdWxsKHgpIHx8IF8uaXNVbmRlZmluZWQoeCk7XG59O1xuXG52YXIgX2lzTm9kZSA9IGZhbHNlO1xuXG5pZiAodHlwZW9mKHByb2Nlc3MpICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgcHJvY2Vzcy52ZXJzaW9ucyAmJlxuICAgIHByb2Nlc3MudmVyc2lvbnMubm9kZSkge1xuICAgICAgX2lzTm9kZSA9IHRydWU7XG59XG5cbl8uZXh0ZW5kKFByb21pc2UsIC8qKiBAbGVuZHMgQVYuUHJvbWlzZSAqLyB7XG5cbiAgX2lzUHJvbWlzZXNBUGx1c0NvbXBsaWFudDogIV9pc05vZGUsXG4gIF9kZWJ1Z0Vycm9yOiBmYWxzZSxcblxuICBzZXRQcm9taXNlc0FQbHVzQ29tcGxpYW50OiBmdW5jdGlvbihpc0NvbXBsaWFudCkge1xuICAgIFByb21pc2UuX2lzUHJvbWlzZXNBUGx1c0NvbXBsaWFudCA9IGlzQ29tcGxpYW50O1xuICB9LFxuXG4gIHNldERlYnVnRXJyb3I6IGZ1bmN0aW9uKGVuYWJsZSkge1xuICAgIFByb21pc2UuX2RlYnVnRXJyb3IgPSBlbmFibGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdHJ1ZSBpZmYgdGhlIGdpdmVuIG9iamVjdCBmdWxmaWxzIHRoZSBQcm9taXNlIGludGVyZmFjZS5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGlzOiBmdW5jdGlvbihwcm9taXNlKSB7XG4gICAgcmV0dXJuIHByb21pc2UgJiYgcHJvbWlzZS50aGVuICYmIF8uaXNGdW5jdGlvbihwcm9taXNlLnRoZW4pO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHByb21pc2UgdGhhdCBpcyByZXNvbHZlZCB3aXRoIGEgZ2l2ZW4gdmFsdWUuXG4gICAqIEByZXR1cm4ge0FWLlByb21pc2V9IHRoZSBuZXcgcHJvbWlzZS5cbiAgICovXG4gIGFzOiBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCk7XG4gICAgaWYgKGFyZ3VtZW50c1swXSAmJiBfLmlzRnVuY3Rpb24oYXJndW1lbnRzWzBdLnRoZW4pKSB7XG4gICAgICBhcmd1bWVudHNbMF0udGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHByb21pc2UucmVzb2x2ZS5jYWxsKHByb21pc2UsIGRhdGEpO1xuICAgICAgfSwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0LmNhbGwocHJvbWlzZSwgZXJyKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9taXNlLnJlc29sdmUuYXBwbHkocHJvbWlzZSwgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBuZXcgcHJvbWlzZSB0aGF0IGlzIHJlamVjdGVkIHdpdGggYSBnaXZlbiBlcnJvci5cbiAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gdGhlIG5ldyBwcm9taXNlLlxuICAgKi9cbiAgZXJyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKTtcbiAgICBwcm9taXNlLnJlamVjdC5hcHBseShwcm9taXNlLCBhcmd1bWVudHMpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbmV3IHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiBhbGwgb2YgdGhlIGlucHV0IHByb21pc2VzXG4gICAqIGFyZSByZXNvbHZlZC4gSWYgYW55IHByb21pc2UgaW4gdGhlIGxpc3QgZmFpbHMsIHRoZW4gdGhlIHJldHVybmVkIHByb21pc2VcbiAgICogd2lsbCBmYWlsIHdpdGggdGhlIGxhc3QgZXJyb3IuIElmIHRoZXkgYWxsIHN1Y2NlZWQsIHRoZW4gdGhlIHJldHVybmVkXG4gICAqIHByb21pc2Ugd2lsbCBzdWNjZWVkLCB3aXRoIHRoZSByZXN1bHRzIGJlaW5nIHRoZSByZXN1bHRzIG9mIGFsbCB0aGUgaW5wdXRcbiAgICogcHJvbWlzZXMuIEZvciBleGFtcGxlOiA8cHJlPlxuICAgKiAgIHZhciBwMSA9IEFWLlByb21pc2UuYXMoMSk7XG4gICAqICAgdmFyIHAyID0gQVYuUHJvbWlzZS5hcygyKTtcbiAgICogICB2YXIgcDMgPSBBVi5Qcm9taXNlLmFzKDMpO1xuICAgKlxuICAgKiAgIEFWLlByb21pc2Uud2hlbihwMSwgcDIsIHAzKS50aGVuKGZ1bmN0aW9uKHIxLCByMiwgcjMpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKHIxKTsgIC8vIHByaW50cyAxXG4gICAqICAgICBjb25zb2xlLmxvZyhyMik7ICAvLyBwcmludHMgMlxuICAgKiAgICAgY29uc29sZS5sb2cocjMpOyAgLy8gcHJpbnRzIDNcbiAgICogICB9KTs8L3ByZT5cbiAgICpcbiAgICogVGhlIGlucHV0IHByb21pc2VzIGNhbiBhbHNvIGJlIHNwZWNpZmllZCBhcyBhbiBhcnJheTogPHByZT5cbiAgICogICB2YXIgcHJvbWlzZXMgPSBbcDEsIHAyLCBwM107XG4gICAqICAgQVYuUHJvbWlzZS53aGVuKHByb21pc2VzKS50aGVuKGZ1bmN0aW9uKHIxLCByMiwgcjMpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKHIxKTsgIC8vIHByaW50cyAxXG4gICAqICAgICBjb25zb2xlLmxvZyhyMik7ICAvLyBwcmludHMgMlxuICAgKiAgICAgY29uc29sZS5sb2cocjMpOyAgLy8gcHJpbnRzIDNcbiAgICogICB9KTtcbiAgICogPC9wcmU+XG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb21pc2VzIGEgbGlzdCBvZiBwcm9taXNlcyB0byB3YWl0IGZvci5cbiAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gdGhlIG5ldyBwcm9taXNlLlxuICAgKi9cbiAgd2hlbjogZnVuY3Rpb24ocHJvbWlzZXMpIHtcbiAgICAvLyBBbGxvdyBwYXNzaW5nIGluIFByb21pc2VzIGFzIHNlcGFyYXRlIGFyZ3VtZW50cyBpbnN0ZWFkIG9mIGFuIEFycmF5LlxuICAgIHZhciBvYmplY3RzO1xuICAgIGlmIChwcm9taXNlcyAmJiBfaXNOdWxsT3JVbmRlZmluZWQocHJvbWlzZXMubGVuZ3RoKSkge1xuICAgICAgb2JqZWN0cyA9IGFyZ3VtZW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqZWN0cyA9IHByb21pc2VzO1xuICAgIH1cbiAgICB2YXIgaXNBbGwgPSBfLmxhc3QoYXJndW1lbnRzKTtcbiAgICBpc0FsbCA9IF8uaXNCb29sZWFuKGlzQWxsKSA/IGlzQWxsIDogZmFsc2U7XG5cbiAgICB2YXIgdG90YWwgPSBvYmplY3RzLmxlbmd0aDtcbiAgICB2YXIgaGFkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIHZhciBlcnJvcnMgPSBbXTtcbiAgICByZXN1bHRzLmxlbmd0aCA9IG9iamVjdHMubGVuZ3RoO1xuICAgIGVycm9ycy5sZW5ndGggPSBvYmplY3RzLmxlbmd0aDtcblxuICAgIGlmICh0b3RhbCA9PT0gMCkge1xuICAgICAgaWYoaXNBbGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYXMuY2FsbCh0aGlzLCByZXN1bHRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFzLmFwcGx5KHRoaXMsIHJlc3VsdHMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gbmV3IFByb21pc2UoKTtcblxuICAgIHZhciByZXNvbHZlT25lID0gZnVuY3Rpb24oaSkge1xuICAgICAgdG90YWwgPSB0b3RhbCAtIDE7XG4gICAgICBpZihoYWRFcnJvciAmJiAhcHJvbWlzZS5fcmVqZWN0ZWQgJiYgaXNBbGwpIHtcbiAgICAgICAgcHJvbWlzZS5yZWplY3QuY2FsbChwcm9taXNlLCBlcnJvcnNbaV0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0b3RhbCA9PT0gMCkge1xuICAgICAgICBpZiAoaGFkRXJyb3IgJiYgIXByb21pc2UuX3JlamVjdGVkKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QuY2FsbChwcm9taXNlLCBlcnJvcnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmKGlzQWxsKSB7XG4gICAgICAgICAgICBpZighcHJvbWlzZS5fcmVqZWN0ZWQpIHtcbiAgICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlLmNhbGwocHJvbWlzZSwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvL0l0J3MgcmVqZWN0ZWQgYWxyZWFkeSwgc28gd2UgaWdub3JlIGl0LlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9taXNlLnJlc29sdmUuYXBwbHkocHJvbWlzZSwgcmVzdWx0cyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIF8uZWFjaChvYmplY3RzLCBmdW5jdGlvbihvYmplY3QsIGkpIHtcbiAgICAgIGlmIChQcm9taXNlLmlzKG9iamVjdCkpIHtcbiAgICAgICAgb2JqZWN0LnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0c1tpXSA9IHJlc3VsdDtcbiAgICAgICAgICByZXNvbHZlT25lKGkpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIGVycm9yc1tpXSA9IGVycm9yO1xuICAgICAgICAgIGhhZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICByZXNvbHZlT25lKGkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdHNbaV0gPSBvYmplY3Q7XG4gICAgICAgIHJlc29sdmVPbmUoaSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfSxcblxuICAvKipcbiAgICogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBvciByZWplY3RzIGFzIHNvb24gYXMgb25lXG4gICAqIG9mIHRoZSBwcm9taXNlcyBpbiB0aGUgaXRlcmFibGUgcmVzb2x2ZXMgb3IgcmVqZWN0cywgd2l0aFxuICAgKiB0aGUgdmFsdWUgb3IgcmVhc29uIGZyb20gdGhhdCBwcm9taXNlLlJldHVybnMgYSBuZXcgcHJvbWlzZVxuICAgKiB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIG9uZSBvZiB0aGUgaW5wdXQgcHJvbWlzZXMuXG4gICAqIEZvciBleGFtcGxlOiA8cHJlPlxuICAgKiAgIHZhciBwMSA9IEFWLlByb21pc2UuYXMoMSk7XG4gICAqICAgdmFyIHAyID0gQVYuUHJvbWlzZS5hcygyKTtcbiAgICogICB2YXIgcDMgPSBBVi5Qcm9taXNlLmFzKDMpO1xuICAgKlxuICAgKiAgIEFWLlByb21pc2UucmFjZShwMSwgcDIsIHAzKS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgKiAgICAgY29uc29sZS5sb2cocmVzdWx0KTsgIC8vIHByaW50cyAxXG4gICAqICAgfSk7PC9wcmU+XG4gICAqXG4gICAqIFRoZSBpbnB1dCBwcm9taXNlcyBjYW4gYWxzbyBiZSBzcGVjaWZpZWQgYXMgYW4gYXJyYXk6IDxwcmU+XG4gICAqICAgdmFyIHByb21pc2VzID0gW3AxLCBwMiwgcDNdO1xuICAgKiAgIEFWLlByb21pc2Uud2hlbihwcm9taXNlcykudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICogICAgIGNvbnNvbGUubG9nKHJlc3VsdCk7ICAvLyBwcmludHMgMVxuICAgKiAgIH0pO1xuICAgKiA8L3ByZT5cbiAgICogQHBhcmFtIHtBcnJheX0gcHJvbWlzZXMgYSBsaXN0IG9mIHByb21pc2VzIHRvIHdhaXQgZm9yLlxuICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSB0aGUgbmV3IHByb21pc2UuXG4gICAqL1xuICByYWNlOiBmdW5jdGlvbihwcm9taXNlcykge1xuICAgIC8vIEFsbG93IHBhc3NpbmcgaW4gUHJvbWlzZXMgYXMgc2VwYXJhdGUgYXJndW1lbnRzIGluc3RlYWQgb2YgYW4gQXJyYXkuXG4gICAgdmFyIG9iamVjdHM7XG4gICAgaWYgKHByb21pc2VzICYmIF9pc051bGxPclVuZGVmaW5lZChwcm9taXNlcy5sZW5ndGgpKSB7XG4gICAgICBvYmplY3RzID0gYXJndW1lbnRzO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3RzID0gcHJvbWlzZXM7XG4gICAgfVxuXG4gICAgdmFyIHRvdGFsID0gb2JqZWN0cy5sZW5ndGg7XG4gICAgdmFyIGhhZEVycm9yID0gZmFsc2U7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgZXJyb3JzID0gW107XG5cbiAgICByZXN1bHRzLmxlbmd0aCA9IGVycm9ycy5sZW5ndGggPSBvYmplY3RzLmxlbmd0aDtcblxuICAgIGlmICh0b3RhbCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UuYXMuY2FsbCh0aGlzKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKCk7XG5cbiAgICB2YXIgcmVzb2x2ZU9uZSA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgIGlmICghcHJvbWlzZS5fcmVzb2x2ZWQgJiYgIXByb21pc2UuX3JlamVjdGVkKSB7XG4gICAgICAgIGlmIChoYWRFcnJvcikge1xuICAgICAgICAgIHByb21pc2UucmVqZWN0LmNhbGwocHJvbWlzZSwgZXJyb3JzW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9taXNlLnJlc29sdmUuY2FsbChwcm9taXNlLCByZXN1bHRzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBfLmVhY2gob2JqZWN0cywgZnVuY3Rpb24ob2JqZWN0LCBpKSB7XG4gICAgICBpZiAoUHJvbWlzZS5pcyhvYmplY3QpKSB7XG4gICAgICAgIG9iamVjdC50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdHNbaV0gPSByZXN1bHQ7XG4gICAgICAgICAgcmVzb2x2ZU9uZShpKTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBlcnJvcnNbaV0gPSBlcnJvcjtcbiAgICAgICAgICBoYWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgcmVzb2x2ZU9uZShpKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzW2ldID0gb2JqZWN0O1xuICAgICAgICByZXNvbHZlT25lKGkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJ1bnMgdGhlIGdpdmVuIGFzeW5jRnVuY3Rpb24gcmVwZWF0ZWRseSwgYXMgbG9uZyBhcyB0aGUgcHJlZGljYXRlXG4gICAqIGZ1bmN0aW9uIHJldHVybnMgYSB0cnV0aHkgdmFsdWUuIFN0b3BzIHJlcGVhdGluZyBpZiBhc3luY0Z1bmN0aW9uIHJldHVybnNcbiAgICogYSByZWplY3RlZCBwcm9taXNlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgc2hvdWxkIHJldHVybiBmYWxzZSB3aGVuIHJlYWR5IHRvIHN0b3AuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGFzeW5jRnVuY3Rpb24gc2hvdWxkIHJldHVybiBhIFByb21pc2UuXG4gICAqL1xuICBfY29udGludWVXaGlsZTogZnVuY3Rpb24ocHJlZGljYXRlLCBhc3luY0Z1bmN0aW9uKSB7XG4gICAgaWYgKHByZWRpY2F0ZSgpKSB7XG4gICAgICByZXR1cm4gYXN5bmNGdW5jdGlvbigpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLl9jb250aW51ZVdoaWxlKHByZWRpY2F0ZSwgYXN5bmNGdW5jdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYXMoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogSnVzdCBsaWtlIEFWLlByb21pc2Uud2hlbiwgYnV0IGl0IGNhbGxzIHJlc29sdmVDYWxsYmNrIGZ1bmN0aW9uXG4gKiB3aXRoIG9uZSByZXN1bHRzIGFycmF5IGFuZCBjYWxscyByZWplY3RDYWxsYmFjayBmdW5jdGlvbiBhcyBzb29uIGFzIGFueSBvbmVcbiAqIG9mIHRoZSBpbnB1dCBwcm9taXNlcyByZWplY3RzLlxuICogQHNlZSBBVi5Qcm9taXNlLndoZW5cbiAqL1xuUHJvbWlzZS5hbGwgPSBmdW5jdGlvbihwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS53aGVuKHByb21pc2VzLCB0cnVlKTtcbn07XG5cbl8uZXh0ZW5kKFByb21pc2UucHJvdG90eXBlLCAvKiogQGxlbmRzIEFWLlByb21pc2UucHJvdG90eXBlICovIHtcblxuICAvKipcbiAgICogTWFya3MgdGhpcyBwcm9taXNlIGFzIGZ1bGZpbGxlZCwgZmlyaW5nIGFueSBjYWxsYmFja3Mgd2FpdGluZyBvbiBpdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IHJlc3VsdCB0aGUgcmVzdWx0IHRvIHBhc3MgdG8gdGhlIGNhbGxiYWNrcy5cbiAgICovXG4gIHJlc29sdmU6IGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgIGlmICh0aGlzLl9yZXNvbHZlZCB8fCB0aGlzLl9yZWplY3RlZCkge1xuICAgICAgdGhyb3cgXCJBIHByb21pc2Ugd2FzIHJlc29sdmVkIGV2ZW4gdGhvdWdoIGl0IGhhZCBhbHJlYWR5IGJlZW4gXCIgK1xuICAgICAgICAodGhpcy5fcmVzb2x2ZWQgPyBcInJlc29sdmVkXCIgOiBcInJlamVjdGVkXCIpICsgXCIuXCI7XG4gICAgfVxuICAgIHRoaXMuX3Jlc29sdmVkID0gdHJ1ZTtcbiAgICB0aGlzLl9yZXN1bHQgPSBhcmd1bWVudHM7XG4gICAgdmFyIHJlc3VsdHMgPSBhcmd1bWVudHM7XG4gICAgXy5lYWNoKHRoaXMuX3Jlc29sdmVkQ2FsbGJhY2tzLCBmdW5jdGlvbihyZXNvbHZlZENhbGxiYWNrKSB7XG4gICAgICByZXNvbHZlZENhbGxiYWNrLmFwcGx5KHRoaXMsIHJlc3VsdHMpO1xuICAgIH0pO1xuICAgIHRoaXMuX3Jlc29sdmVkQ2FsbGJhY2tzID0gW107XG4gICAgdGhpcy5fcmVqZWN0ZWRDYWxsYmFja3MgPSBbXTtcbiAgfSxcblxuICBkb1Jlc29sdmU6IGZ1bmN0aW9uKGZuKXtcbiAgICBpZiAoIWZuKSByZXR1cm47XG4gICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIGZuKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgc2VsZi5yZXNvbHZlLmNhbGwoc2VsZiwgdmFsdWUpO1xuICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgICBkb25lID0gdHJ1ZTtcbiAgICAgICAgICAgc2VsZi5yZWplY3QuY2FsbChzZWxmLCByZWFzb24pO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICBkb25lID0gdHJ1ZTtcbiAgICAgIHNlbGYucmVqZWN0LmNhbGwoc2VsZiwgZXgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTWFya3MgdGhpcyBwcm9taXNlIGFzIGZ1bGZpbGxlZCwgZmlyaW5nIGFueSBjYWxsYmFja3Mgd2FpdGluZyBvbiBpdC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yIHRoZSBlcnJvciB0byBwYXNzIHRvIHRoZSBjYWxsYmFja3MuXG4gICAqL1xuICByZWplY3Q6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgaWYgKHRoaXMuX3Jlc29sdmVkIHx8IHRoaXMuX3JlamVjdGVkKSB7XG4gICAgICB0aHJvdyBcIkEgcHJvbWlzZSB3YXMgcmVqZWN0ZWQgZXZlbiB0aG91Z2ggaXQgaGFkIGFscmVhZHkgYmVlbiBcIiArXG4gICAgICAgICh0aGlzLl9yZXNvbHZlZCA/IFwicmVzb2x2ZWRcIiA6IFwicmVqZWN0ZWRcIikgKyBcIi5cIjtcbiAgICB9XG4gICAgdGhpcy5fcmVqZWN0ZWQgPSB0cnVlO1xuICAgIHRoaXMuX2Vycm9yID0gZXJyb3I7XG4gICAgXy5lYWNoKHRoaXMuX3JlamVjdGVkQ2FsbGJhY2tzLCBmdW5jdGlvbihyZWplY3RlZENhbGxiYWNrKSB7XG4gICAgICByZWplY3RlZENhbGxiYWNrKGVycm9yKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXNvbHZlZENhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMuX3JlamVjdGVkQ2FsbGJhY2tzID0gW107XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFkZHMgY2FsbGJhY2tzIHRvIGJlIGNhbGxlZCB3aGVuIHRoaXMgcHJvbWlzZSBpcyBmdWxmaWxsZWQuIFJldHVybnMgYSBuZXdcbiAgICogUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIHdoZW4gdGhlIGNhbGxiYWNrIGlzIGNvbXBsZXRlLiBJdCBhbGxvd3NcbiAgICogY2hhaW5pbmcuIElmIHRoZSBjYWxsYmFjayBpdHNlbGYgcmV0dXJucyBhIFByb21pc2UsIHRoZW4gdGhlIG9uZSByZXR1cm5lZFxuICAgKiBieSBcInRoZW5cIiB3aWxsIG5vdCBiZSBmdWxmaWxsZWQgdW50aWwgdGhhdCBvbmUgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG4gICAqIGlzIGZ1bGZpbGxlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVzb2x2ZWRDYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoaXNcbiAgICogUHJvbWlzZSBpcyByZXNvbHZlZC4gT25jZSB0aGUgY2FsbGJhY2sgaXMgY29tcGxldGUsIHRoZW4gdGhlIFByb21pc2VcbiAgICogcmV0dXJuZWQgYnkgXCJ0aGVuXCIgd2lsbCBhbHNvIGJlIGZ1bGZpbGxlZC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWRDYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoaXNcbiAgICogUHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIGFuIGVycm9yLiBPbmNlIHRoZSBjYWxsYmFjayBpcyBjb21wbGV0ZSwgdGhlblxuICAgKiB0aGUgcHJvbWlzZSByZXR1cm5lZCBieSBcInRoZW5cIiB3aXRoIGJlIHJlc29sdmVkIHN1Y2Nlc3NmdWxseS4gSWZcbiAgICogcmVqZWN0ZWRDYWxsYmFjayBpcyBudWxsLCBvciBpdCByZXR1cm5zIGEgcmVqZWN0ZWQgUHJvbWlzZSwgdGhlbiB0aGVcbiAgICogUHJvbWlzZSByZXR1cm5lZCBieSBcInRoZW5cIiB3aWxsIGJlIHJlamVjdGVkIHdpdGggdGhhdCBlcnJvci5cbiAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBuZXcgUHJvbWlzZSB0aGF0IHdpbGwgYmUgZnVsZmlsbGVkIGFmdGVyIHRoaXNcbiAgICogUHJvbWlzZSBpcyBmdWxmaWxsZWQgYW5kIGVpdGhlciBjYWxsYmFjayBoYXMgY29tcGxldGVkLiBJZiB0aGUgY2FsbGJhY2tcbiAgICogcmV0dXJuZWQgYSBQcm9taXNlLCB0aGVuIHRoaXMgUHJvbWlzZSB3aWxsIG5vdCBiZSBmdWxmaWxsZWQgdW50aWwgdGhhdFxuICAgKiBvbmUgaXMuXG4gICAqL1xuICB0aGVuOiBmdW5jdGlvbihyZXNvbHZlZENhbGxiYWNrLCByZWplY3RlZENhbGxiYWNrKSB7XG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZSgpO1xuXG4gICAgdmFyIHdyYXBwZWRSZXNvbHZlZENhbGxiYWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJndW1lbnRzO1xuICAgICAgaWYgKHJlc29sdmVkQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKFByb21pc2UuX2lzUHJvbWlzZXNBUGx1c0NvbXBsaWFudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbcmVzb2x2ZWRDYWxsYmFjay5hcHBseSh0aGlzLCByZXN1bHQpXTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZihQcm9taXNlLl9kZWJ1Z0Vycm9yICYmIGUpIHtcbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3Igb2NjdXJyZWQgaW4gcHJvbWlzZSByZXNvbHZlIGNhbGxiYWNrLicsIGUuc3RhY2sgfHwgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBbUHJvbWlzZS5lcnJvcihlKV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdCA9IFtyZXNvbHZlZENhbGxiYWNrLmFwcGx5KHRoaXMsIHJlc3VsdCldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMSAmJiBQcm9taXNlLmlzKHJlc3VsdFswXSkpIHtcbiAgICAgICAgcmVzdWx0WzBdLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZXNvbHZlLmFwcGx5KHByb21pc2UsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UucmVzb2x2ZS5hcHBseShwcm9taXNlLCByZXN1bHQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgd3JhcHBlZFJlamVjdGVkQ2FsbGJhY2sgPSBmdW5jdGlvbihlcnJvcikge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHJlamVjdGVkQ2FsbGJhY2spIHtcbiAgICAgICAgaWYgKFByb21pc2UuX2lzUHJvbWlzZXNBUGx1c0NvbXBsaWFudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXN1bHQgPSBbcmVqZWN0ZWRDYWxsYmFjayhlcnJvcildO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmKFByb21pc2UuX2RlYnVnRXJyb3IgJiYgZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBvY2N1cnJlZCBpbiBwcm9taXNlIHJlamVjdCBjYWxsYmFjay4nLCBlLnN0YWNrIHx8IGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gW1Byb21pc2UuZXJyb3IoZSldO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBbcmVqZWN0ZWRDYWxsYmFjayhlcnJvcildO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQubGVuZ3RoID09PSAxICYmIFByb21pc2UuaXMocmVzdWx0WzBdKSkge1xuICAgICAgICAgIHJlc3VsdFswXS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcHJvbWlzZS5yZXNvbHZlLmFwcGx5KHByb21pc2UsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoUHJvbWlzZS5faXNQcm9taXNlc0FQbHVzQ29tcGxpYW50KSB7XG4gICAgICAgICAgICBwcm9taXNlLnJlc29sdmUuYXBwbHkocHJvbWlzZSwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvbWlzZS5yZWplY3QocmVzdWx0WzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIHJ1bkxhdGVyID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgZnVuYy5jYWxsKCk7XG4gICAgfTtcbiAgICBpZiAoUHJvbWlzZS5faXNQcm9taXNlc0FQbHVzQ29tcGxpYW50KSB7XG4gICAgICBpZiAodHlwZW9mKHdpbmRvdykgIT09ICd1bmRlZmluZWQnICYmIF8uaXNGdW5jdGlvbih3aW5kb3cuc2V0SW1tZWRpYXRlKSkge1xuICAgICAgICBydW5MYXRlciA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICB3aW5kb3cuc2V0SW1tZWRpYXRlKGZ1bmMpO1xuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YocHJvY2VzcykgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MubmV4dFRpY2spIHtcbiAgICAgICAgcnVuTGF0ZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuYyk7XG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZihzZXRUaW1lb3V0KSAhPT0gJ3VuZGVmaW5lZCcgJiYgXy5pc0Z1bmN0aW9uKHNldFRpbWVvdXQpKSB7XG4gICAgICAgIHJ1bkxhdGVyID0gZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgIHNldFRpbWVvdXQoZnVuYywgMCk7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgcnVuTGF0ZXIoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdyYXBwZWRSZXNvbHZlZENhbGxiYWNrLmFwcGx5KHNlbGYsIHNlbGYuX3Jlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3JlamVjdGVkKSB7XG4gICAgICBydW5MYXRlcihmdW5jdGlvbigpIHtcbiAgICAgICAgd3JhcHBlZFJlamVjdGVkQ2FsbGJhY2suYXBwbHkoc2VsZiwgW3NlbGYuX2Vycm9yXSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcmVzb2x2ZWRDYWxsYmFja3MucHVzaCh3cmFwcGVkUmVzb2x2ZWRDYWxsYmFjayk7XG4gICAgICB0aGlzLl9yZWplY3RlZENhbGxiYWNrcy5wdXNoKHdyYXBwZWRSZWplY3RlZENhbGxiYWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGhhbmRsZXJzIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBQcm9taXNlIG9iamVjdCBpcyByZWplY3RlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWRDYWxsYmFjayBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoaXNcbiAgICogICAgICAgICAgICAgICAgICAgUHJvbWlzZSBpcyByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIG5ldyBQcm9taXNlIHRoYXQgd2lsbCBiZSBmdWxmaWxsZWQgYWZ0ZXIgdGhpc1xuICAgKiAgICAgICAgICAgICAgICAgICBQcm9taXNlIGlzIGZ1bGZpbGxlZCBhbmQgZWl0aGVyIGNhbGxiYWNrIGhhcyBjb21wbGV0ZWQuIElmIHRoZSBjYWxsYmFja1xuICAgKiByZXR1cm5lZCBhIFByb21pc2UsIHRoZW4gdGhpcyBQcm9taXNlIHdpbGwgbm90IGJlIGZ1bGZpbGxlZCB1bnRpbCB0aGF0XG4gICAqICAgICAgICAgICAgICAgICAgIG9uZSBpcy5cbiAgICogQGZ1bmN0aW9uXG4gICAqL1xuICBjYXRjaDogZnVuY3Rpb24ob25SZWplY3RlZCkge1xuICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGhhbmRsZXJzIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBwcm9taXNlXG4gICAqIGlzIGVpdGhlciByZXNvbHZlZCBvciByZWplY3RlZFxuICAgKi9cbiAgYWx3YXlzOiBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLnRoZW4oY2FsbGJhY2ssIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGhhbmRsZXJzIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBQcm9taXNlIG9iamVjdCBpcyByZXNvbHZlZFxuICAgKi9cbiAgZG9uZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkIGhhbmRsZXJzIHRvIGJlIGNhbGxlZCB3aGVuIHRoZSBQcm9taXNlIG9iamVjdCBpcyByZWplY3RlZFxuICAgKi9cbiAgZmFpbDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy50aGVuKG51bGwsIGNhbGxiYWNrKTtcbiAgfSxcblxuICAvKipcbiAgICogUnVuIHRoZSBnaXZlbiBjYWxsYmFja3MgYWZ0ZXIgdGhpcyBwcm9taXNlIGlzIGZ1bGZpbGxlZC5cbiAgICogQHBhcmFtIG9wdGlvbnNPckNhbGxiYWNrIHt9IEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBjYWxsYmFjaywgb3IgYVxuICAgKiBjYWxsYmFjayBmdW5jdGlvbi4gSWYgdGhpcyBpcyBhbiBvcHRpb25zIG9iamVjdCBhbmQgY29udGFpbnMgYSBcIm1vZGVsXCJcbiAgICogYXR0cmlidXRlcywgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBlcnJvciBjYWxsYmFja3MgYXMgdGhlIGZpcnN0IGFyZ3VtZW50LlxuICAgKiBAcGFyYW0gbW9kZWwge30gSWYgdHJ1dGh5LCB0aGlzIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBmaXJzdCByZXN1bHQgb2ZcbiAgICogZXJyb3IgY2FsbGJhY2tzLiBUaGlzIGlzIGZvciBCYWNrYm9uZS1jb21wYXRhYmlsaXR5LlxuICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIGFmdGVyIHRoZVxuICAgKiBjYWxsYmFja3MgYXJlIHJ1biwgd2l0aCB0aGUgc2FtZSByZXN1bHQgYXMgdGhpcy5cbiAgICovXG4gIF90aGVuUnVuQ2FsbGJhY2tzOiBmdW5jdGlvbihvcHRpb25zT3JDYWxsYmFjaywgbW9kZWwpIHtcbiAgICB2YXIgb3B0aW9ucztcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9wdGlvbnNPckNhbGxiYWNrKSkge1xuICAgICAgdmFyIGNhbGxiYWNrID0gb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICBvcHRpb25zID0ge1xuICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICBjYWxsYmFjayhyZXN1bHQsIG51bGwpO1xuICAgICAgICB9LFxuICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMgPSBfLmNsb25lKG9wdGlvbnNPckNhbGxiYWNrKTtcbiAgICB9XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICByZXR1cm4gdGhpcy50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgaWYgKG9wdGlvbnMuc3VjY2Vzcykge1xuICAgICAgICBvcHRpb25zLnN1Y2Nlc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0gZWxzZSBpZiAobW9kZWwpIHtcbiAgICAgICAgLy8gV2hlbiB0aGVyZSdzIG5vIGNhbGxiYWNrLCBhIHN5bmMgZXZlbnQgc2hvdWxkIGJlIHRyaWdnZXJlZC5cbiAgICAgICAgbW9kZWwudHJpZ2dlcignc3luYycsIG1vZGVsLCByZXN1bHQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UuYXMuYXBwbHkoUHJvbWlzZSwgYXJndW1lbnRzKTtcbiAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgaWYgKCFfLmlzVW5kZWZpbmVkKG1vZGVsKSkge1xuICAgICAgICAgIG9wdGlvbnMuZXJyb3IobW9kZWwsIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvcHRpb25zLmVycm9yKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChtb2RlbCkge1xuICAgICAgICAvLyBXaGVuIHRoZXJlJ3Mgbm8gZXJyb3IgY2FsbGJhY2ssIGFuIGVycm9yIGV2ZW50IHNob3VsZCBiZSB0cmlnZ2VyZWQuXG4gICAgICAgIG1vZGVsLnRyaWdnZXIoJ2Vycm9yJywgbW9kZWwsIGVycm9yLCBvcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIC8vIEJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGEgcmVqZWN0ZWQgUHJvbWlzZSwgdGhpcyB3aWxsIHdvcmsgd2l0aFxuICAgICAgLy8gZWl0aGVyIGpRdWVyeSBvciBQcm9taXNlcy9BIHNlbWFudGljcy5cbiAgICAgIHJldHVybiBQcm9taXNlLmVycm9yKGVycm9yKTtcbiAgICB9KTtcbiAgfSxcblxuICAvKipcbiAgICogQWRkcyBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgc2hvdWxkIGJlIGNhbGxlZCByZWdhcmRsZXNzIG9mIHdoZXRoZXJcbiAgICogdGhpcyBwcm9taXNlIGZhaWxlZCBvciBzdWNjZWVkZWQuIFRoZSBjYWxsYmFjayB3aWxsIGJlIGdpdmVuIGVpdGhlciB0aGVcbiAgICogYXJyYXkgb2YgcmVzdWx0cyBmb3IgaXRzIGZpcnN0IGFyZ3VtZW50LCBvciB0aGUgZXJyb3IgYXMgaXRzIHNlY29uZCxcbiAgICogZGVwZW5kaW5nIG9uIHdoZXRoZXIgdGhpcyBQcm9taXNlIHdhcyByZWplY3RlZCBvciByZXNvbHZlZC4gUmV0dXJucyBhXG4gICAqIG5ldyBQcm9taXNlLCBsaWtlIFwidGhlblwiIHdvdWxkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb250aW51YXRpb24gdGhlIGNhbGxiYWNrLlxuICAgKi9cbiAgX2NvbnRpbnVlV2l0aDogZnVuY3Rpb24oY29udGludWF0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBjb250aW51YXRpb24oYXJndW1lbnRzLCBudWxsKTtcbiAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgcmV0dXJuIGNvbnRpbnVhdGlvbihudWxsLCBlcnJvcik7XG4gICAgfSk7XG4gIH1cblxufSk7XG5cbi8qKlxuICogQWxpYXMgb2YgQVYuUHJvbWlzZS5wcm90b3R5cGUuYWx3YXlzXG4gKiBAZnVuY3Rpb25cbiAqIEBzZWUgQVYuUHJvbWlzZSNhbHdheXNcbiAqL1xuUHJvbWlzZS5wcm90b3R5cGUuZmluYWxseSA9IFByb21pc2UucHJvdG90eXBlLmFsd2F5cztcblxuLyoqXG4gKiBBbGlhcyBvZiBBVi5Qcm9taXNlLnByb3RvdHlwZS5kb25lXG4gKiBAZnVuY3Rpb25cbiAqIEBzZWUgQVYuUHJvbWlzZSNkb25lXG4gKi9cblByb21pc2UucHJvdG90eXBlLnRyeSA9IFByb21pc2UucHJvdG90eXBlLmRvbmU7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL3Byb21pc2UuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQVYpIHtcbiAgQVYuSW5zdGFsbGF0aW9uID0gQVYuT2JqZWN0LmV4dGVuZChcIl9JbnN0YWxsYXRpb25cIik7XG5cbiAgLyoqXG4gICAqIENvbnRhaW5zIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggUHVzaCBpbiBBVlxuICAgKiBAbmFtZSBBVi5QdXNoXG4gICAqIEBuYW1lc3BhY2VcbiAgICovXG4gIEFWLlB1c2ggPSBBVi5QdXNoIHx8IHt9O1xuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHB1c2ggbm90aWZpY2F0aW9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtICBUaGUgZGF0YSBvZiB0aGUgcHVzaCBub3RpZmljYXRpb24uICBWYWxpZCBmaWVsZHNcbiAgICogYXJlOlxuICAgKiAgIDxvbD5cbiAgICogICAgIDxsaT5jaGFubmVscyAtIEFuIEFycmF5IG9mIGNoYW5uZWxzIHRvIHB1c2ggdG8uPC9saT5cbiAgICogICAgIDxsaT5wdXNoX3RpbWUgLSBBIERhdGUgb2JqZWN0IGZvciB3aGVuIHRvIHNlbmQgdGhlIHB1c2guPC9saT5cbiAgICogICAgIDxsaT5leHBpcmF0aW9uX3RpbWUgLSAgQSBEYXRlIG9iamVjdCBmb3Igd2hlbiB0byBleHBpcmVcbiAgICogICAgICAgICB0aGUgcHVzaC48L2xpPlxuICAgKiAgICAgPGxpPmV4cGlyYXRpb25faW50ZXJ2YWwgLSBUaGUgc2Vjb25kcyBmcm9tIG5vdyB0byBleHBpcmUgdGhlIHB1c2guPC9saT5cbiAgICogICAgIDxsaT53aGVyZSAtIEEgQVYuUXVlcnkgb3ZlciBBVi5JbnN0YWxsYXRpb24gdGhhdCBpcyB1c2VkIHRvIG1hdGNoXG4gICAqICAgICAgICAgYSBzZXQgb2YgaW5zdGFsbGF0aW9ucyB0byBwdXNoIHRvLjwvbGk+XG4gICAqICAgICA8bGk+Y3FsIC0gQSBDUUwgc3RhdGVtZW50IG92ZXIgQVYuSW5zdGFsbGF0aW9uIHRoYXQgaXMgdXNlZCB0byBtYXRjaFxuICAgKiAgICAgICAgIGEgc2V0IG9mIGluc3RhbGxhdGlvbnMgdG8gcHVzaCB0by48L2xpPlxuICAgKiAgICAgPGxpPmRhdGEgLSBUaGUgZGF0YSB0byBzZW5kIGFzIHBhcnQgb2YgdGhlIHB1c2g8L2xpPlxuICAgKiAgIDxvbD5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb2JqZWN0IHRoYXQgaGFzIGFuIG9wdGlvbmFsIHN1Y2Nlc3MgZnVuY3Rpb24sXG4gICAqIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRzIGFuZCB3aWxsIGJlIGNhbGxlZCBvbiBhIHN1Y2Nlc3NmdWwgcHVzaCwgYW5kXG4gICAqIGFuIGVycm9yIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBBVi5FcnJvciBhbmQgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHB1c2hcbiAgICogZmFpbGVkLlxuICAgKi9cbiAgQVYuUHVzaC5zZW5kID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgIGlmIChkYXRhLndoZXJlKSB7XG4gICAgICBkYXRhLndoZXJlID0gZGF0YS53aGVyZS50b0pTT04oKS53aGVyZTtcbiAgICB9XG5cbiAgICBpZihkYXRhLndoZXJlICYmIGRhdGEuY3FsKXtcbiAgICAgIHRocm93IFwiQm90aCB3aGVyZSBhbmQgY3FsIGNhbid0IGJlIHNldFwiO1xuICAgIH1cblxuICAgIGlmIChkYXRhLnB1c2hfdGltZSkge1xuICAgICAgZGF0YS5wdXNoX3RpbWUgPSBkYXRhLnB1c2hfdGltZS50b0pTT04oKTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5leHBpcmF0aW9uX3RpbWUpIHtcbiAgICAgIGRhdGEuZXhwaXJhdGlvbl90aW1lID0gZGF0YS5leHBpcmF0aW9uX3RpbWUudG9KU09OKCk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEuZXhwaXJhdGlvbl90aW1lICYmIGRhdGEuZXhwaXJhdGlvbl90aW1lX2ludGVydmFsKSB7XG4gICAgICB0aHJvdyBcIkJvdGggZXhwaXJhdGlvbl90aW1lIGFuZCBleHBpcmF0aW9uX3RpbWVfaW50ZXJ2YWwgY2FuJ3QgYmUgc2V0XCI7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBBVi5fcmVxdWVzdCgncHVzaCcsIG51bGwsIG51bGwsICdQT1NUJywgZGF0YSk7XG4gICAgcmV0dXJuIHJlcXVlc3QuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9wdXNoLmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuLy8gQVYuUXVlcnkgaXMgYSB3YXkgdG8gY3JlYXRlIGEgbGlzdCBvZiBBVi5PYmplY3RzLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihBVikge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBhdm9zY2xvdWQgQVYuUXVlcnkgZm9yIHRoZSBnaXZlbiBBVi5PYmplY3Qgc3ViY2xhc3MuXG4gICAqIEBwYXJhbSBvYmplY3RDbGFzcyAtXG4gICAqICAgQW4gaW5zdGFuY2Ugb2YgYSBzdWJjbGFzcyBvZiBBVi5PYmplY3QsIG9yIGEgQVYgY2xhc3NOYW1lIHN0cmluZy5cbiAgICogQGNsYXNzXG4gICAqXG4gICAqIDxwPkFWLlF1ZXJ5IGRlZmluZXMgYSBxdWVyeSB0aGF0IGlzIHVzZWQgdG8gZmV0Y2ggQVYuT2JqZWN0cy4gVGhlXG4gICAqIG1vc3QgY29tbW9uIHVzZSBjYXNlIGlzIGZpbmRpbmcgYWxsIG9iamVjdHMgdGhhdCBtYXRjaCBhIHF1ZXJ5IHRocm91Z2ggdGhlXG4gICAqIDxjb2RlPmZpbmQ8L2NvZGU+IG1ldGhvZC4gRm9yIGV4YW1wbGUsIHRoaXMgc2FtcGxlIGNvZGUgZmV0Y2hlcyBhbGwgb2JqZWN0c1xuICAgKiBvZiBjbGFzcyA8Y29kZT5NeUNsYXNzPC9jb2RlPi4gSXQgY2FsbHMgYSBkaWZmZXJlbnQgZnVuY3Rpb24gZGVwZW5kaW5nIG9uXG4gICAqIHdoZXRoZXIgdGhlIGZldGNoIHN1Y2NlZWRlZCBvciBub3QuXG4gICAqXG4gICAqIDxwcmU+XG4gICAqIHZhciBxdWVyeSA9IG5ldyBBVi5RdWVyeShNeUNsYXNzKTtcbiAgICogcXVlcnkuZmluZCh7XG4gICAqICAgc3VjY2VzczogZnVuY3Rpb24ocmVzdWx0cykge1xuICAgKiAgICAgLy8gcmVzdWx0cyBpcyBhbiBhcnJheSBvZiBBVi5PYmplY3QuXG4gICAqICAgfSxcbiAgICpcbiAgICogICBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICogICAgIC8vIGVycm9yIGlzIGFuIGluc3RhbmNlIG9mIEFWLkVycm9yLlxuICAgKiAgIH1cbiAgICogfSk7PC9wcmU+PC9wPlxuICAgKlxuICAgKiA8cD5BIEFWLlF1ZXJ5IGNhbiBhbHNvIGJlIHVzZWQgdG8gcmV0cmlldmUgYSBzaW5nbGUgb2JqZWN0IHdob3NlIGlkIGlzXG4gICAqIGtub3duLCB0aHJvdWdoIHRoZSBnZXQgbWV0aG9kLiBGb3IgZXhhbXBsZSwgdGhpcyBzYW1wbGUgY29kZSBmZXRjaGVzIGFuXG4gICAqIG9iamVjdCBvZiBjbGFzcyA8Y29kZT5NeUNsYXNzPC9jb2RlPiBhbmQgaWQgPGNvZGU+bXlJZDwvY29kZT4uIEl0IGNhbGxzIGFcbiAgICogZGlmZmVyZW50IGZ1bmN0aW9uIGRlcGVuZGluZyBvbiB3aGV0aGVyIHRoZSBmZXRjaCBzdWNjZWVkZWQgb3Igbm90LlxuICAgKlxuICAgKiA8cHJlPlxuICAgKiB2YXIgcXVlcnkgPSBuZXcgQVYuUXVlcnkoTXlDbGFzcyk7XG4gICAqIHF1ZXJ5LmdldChteUlkLCB7XG4gICAqICAgc3VjY2VzczogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAqICAgICAvLyBvYmplY3QgaXMgYW4gaW5zdGFuY2Ugb2YgQVYuT2JqZWN0LlxuICAgKiAgIH0sXG4gICAqXG4gICAqICAgZXJyb3I6IGZ1bmN0aW9uKG9iamVjdCwgZXJyb3IpIHtcbiAgICogICAgIC8vIGVycm9yIGlzIGFuIGluc3RhbmNlIG9mIEFWLkVycm9yLlxuICAgKiAgIH1cbiAgICogfSk7PC9wcmU+PC9wPlxuICAgKlxuICAgKiA8cD5BIEFWLlF1ZXJ5IGNhbiBhbHNvIGJlIHVzZWQgdG8gY291bnQgdGhlIG51bWJlciBvZiBvYmplY3RzIHRoYXQgbWF0Y2hcbiAgICogdGhlIHF1ZXJ5IHdpdGhvdXQgcmV0cmlldmluZyBhbGwgb2YgdGhvc2Ugb2JqZWN0cy4gRm9yIGV4YW1wbGUsIHRoaXNcbiAgICogc2FtcGxlIGNvZGUgY291bnRzIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBvZiB0aGUgY2xhc3MgPGNvZGU+TXlDbGFzczwvY29kZT5cbiAgICogPHByZT5cbiAgICogdmFyIHF1ZXJ5ID0gbmV3IEFWLlF1ZXJ5KE15Q2xhc3MpO1xuICAgKiBxdWVyeS5jb3VudCh7XG4gICAqICAgc3VjY2VzczogZnVuY3Rpb24obnVtYmVyKSB7XG4gICAqICAgICAvLyBUaGVyZSBhcmUgbnVtYmVyIGluc3RhbmNlcyBvZiBNeUNsYXNzLlxuICAgKiAgIH0sXG4gICAqXG4gICAqICAgZXJyb3I6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAqICAgICAvLyBlcnJvciBpcyBhbiBpbnN0YW5jZSBvZiBBVi5FcnJvci5cbiAgICogICB9XG4gICAqIH0pOzwvcHJlPjwvcD5cbiAgICovXG4gIEFWLlF1ZXJ5ID0gZnVuY3Rpb24ob2JqZWN0Q2xhc3MpIHtcbiAgICBpZiAoXy5pc1N0cmluZyhvYmplY3RDbGFzcykpIHtcbiAgICAgIG9iamVjdENsYXNzID0gQVYuT2JqZWN0Ll9nZXRTdWJjbGFzcyhvYmplY3RDbGFzcyk7XG4gICAgfVxuXG4gICAgdGhpcy5vYmplY3RDbGFzcyA9IG9iamVjdENsYXNzO1xuXG4gICAgdGhpcy5jbGFzc05hbWUgPSBvYmplY3RDbGFzcy5wcm90b3R5cGUuY2xhc3NOYW1lO1xuXG4gICAgdGhpcy5fd2hlcmUgPSB7fTtcbiAgICB0aGlzLl9pbmNsdWRlID0gW107XG4gICAgdGhpcy5fbGltaXQgPSAtMTsgLy8gbmVnYXRpdmUgbGltaXQgbWVhbnMsIGRvIG5vdCBzZW5kIGEgbGltaXRcbiAgICB0aGlzLl9za2lwID0gMDtcbiAgICB0aGlzLl9leHRyYU9wdGlvbnMgPSB7fTtcbiAgfTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIEFWLlF1ZXJ5IHRoYXQgaXMgdGhlIE9SIG9mIHRoZSBwYXNzZWQgaW4gcXVlcmllcy4gIEZvclxuICAgKiBleGFtcGxlOlxuICAgKiA8cHJlPnZhciBjb21wb3VuZFF1ZXJ5ID0gQVYuUXVlcnkub3IocXVlcnkxLCBxdWVyeTIsIHF1ZXJ5Myk7PC9wcmU+XG4gICAqXG4gICAqIHdpbGwgY3JlYXRlIGEgY29tcG91bmRRdWVyeSB0aGF0IGlzIGFuIG9yIG9mIHRoZSBxdWVyeTEsIHF1ZXJ5MiwgYW5kXG4gICAqIHF1ZXJ5My5cbiAgICogQHBhcmFtIHsuLi5BVi5RdWVyeX0gdmFyX2FyZ3MgVGhlIGxpc3Qgb2YgcXVlcmllcyB0byBPUi5cbiAgICogQHJldHVybiB7QVYuUXVlcnl9IFRoZSBxdWVyeSB0aGF0IGlzIHRoZSBPUiBvZiB0aGUgcGFzc2VkIGluIHF1ZXJpZXMuXG4gICAqL1xuICBBVi5RdWVyeS5vciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBxdWVyaWVzID0gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgdmFyIGNsYXNzTmFtZSA9IG51bGw7XG4gICAgQVYuX2FycmF5RWFjaChxdWVyaWVzLCBmdW5jdGlvbihxKSB7XG4gICAgICBpZiAoXy5pc051bGwoY2xhc3NOYW1lKSkge1xuICAgICAgICBjbGFzc05hbWUgPSBxLmNsYXNzTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNsYXNzTmFtZSAhPT0gcS5jbGFzc05hbWUpIHtcbiAgICAgICAgdGhyb3cgXCJBbGwgcXVlcmllcyBtdXN0IGJlIGZvciB0aGUgc2FtZSBjbGFzc1wiO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZhciBxdWVyeSA9IG5ldyBBVi5RdWVyeShjbGFzc05hbWUpO1xuICAgIHF1ZXJ5Ll9vclF1ZXJ5KHF1ZXJpZXMpO1xuICAgIHJldHVybiBxdWVyeTtcbiAgfTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIEFWLlF1ZXJ5IHRoYXQgaXMgdGhlIEFORCBvZiB0aGUgcGFzc2VkIGluIHF1ZXJpZXMuICBGb3JcbiAgICogZXhhbXBsZTpcbiAgICogPHByZT52YXIgY29tcG91bmRRdWVyeSA9IEFWLlF1ZXJ5LmFuZChxdWVyeTEsIHF1ZXJ5MiwgcXVlcnkzKTs8L3ByZT5cbiAgICpcbiAgICogd2lsbCBjcmVhdGUgYSBjb21wb3VuZFF1ZXJ5IHRoYXQgaXMgYW4gJ2FuZCcgb2YgdGhlIHF1ZXJ5MSwgcXVlcnkyLCBhbmRcbiAgICogcXVlcnkzLlxuICAgKiBAcGFyYW0gey4uLkFWLlF1ZXJ5fSB2YXJfYXJncyBUaGUgbGlzdCBvZiBxdWVyaWVzIHRvIEFORC5cbiAgICogQHJldHVybiB7QVYuUXVlcnl9IFRoZSBxdWVyeSB0aGF0IGlzIHRoZSBBTkQgb2YgdGhlIHBhc3NlZCBpbiBxdWVyaWVzLlxuICAgKi9cbiAgQVYuUXVlcnkuYW5kID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHF1ZXJpZXMgPSBfLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICB2YXIgY2xhc3NOYW1lID0gbnVsbDtcbiAgICBBVi5fYXJyYXlFYWNoKHF1ZXJpZXMsIGZ1bmN0aW9uKHEpIHtcbiAgICAgIGlmIChfLmlzTnVsbChjbGFzc05hbWUpKSB7XG4gICAgICAgIGNsYXNzTmFtZSA9IHEuY2xhc3NOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2xhc3NOYW1lICE9PSBxLmNsYXNzTmFtZSkge1xuICAgICAgICB0aHJvdyBcIkFsbCBxdWVyaWVzIG11c3QgYmUgZm9yIHRoZSBzYW1lIGNsYXNzXCI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdmFyIHF1ZXJ5ID0gbmV3IEFWLlF1ZXJ5KGNsYXNzTmFtZSk7XG4gICAgcXVlcnkuX2FuZFF1ZXJ5KHF1ZXJpZXMpO1xuICAgIHJldHVybiBxdWVyeTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgbGlzdCBvZiBBVk9iamVjdHMgdGhhdCBzYXRpc2Z5IHRoZSBDUUwuXG4gICAqIENRTCBzeW50YXggcGxlYXNlIHNlZSA8YSBocmVmPSdodHRwczovL2NuLmF2b3NjbG91ZC5jb20vZG9jcy9jcWxfZ3VpZGUuaHRtbCc+Q1FMIEd1aWRlLjwvYT5cbiAgICogRWl0aGVyIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIGlzIGNhbGxlZCB3aGVuIHRoZSBmaW5kXG4gICAqIGNvbXBsZXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNxbCwgIEEgQ1FMIHN0cmluZywgc2VlIDxhIGhyZWY9J2h0dHBzOi8vY24uYXZvc2Nsb3VkLmNvbS9kb2NzL2NxbF9ndWlkZS5odG1sJz5DUUwgR3VpZGUuPC9hPlxuICAgKiBAcGFyYW0ge0FycmF5fSBwdmFsdWVzLCBBbiBhcnJheSBjb250YWlucyBwbGFjZWhvbGRlciB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QsaXQncyBvcHRpb25hbC5cbiAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyB3aGVuXG4gICAqIHRoZSBxdWVyeSBjb21wbGV0ZXMsaXQncyBvcHRpb25hbC5cbiAgICovXG4gIEFWLlF1ZXJ5LmRvQ2xvdWRRdWVyeSA9IGZ1bmN0aW9uKGNxbCwgcHZhbHVlcywgb3B0aW9ucykge1xuICAgIHZhciBwYXJhbXMgPSB7IGNxbDogY3FsIH07XG4gICAgaWYoXy5pc0FycmF5KHB2YWx1ZXMpKXtcbiAgICAgIHBhcmFtcy5wdmFsdWVzID0gcHZhbHVlcztcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9ucyA9IHB2YWx1ZXM7XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBBVi5fcmVxdWVzdChcImNsb3VkUXVlcnlcIiwgbnVsbCwgbnVsbCwgJ0dFVCcsIHBhcmFtcyk7XG4gICAgcmV0dXJuIHJlcXVlc3QudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgLy9xdWVyeSB0byBwcm9jZXNzIHJlc3VsdHMuXG4gICAgICB2YXIgcXVlcnkgPSBuZXcgQVYuUXVlcnkocmVzcG9uc2UuY2xhc3NOYW1lKTtcbiAgICAgIHZhciByZXN1bHRzID0gXy5tYXAocmVzcG9uc2UucmVzdWx0cywgZnVuY3Rpb24oanNvbikge1xuICAgICAgICB2YXIgb2JqID0gcXVlcnkuX25ld09iamVjdChyZXNwb25zZSk7XG4gICAgICAgIG9iai5fZmluaXNoRmV0Y2gocXVlcnkuX3Byb2Nlc3NSZXN1bHQoanNvbiksIHRydWUpO1xuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlc3VsdHM6IHJlc3VsdHMsXG4gICAgICAgIGNvdW50OiAgcmVzcG9uc2UuY291bnQsXG4gICAgICAgIGNsYXNzTmFtZTogcmVzcG9uc2UuY2xhc3NOYW1lXG4gICAgICB9O1xuICAgIH0pLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICB9O1xuXG4gIEFWLlF1ZXJ5Ll9leHRlbmQgPSBBVi5fZXh0ZW5kO1xuXG4gIEFWLlF1ZXJ5LnByb3RvdHlwZSA9IHtcbiAgICAgLy9ob29rIHRvIGl0ZXJhdGUgcmVzdWx0LiBBZGRlZCBieSBkZW5uaXM8eHpodWFuZ0Bhdm9zY2xvdWQuY29tPi5cbiAgICAgX3Byb2Nlc3NSZXN1bHQ6IGZ1bmN0aW9uKG9iail7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbnN0cnVjdHMgYSBBVi5PYmplY3Qgd2hvc2UgaWQgaXMgYWxyZWFkeSBrbm93biBieSBmZXRjaGluZyBkYXRhIGZyb21cbiAgICAgKiB0aGUgc2VydmVyLiAgRWl0aGVyIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIGlzIGNhbGxlZCB3aGVuIHRoZVxuICAgICAqIGZpbmQgY29tcGxldGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt9IG9iamVjdElkIFRoZSBpZCBvZiB0aGUgb2JqZWN0IHRvIGJlIGZldGNoZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG9iamVjdElkLCBvcHRpb25zKSB7XG4gICAgICBpZighb2JqZWN0SWQpIHtcbiAgICAgICAgdmFyIGVycm9yT2JqZWN0ID0gbmV3IEFWLkVycm9yKEFWLkVycm9yLk9CSkVDVF9OT1RfRk9VTkQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIk9iamVjdCBub3QgZm91bmQuXCIpO1xuICAgICAgICByZXR1cm4gQVYuUHJvbWlzZS5lcnJvcihlcnJvck9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHNlbGYuZXF1YWxUbygnb2JqZWN0SWQnLCBvYmplY3RJZCk7XG5cbiAgICAgIHJldHVybiBzZWxmLmZpcnN0KCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBpZiAoIUFWLl8uaXNFbXB0eShyZXNwb25zZSkpIHtcbiAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXJyb3JPYmplY3QgPSBuZXcgQVYuRXJyb3IoQVYuRXJyb3IuT0JKRUNUX05PVF9GT1VORCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiT2JqZWN0IG5vdCBmb3VuZC5cIik7XG4gICAgICAgIHJldHVybiBBVi5Qcm9taXNlLmVycm9yKGVycm9yT2JqZWN0KTtcblxuICAgICAgfSkuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucywgbnVsbCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgcXVlcnkuXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICB3aGVyZTogdGhpcy5fd2hlcmVcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLl9pbmNsdWRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGFyYW1zLmluY2x1ZGUgPSB0aGlzLl9pbmNsdWRlLmpvaW4oXCIsXCIpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NlbGVjdCkge1xuICAgICAgICBwYXJhbXMua2V5cyA9IHRoaXMuX3NlbGVjdC5qb2luKFwiLFwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9saW1pdCA+PSAwKSB7XG4gICAgICAgIHBhcmFtcy5saW1pdCA9IHRoaXMuX2xpbWl0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3NraXAgPiAwKSB7XG4gICAgICAgIHBhcmFtcy5za2lwID0gdGhpcy5fc2tpcDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9vcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy5vcmRlciA9IHRoaXMuX29yZGVyO1xuICAgICAgfVxuXG4gICAgICBBVi5fb2JqZWN0RWFjaCh0aGlzLl9leHRyYU9wdGlvbnMsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgcGFyYW1zW2tdID0gdjtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH0sXG5cbiAgICBfbmV3T2JqZWN0OiBmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICB2YXIgb2JqO1xuICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLmNsYXNzTmFtZSkge1xuICAgICAgICBvYmogPSBuZXcgQVYuT2JqZWN0KHJlc3BvbnNlLmNsYXNzTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvYmogPSBuZXcgdGhpcy5vYmplY3RDbGFzcygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9iajtcbiAgICB9LFxuICAgIF9jcmVhdGVSZXF1ZXN0OiBmdW5jdGlvbihwYXJhbXMpe1xuICAgICAgcmV0dXJuIEFWLl9yZXF1ZXN0KFwiY2xhc3Nlc1wiLCB0aGlzLmNsYXNzTmFtZSwgbnVsbCwgXCJHRVRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zIHx8IHRoaXMudG9KU09OKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIEFWT2JqZWN0cyB0aGF0IHNhdGlzZnkgdGhpcyBxdWVyeS5cbiAgICAgKiBFaXRoZXIgb3B0aW9ucy5zdWNjZXNzIG9yIG9wdGlvbnMuZXJyb3IgaXMgY2FsbGVkIHdoZW4gdGhlIGZpbmRcbiAgICAgKiBjb21wbGV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdHMgd2hlblxuICAgICAqIHRoZSBxdWVyeSBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgZmluZDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgcmVxdWVzdCA9IHRoaXMuX2NyZWF0ZVJlcXVlc3QoKTtcblxuICAgICAgcmV0dXJuIHJlcXVlc3QudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gXy5tYXAocmVzcG9uc2UucmVzdWx0cywgZnVuY3Rpb24oanNvbikge1xuICAgICAgICAgIHZhciBvYmogPSBzZWxmLl9uZXdPYmplY3QocmVzcG9uc2UpO1xuICAgICAgICAgIG9iai5fZmluaXNoRmV0Y2goc2VsZi5fcHJvY2Vzc1Jlc3VsdChqc29uKSwgdHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgICAgfSk7XG4gICAgICB9KS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zKTtcbiAgICB9LFxuXG4gICAvKipcbiAgICAqIERlbGV0ZSBvYmplY3RzIHJldHJpZXZlZCBieSB0aGlzIHF1ZXJ5LlxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgU3RhbmRhcmQgb3B0aW9ucyBvYmplY3Qgd2l0aCBzdWNjZXNzIGFuZCBlcnJvclxuICAgICogICAgIGNhbGxiYWNrcy5cbiAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIHRoZSBzYXZlXG4gICAgKiAgICAgY29tcGxldGVzLlxuICAgICovXG4gICAgIGRlc3Ryb3lBbGw6IGZ1bmN0aW9uKG9wdGlvbnMpe1xuICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICByZXR1cm4gc2VsZi5maW5kKCkudGhlbihmdW5jdGlvbihvYmplY3RzKXtcbiAgICAgICAgICAgcmV0dXJuIEFWLk9iamVjdC5kZXN0cm95QWxsKG9iamVjdHMpO1xuICAgICAgIH0pLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ291bnRzIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyB0aGF0IG1hdGNoIHRoaXMgcXVlcnkuXG4gICAgICogRWl0aGVyIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIGlzIGNhbGxlZCB3aGVuIHRoZSBjb3VudFxuICAgICAqIGNvbXBsZXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgY291bnQgd2hlblxuICAgICAqIHRoZSBxdWVyeSBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgY291bnQ6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnRvSlNPTigpO1xuICAgICAgcGFyYW1zLmxpbWl0ID0gMDtcbiAgICAgIHBhcmFtcy5jb3VudCA9IDE7XG4gICAgICB2YXIgcmVxdWVzdCA9IHRoaXMuX2NyZWF0ZVJlcXVlc3QocGFyYW1zKTtcblxuICAgICAgcmV0dXJuIHJlcXVlc3QudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuY291bnQ7XG4gICAgICB9KS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIGF0IG1vc3Qgb25lIEFWLk9iamVjdCB0aGF0IHNhdGlzZmllcyB0aGlzIHF1ZXJ5LlxuICAgICAqXG4gICAgICogRWl0aGVyIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIGlzIGNhbGxlZCB3aGVuIGl0IGNvbXBsZXRlcy5cbiAgICAgKiBzdWNjZXNzIGlzIHBhc3NlZCB0aGUgb2JqZWN0IGlmIHRoZXJlIGlzIG9uZS4gb3RoZXJ3aXNlLCB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IGlzIHJlc29sdmVkIHdpdGggdGhlIG9iamVjdCB3aGVuXG4gICAgICogdGhlIHF1ZXJ5IGNvbXBsZXRlcy5cbiAgICAgKi9cbiAgICBmaXJzdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyYW1zID0gdGhpcy50b0pTT04oKTtcbiAgICAgIHBhcmFtcy5saW1pdCA9IDE7XG4gICAgICB2YXIgcmVxdWVzdCA9IHRoaXMuX2NyZWF0ZVJlcXVlc3QocGFyYW1zKTtcblxuICAgICAgcmV0dXJuIHJlcXVlc3QudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gXy5tYXAocmVzcG9uc2UucmVzdWx0cywgZnVuY3Rpb24oanNvbikge1xuICAgICAgICAgIHZhciBvYmogPSBzZWxmLl9uZXdPYmplY3QoKTtcbiAgICAgICAgICBvYmouX2ZpbmlzaEZldGNoKHNlbGYuX3Byb2Nlc3NSZXN1bHQoanNvbiksIHRydWUpO1xuICAgICAgICAgIHJldHVybiBvYmo7XG4gICAgICAgIH0pWzBdO1xuICAgICAgfSkuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgaW5zdGFuY2Ugb2YgQVYuQ29sbGVjdGlvbiBiYWNrZWQgYnkgdGhpcyBxdWVyeS5cbiAgICAgKiBAcmV0dXJuIHtBVi5Db2xsZWN0aW9ufVxuICAgICAqL1xuICAgIGNvbGxlY3Rpb246IGZ1bmN0aW9uKGl0ZW1zLCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHJldHVybiBuZXcgQVYuQ29sbGVjdGlvbihpdGVtcywgXy5leHRlbmQob3B0aW9ucywge1xuICAgICAgICBtb2RlbDogdGhpcy5fb2JqZWN0Q2xhc3MgfHwgdGhpcy5vYmplY3RDbGFzcyxcbiAgICAgICAgcXVlcnk6IHRoaXNcbiAgICAgIH0pKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gc2tpcCBiZWZvcmUgcmV0dXJuaW5nIGFueSByZXN1bHRzLlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIGZvciBwYWdpbmF0aW9uLlxuICAgICAqIERlZmF1bHQgaXMgdG8gc2tpcCB6ZXJvIHJlc3VsdHMuXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gdGhlIG51bWJlciBvZiByZXN1bHRzIHRvIHNraXAuXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBza2lwOiBmdW5jdGlvbihuKSB7XG4gICAgICB0aGlzLl9za2lwID0gbjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaW1pdCBvZiB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gcmV0dXJuLiBUaGUgZGVmYXVsdCBsaW1pdCBpc1xuICAgICAqIDEwMCwgd2l0aCBhIG1heGltdW0gb2YgMTAwMCByZXN1bHRzIGJlaW5nIHJldHVybmVkIGF0IGEgdGltZS5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbiB0aGUgbnVtYmVyIG9mIHJlc3VsdHMgdG8gbGltaXQgdG8uXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBsaW1pdDogZnVuY3Rpb24obikge1xuICAgICAgdGhpcy5fbGltaXQgPSBuO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHF1ZXJ5IHRoYXQgcmVxdWlyZXMgYSBwYXJ0aWN1bGFyIGtleSdzIHZhbHVlIHRvXG4gICAgICogYmUgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRoYXQgdGhlIEFWLk9iamVjdCBtdXN0IGNvbnRhaW4uXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBlcXVhbFRvOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLl93aGVyZVtrZXldID0gQVYuX2VuY29kZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSGVscGVyIGZvciBjb25kaXRpb24gcXVlcmllc1xuICAgICAqL1xuICAgIF9hZGRDb25kaXRpb246IGZ1bmN0aW9uKGtleSwgY29uZGl0aW9uLCB2YWx1ZSkge1xuICAgICAgLy8gQ2hlY2sgaWYgd2UgYWxyZWFkeSBoYXZlIGEgY29uZGl0aW9uXG4gICAgICBpZiAoIXRoaXMuX3doZXJlW2tleV0pIHtcbiAgICAgICAgdGhpcy5fd2hlcmVba2V5XSA9IHt9O1xuICAgICAgfVxuICAgICAgdGhpcy5fd2hlcmVba2V5XVtjb25kaXRpb25dID0gQVYuX2VuY29kZSh2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY29uc3RyYWludCB0byB0aGUgcXVlcnkgdGhhdCByZXF1aXJlcyBhIHBhcnRpY3VsYXJcbiAgICAgKiA8c3Ryb25nPmFycmF5PC9zdHJvbmc+IGtleSdzIGxlbmd0aCB0byBiZSBlcXVhbCB0byB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgYXJyYXkga2V5IHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgbGVuZ3RoIHZhbHVlLlxuICAgICAqIEByZXR1cm4ge0FWLlF1ZXJ5fSBSZXR1cm5zIHRoZSBxdWVyeSwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgc2l6ZUVxdWFsVG86IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX2FkZENvbmRpdGlvbihrZXksIFwiJHNpemVcIiwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBxdWVyeSB0aGF0IHJlcXVpcmVzIGEgcGFydGljdWxhciBrZXkncyB2YWx1ZSB0b1xuICAgICAqIGJlIG5vdCBlcXVhbCB0byB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCBtdXN0IG5vdCBiZSBlcXVhbGxlZC5cbiAgICAgKiBAcmV0dXJuIHtBVi5RdWVyeX0gUmV0dXJucyB0aGUgcXVlcnksIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIG5vdEVxdWFsVG86IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX2FkZENvbmRpdGlvbihrZXksIFwiJG5lXCIsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBxdWVyeSB0aGF0IHJlcXVpcmVzIGEgcGFydGljdWxhciBrZXkncyB2YWx1ZSB0b1xuICAgICAqIGJlIGxlc3MgdGhhbiB0aGUgcHJvdmlkZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgdGhhdCBwcm92aWRlcyBhbiB1cHBlciBib3VuZC5cbiAgICAgKiBAcmV0dXJuIHtBVi5RdWVyeX0gUmV0dXJucyB0aGUgcXVlcnksIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGxlc3NUaGFuOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCBcIiRsdFwiLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY29uc3RyYWludCB0byB0aGUgcXVlcnkgdGhhdCByZXF1aXJlcyBhIHBhcnRpY3VsYXIga2V5J3MgdmFsdWUgdG9cbiAgICAgKiBiZSBncmVhdGVyIHRoYW4gdGhlIHByb3ZpZGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRoYXQgcHJvdmlkZXMgYW4gbG93ZXIgYm91bmQuXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBncmVhdGVyVGhhbjogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5fYWRkQ29uZGl0aW9uKGtleSwgXCIkZ3RcIiwgdmFsdWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHF1ZXJ5IHRoYXQgcmVxdWlyZXMgYSBwYXJ0aWN1bGFyIGtleSdzIHZhbHVlIHRvXG4gICAgICogYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBwcm92aWRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHBhcmFtIHZhbHVlIFRoZSB2YWx1ZSB0aGF0IHByb3ZpZGVzIGFuIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm4ge0FWLlF1ZXJ5fSBSZXR1cm5zIHRoZSBxdWVyeSwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgbGVzc1RoYW5PckVxdWFsVG86IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcbiAgICAgIHRoaXMuX2FkZENvbmRpdGlvbihrZXksIFwiJGx0ZVwiLCB2YWx1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY29uc3RyYWludCB0byB0aGUgcXVlcnkgdGhhdCByZXF1aXJlcyBhIHBhcnRpY3VsYXIga2V5J3MgdmFsdWUgdG9cbiAgICAgKiBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIHByb3ZpZGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRoYXQgcHJvdmlkZXMgYW4gbG93ZXIgYm91bmQuXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBncmVhdGVyVGhhbk9yRXF1YWxUbzogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5fYWRkQ29uZGl0aW9uKGtleSwgXCIkZ3RlXCIsIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBxdWVyeSB0aGF0IHJlcXVpcmVzIGEgcGFydGljdWxhciBrZXkncyB2YWx1ZSB0b1xuICAgICAqIGJlIGNvbnRhaW5lZCBpbiB0aGUgcHJvdmlkZWQgbGlzdCBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRoYXQgd2lsbCBtYXRjaC5cbiAgICAgKiBAcmV0dXJuIHtBVi5RdWVyeX0gUmV0dXJucyB0aGUgcXVlcnksIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGNvbnRhaW5lZEluOiBmdW5jdGlvbihrZXksIHZhbHVlcykge1xuICAgICAgdGhpcy5fYWRkQ29uZGl0aW9uKGtleSwgXCIkaW5cIiwgdmFsdWVzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBxdWVyeSB0aGF0IHJlcXVpcmVzIGEgcGFydGljdWxhciBrZXkncyB2YWx1ZSB0b1xuICAgICAqIG5vdCBiZSBjb250YWluZWQgaW4gdGhlIHByb3ZpZGVkIGxpc3Qgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0aGF0IHdpbGwgbm90IG1hdGNoLlxuICAgICAqIEByZXR1cm4ge0FWLlF1ZXJ5fSBSZXR1cm5zIHRoZSBxdWVyeSwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgbm90Q29udGFpbmVkSW46IGZ1bmN0aW9uKGtleSwgdmFsdWVzKSB7XG4gICAgICB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCBcIiRuaW5cIiwgdmFsdWVzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBjb25zdHJhaW50IHRvIHRoZSBxdWVyeSB0aGF0IHJlcXVpcmVzIGEgcGFydGljdWxhciBrZXkncyB2YWx1ZSB0b1xuICAgICAqIGNvbnRhaW4gZWFjaCBvbmUgb2YgdGhlIHByb3ZpZGVkIGxpc3Qgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0byBjaGVjay4gIFRoaXMga2V5J3MgdmFsdWUgbXVzdCBiZSBhbiBhcnJheS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0aGF0IHdpbGwgbWF0Y2guXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBjb250YWluc0FsbDogZnVuY3Rpb24oa2V5LCB2YWx1ZXMpIHtcbiAgICAgIHRoaXMuX2FkZENvbmRpdGlvbihrZXksIFwiJGFsbFwiLCB2YWx1ZXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY29uc3RyYWludCBmb3IgZmluZGluZyBvYmplY3RzIHRoYXQgY29udGFpbiB0aGUgZ2l2ZW4ga2V5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0aGF0IHNob3VsZCBleGlzdC5cbiAgICAgKiBAcmV0dXJuIHtBVi5RdWVyeX0gUmV0dXJucyB0aGUgcXVlcnksIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGV4aXN0czogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCBcIiRleGlzdHNcIiwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY29uc3RyYWludCBmb3IgZmluZGluZyBvYmplY3RzIHRoYXQgZG8gbm90IGNvbnRhaW4gYSBnaXZlbiBrZXkuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IHRoYXQgc2hvdWxkIG5vdCBleGlzdFxuICAgICAqIEByZXR1cm4ge0FWLlF1ZXJ5fSBSZXR1cm5zIHRoZSBxdWVyeSwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgZG9lc05vdEV4aXN0OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHRoaXMuX2FkZENvbmRpdGlvbihrZXksIFwiJGV4aXN0c1wiLCBmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgcmVndWxhciBleHByZXNzaW9uIGNvbnN0cmFpbnQgZm9yIGZpbmRpbmcgc3RyaW5nIHZhbHVlcyB0aGF0IG1hdGNoXG4gICAgICogdGhlIHByb3ZpZGVkIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICAgKiBUaGlzIG1heSBiZSBzbG93IGZvciBsYXJnZSBkYXRhc2V0cy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdGhhdCB0aGUgc3RyaW5nIHRvIG1hdGNoIGlzIHN0b3JlZCBpbi5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gcmVnZXggVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiBwYXR0ZXJuIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm4ge0FWLlF1ZXJ5fSBSZXR1cm5zIHRoZSBxdWVyeSwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgbWF0Y2hlczogZnVuY3Rpb24oa2V5LCByZWdleCwgbW9kaWZpZXJzKSB7XG4gICAgICB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCBcIiRyZWdleFwiLCByZWdleCk7XG4gICAgICBpZiAoIW1vZGlmaWVycykgeyBtb2RpZmllcnMgPSBcIlwiOyB9XG4gICAgICAvLyBKYXZhc2NyaXB0IHJlZ2V4IG9wdGlvbnMgc3VwcG9ydCBtaWcgYXMgaW5saW5lIG9wdGlvbnMgYnV0IHN0b3JlIHRoZW1cbiAgICAgIC8vIGFzIHByb3BlcnRpZXMgb2YgdGhlIG9iamVjdC4gV2Ugc3VwcG9ydCBtaSAmIHNob3VsZCBtaWdyYXRlIHRoZW0gdG9cbiAgICAgIC8vIG1vZGlmaWVyc1xuICAgICAgaWYgKHJlZ2V4Lmlnbm9yZUNhc2UpIHsgbW9kaWZpZXJzICs9ICdpJzsgfVxuICAgICAgaWYgKHJlZ2V4Lm11bHRpbGluZSkgeyBtb2RpZmllcnMgKz0gJ20nOyB9XG5cbiAgICAgIGlmIChtb2RpZmllcnMgJiYgbW9kaWZpZXJzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCBcIiRvcHRpb25zXCIsIG1vZGlmaWVycyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY29uc3RyYWludCB0aGF0IHJlcXVpcmVzIHRoYXQgYSBrZXkncyB2YWx1ZSBtYXRjaGVzIGEgQVYuUXVlcnlcbiAgICAgKiBjb25zdHJhaW50LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0aGF0IHRoZSBjb250YWlucyB0aGUgb2JqZWN0IHRvIG1hdGNoIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgICAgcXVlcnkuXG4gICAgICogQHBhcmFtIHtBVi5RdWVyeX0gcXVlcnkgVGhlIHF1ZXJ5IHRoYXQgc2hvdWxkIG1hdGNoLlxuICAgICAqIEByZXR1cm4ge0FWLlF1ZXJ5fSBSZXR1cm5zIHRoZSBxdWVyeSwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgbWF0Y2hlc1F1ZXJ5OiBmdW5jdGlvbihrZXksIHF1ZXJ5KSB7XG4gICAgICB2YXIgcXVlcnlKU09OID0gcXVlcnkudG9KU09OKCk7XG4gICAgICBxdWVyeUpTT04uY2xhc3NOYW1lID0gcXVlcnkuY2xhc3NOYW1lO1xuICAgICAgdGhpcy5fYWRkQ29uZGl0aW9uKGtleSwgXCIkaW5RdWVyeVwiLCBxdWVyeUpTT04pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgLyoqXG4gICAgICogQWRkIGEgY29uc3RyYWludCB0aGF0IHJlcXVpcmVzIHRoYXQgYSBrZXkncyB2YWx1ZSBub3QgbWF0Y2hlcyBhXG4gICAgICogQVYuUXVlcnkgY29uc3RyYWludC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdGhhdCB0aGUgY29udGFpbnMgdGhlIG9iamVjdCB0byBtYXRjaCB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QVYuUXVlcnl9IHF1ZXJ5IFRoZSBxdWVyeSB0aGF0IHNob3VsZCBub3QgbWF0Y2guXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBkb2VzTm90TWF0Y2hRdWVyeTogZnVuY3Rpb24oa2V5LCBxdWVyeSkge1xuICAgICAgdmFyIHF1ZXJ5SlNPTiA9IHF1ZXJ5LnRvSlNPTigpO1xuICAgICAgcXVlcnlKU09OLmNsYXNzTmFtZSA9IHF1ZXJ5LmNsYXNzTmFtZTtcbiAgICAgIHRoaXMuX2FkZENvbmRpdGlvbihrZXksIFwiJG5vdEluUXVlcnlcIiwgcXVlcnlKU09OKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbnN0cmFpbnQgdGhhdCByZXF1aXJlcyB0aGF0IGEga2V5J3MgdmFsdWUgbWF0Y2hlcyBhIHZhbHVlIGluXG4gICAgICogYW4gb2JqZWN0IHJldHVybmVkIGJ5IGEgZGlmZmVyZW50IEFWLlF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0aGF0IGNvbnRhaW5zIHRoZSB2YWx1ZSB0aGF0IGlzIGJlaW5nXG4gICAgICogICAgICAgICAgICAgICAgICAgICBtYXRjaGVkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeUtleSBUaGUga2V5IGluIHRoZSBvYmplY3RzIHJldHVybmVkIGJ5IHRoZSBxdWVyeSB0b1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCBhZ2FpbnN0LlxuICAgICAqIEBwYXJhbSB7QVYuUXVlcnl9IHF1ZXJ5IFRoZSBxdWVyeSB0byBydW4uXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBtYXRjaGVzS2V5SW5RdWVyeTogZnVuY3Rpb24oa2V5LCBxdWVyeUtleSwgcXVlcnkpIHtcbiAgICAgIHZhciBxdWVyeUpTT04gPSBxdWVyeS50b0pTT04oKTtcbiAgICAgIHF1ZXJ5SlNPTi5jbGFzc05hbWUgPSBxdWVyeS5jbGFzc05hbWU7XG4gICAgICB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCBcIiRzZWxlY3RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICB7IGtleTogcXVlcnlLZXksIHF1ZXJ5OiBxdWVyeUpTT04gfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY29uc3RyYWludCB0aGF0IHJlcXVpcmVzIHRoYXQgYSBrZXkncyB2YWx1ZSBub3QgbWF0Y2ggYSB2YWx1ZSBpblxuICAgICAqIGFuIG9iamVjdCByZXR1cm5lZCBieSBhIGRpZmZlcmVudCBBVi5RdWVyeS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdGhhdCBjb250YWlucyB0aGUgdmFsdWUgdGhhdCBpcyBiZWluZ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgZXhjbHVkZWQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5S2V5IFRoZSBrZXkgaW4gdGhlIG9iamVjdHMgcmV0dXJuZWQgYnkgdGhlIHF1ZXJ5IHRvXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoIGFnYWluc3QuXG4gICAgICogQHBhcmFtIHtBVi5RdWVyeX0gcXVlcnkgVGhlIHF1ZXJ5IHRvIHJ1bi5cbiAgICAgKiBAcmV0dXJuIHtBVi5RdWVyeX0gUmV0dXJucyB0aGUgcXVlcnksIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGRvZXNOb3RNYXRjaEtleUluUXVlcnk6IGZ1bmN0aW9uKGtleSwgcXVlcnlLZXksIHF1ZXJ5KSB7XG4gICAgICB2YXIgcXVlcnlKU09OID0gcXVlcnkudG9KU09OKCk7XG4gICAgICBxdWVyeUpTT04uY2xhc3NOYW1lID0gcXVlcnkuY2xhc3NOYW1lO1xuICAgICAgdGhpcy5fYWRkQ29uZGl0aW9uKGtleSwgXCIkZG9udFNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiBxdWVyeUtleSwgcXVlcnk6IHF1ZXJ5SlNPTiB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgY29uc3RyYWludCB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGUgcGFzc2VkIGluIHF1ZXJpZXMgbWF0Y2hlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBxdWVyaWVzXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBfb3JRdWVyeTogZnVuY3Rpb24ocXVlcmllcykge1xuICAgICAgdmFyIHF1ZXJ5SlNPTiA9IF8ubWFwKHF1ZXJpZXMsIGZ1bmN0aW9uKHEpIHtcbiAgICAgICAgcmV0dXJuIHEudG9KU09OKCkud2hlcmU7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fd2hlcmUuJG9yID0gcXVlcnlKU09OO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBjb25zdHJhaW50IHRoYXQgYm90aCBvZiB0aGUgcGFzc2VkIGluIHF1ZXJpZXMgbWF0Y2hlcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBxdWVyaWVzXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBfYW5kUXVlcnk6IGZ1bmN0aW9uKHF1ZXJpZXMpIHtcbiAgICAgIHZhciBxdWVyeUpTT04gPSBfLm1hcChxdWVyaWVzLCBmdW5jdGlvbihxKSB7XG4gICAgICAgIHJldHVybiBxLnRvSlNPTigpLndoZXJlO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX3doZXJlLiRhbmQgPSBxdWVyeUpTT047XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBhIHN0cmluZyBpbnRvIGEgcmVnZXggdGhhdCBtYXRjaGVzIGl0LlxuICAgICAqIFN1cnJvdW5kaW5nIHdpdGggXFxRIC4uIFxcRSBkb2VzIHRoaXMsIHdlIGp1c3QgbmVlZCB0byBlc2NhcGUgXFxFJ3MgaW5cbiAgICAgKiB0aGUgdGV4dCBzZXBhcmF0ZWx5LlxuICAgICAqL1xuICAgIF9xdW90ZTogZnVuY3Rpb24ocykge1xuICAgICAgcmV0dXJuIFwiXFxcXFFcIiArIHMucmVwbGFjZShcIlxcXFxFXCIsIFwiXFxcXEVcXFxcXFxcXEVcXFxcUVwiKSArIFwiXFxcXEVcIjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY29uc3RyYWludCBmb3IgZmluZGluZyBzdHJpbmcgdmFsdWVzIHRoYXQgY29udGFpbiBhIHByb3ZpZGVkXG4gICAgICogc3RyaW5nLiAgVGhpcyBtYXkgYmUgc2xvdyBmb3IgbGFyZ2UgZGF0YXNldHMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IHRoYXQgdGhlIHN0cmluZyB0byBtYXRjaCBpcyBzdG9yZWQgaW4uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHN1YnN0cmluZyBUaGUgc3Vic3RyaW5nIHRoYXQgdGhlIHZhbHVlIG11c3QgY29udGFpbi5cbiAgICAgKiBAcmV0dXJuIHtBVi5RdWVyeX0gUmV0dXJucyB0aGUgcXVlcnksIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGNvbnRhaW5zOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCBcIiRyZWdleFwiLCB0aGlzLl9xdW90ZSh2YWx1ZSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbnN0cmFpbnQgZm9yIGZpbmRpbmcgc3RyaW5nIHZhbHVlcyB0aGF0IHN0YXJ0IHdpdGggYSBwcm92aWRlZFxuICAgICAqIHN0cmluZy4gIFRoaXMgcXVlcnkgd2lsbCB1c2UgdGhlIGJhY2tlbmQgaW5kZXgsIHNvIGl0IHdpbGwgYmUgZmFzdCBldmVuXG4gICAgICogZm9yIGxhcmdlIGRhdGFzZXRzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0aGF0IHRoZSBzdHJpbmcgdG8gbWF0Y2ggaXMgc3RvcmVkIGluLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcmVmaXggVGhlIHN1YnN0cmluZyB0aGF0IHRoZSB2YWx1ZSBtdXN0IHN0YXJ0IHdpdGguXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBzdGFydHNXaXRoOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCBcIiRyZWdleFwiLCBcIl5cIiArIHRoaXMuX3F1b3RlKHZhbHVlKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgY29uc3RyYWludCBmb3IgZmluZGluZyBzdHJpbmcgdmFsdWVzIHRoYXQgZW5kIHdpdGggYSBwcm92aWRlZFxuICAgICAqIHN0cmluZy4gIFRoaXMgd2lsbCBiZSBzbG93IGZvciBsYXJnZSBkYXRhc2V0cy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdGhhdCB0aGUgc3RyaW5nIHRvIG1hdGNoIGlzIHN0b3JlZCBpbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3VmZml4IFRoZSBzdWJzdHJpbmcgdGhhdCB0aGUgdmFsdWUgbXVzdCBlbmQgd2l0aC5cbiAgICAgKiBAcmV0dXJuIHtBVi5RdWVyeX0gUmV0dXJucyB0aGUgcXVlcnksIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGVuZHNXaXRoOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCBcIiRyZWdleFwiLCB0aGlzLl9xdW90ZSh2YWx1ZSkgKyBcIiRcIik7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIHJlc3VsdHMgaW4gYXNjZW5kaW5nIG9yZGVyIGJ5IHRoZSBnaXZlbiBrZXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdG8gb3JkZXIgYnkuXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBhc2NlbmRpbmc6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdGhpcy5fb3JkZXIgPSBrZXk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gIC8qKlxuICAgKiBBbHNvIHNvcnRzIHRoZSByZXN1bHRzIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgZ2l2ZW4ga2V5LiBUaGUgcHJldmlvdXMgc29ydCBrZXlzIGhhdmVcbiAgICogcHJlY2VkZW5jZSBvdmVyIHRoaXMga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdG8gb3JkZXIgYnlcbiAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5IHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgKi9cbiAgIGFkZEFzY2VuZGluZzogZnVuY3Rpb24oa2V5KXtcbiAgICAgaWYodGhpcy5fb3JkZXIpXG4gICAgICAgdGhpcy5fb3JkZXIgKz0gICcsJyAgKyBrZXk7XG4gICAgZWxzZVxuICAgICAgIHRoaXMuX29yZGVyID0ga2V5O1xuICAgIHJldHVybiB0aGlzO1xuICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSByZXN1bHRzIGluIGRlc2NlbmRpbmcgb3JkZXIgYnkgdGhlIGdpdmVuIGtleS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0byBvcmRlciBieS5cbiAgICAgKiBAcmV0dXJuIHtBVi5RdWVyeX0gUmV0dXJucyB0aGUgcXVlcnksIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGRlc2NlbmRpbmc6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdGhpcy5fb3JkZXIgPSBcIi1cIiArIGtleTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAgLyoqXG4gICAqIEFsc28gc29ydHMgdGhlIHJlc3VsdHMgaW4gZGVzY2VuZGluZyBvcmRlciBieSB0aGUgZ2l2ZW4ga2V5LiBUaGUgcHJldmlvdXMgc29ydCBrZXlzIGhhdmVcbiAgICogcHJlY2VkZW5jZSBvdmVyIHRoaXMga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdG8gb3JkZXIgYnlcbiAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5IHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgKi9cbiAgIGFkZERlc2NlbmRpbmc6IGZ1bmN0aW9uKGtleSl7XG4gICAgIGlmKHRoaXMuX29yZGVyKVxuICAgICAgIHRoaXMuX29yZGVyICs9ICcsLScgKyBrZXk7XG4gICAgIGVsc2VcbiAgICAgICB0aGlzLl9vcmRlciA9ICctJyArIGtleTtcbiAgICAgcmV0dXJuIGtleTtcbiAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBwcm94aW1pdHkgYmFzZWQgY29uc3RyYWludCBmb3IgZmluZGluZyBvYmplY3RzIHdpdGgga2V5IHBvaW50XG4gICAgICogdmFsdWVzIG5lYXIgdGhlIHBvaW50IGdpdmVuLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0aGF0IHRoZSBBVi5HZW9Qb2ludCBpcyBzdG9yZWQgaW4uXG4gICAgICogQHBhcmFtIHtBVi5HZW9Qb2ludH0gcG9pbnQgVGhlIHJlZmVyZW5jZSBBVi5HZW9Qb2ludCB0aGF0IGlzIHVzZWQuXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBuZWFyOiBmdW5jdGlvbihrZXksIHBvaW50KSB7XG4gICAgICBpZiAoIShwb2ludCBpbnN0YW5jZW9mIEFWLkdlb1BvaW50KSkge1xuICAgICAgICAvLyBUcnkgdG8gY2FzdCBpdCB0byBhIEdlb1BvaW50LCBzbyB0aGF0IG5lYXIoXCJsb2NcIiwgWzIwLDMwXSkgd29ya3MuXG4gICAgICAgIHBvaW50ID0gbmV3IEFWLkdlb1BvaW50KHBvaW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZENvbmRpdGlvbihrZXksIFwiJG5lYXJTcGhlcmVcIiwgcG9pbnQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIHByb3hpbWl0eSBiYXNlZCBjb25zdHJhaW50IGZvciBmaW5kaW5nIG9iamVjdHMgd2l0aCBrZXkgcG9pbnRcbiAgICAgKiB2YWx1ZXMgbmVhciB0aGUgcG9pbnQgZ2l2ZW4gYW5kIHdpdGhpbiB0aGUgbWF4aW11bSBkaXN0YW5jZSBnaXZlbi5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdGhhdCB0aGUgQVYuR2VvUG9pbnQgaXMgc3RvcmVkIGluLlxuICAgICAqIEBwYXJhbSB7QVYuR2VvUG9pbnR9IHBvaW50IFRoZSByZWZlcmVuY2UgQVYuR2VvUG9pbnQgdGhhdCBpcyB1c2VkLlxuICAgICAqIEBwYXJhbSBtYXhEaXN0YW5jZSBNYXhpbXVtIGRpc3RhbmNlIChpbiByYWRpYW5zKSBvZiByZXN1bHRzIHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJuIHtBVi5RdWVyeX0gUmV0dXJucyB0aGUgcXVlcnksIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIHdpdGhpblJhZGlhbnM6IGZ1bmN0aW9uKGtleSwgcG9pbnQsIGRpc3RhbmNlKSB7XG4gICAgICB0aGlzLm5lYXIoa2V5LCBwb2ludCk7XG4gICAgICB0aGlzLl9hZGRDb25kaXRpb24oa2V5LCBcIiRtYXhEaXN0YW5jZVwiLCBkaXN0YW5jZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkIGEgcHJveGltaXR5IGJhc2VkIGNvbnN0cmFpbnQgZm9yIGZpbmRpbmcgb2JqZWN0cyB3aXRoIGtleSBwb2ludFxuICAgICAqIHZhbHVlcyBuZWFyIHRoZSBwb2ludCBnaXZlbiBhbmQgd2l0aGluIHRoZSBtYXhpbXVtIGRpc3RhbmNlIGdpdmVuLlxuICAgICAqIFJhZGl1cyBvZiBlYXJ0aCB1c2VkIGlzIDM5NTguOCBtaWxlcy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdGhhdCB0aGUgQVYuR2VvUG9pbnQgaXMgc3RvcmVkIGluLlxuICAgICAqIEBwYXJhbSB7QVYuR2VvUG9pbnR9IHBvaW50IFRoZSByZWZlcmVuY2UgQVYuR2VvUG9pbnQgdGhhdCBpcyB1c2VkLlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhEaXN0YW5jZSBNYXhpbXVtIGRpc3RhbmNlIChpbiBtaWxlcykgb2YgcmVzdWx0cyB0b1xuICAgICAqICAgICByZXR1cm4uXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICB3aXRoaW5NaWxlczogZnVuY3Rpb24oa2V5LCBwb2ludCwgZGlzdGFuY2UpIHtcbiAgICAgIHJldHVybiB0aGlzLndpdGhpblJhZGlhbnMoa2V5LCBwb2ludCwgZGlzdGFuY2UgLyAzOTU4LjgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBwcm94aW1pdHkgYmFzZWQgY29uc3RyYWludCBmb3IgZmluZGluZyBvYmplY3RzIHdpdGgga2V5IHBvaW50XG4gICAgICogdmFsdWVzIG5lYXIgdGhlIHBvaW50IGdpdmVuIGFuZCB3aXRoaW4gdGhlIG1heGltdW0gZGlzdGFuY2UgZ2l2ZW4uXG4gICAgICogUmFkaXVzIG9mIGVhcnRoIHVzZWQgaXMgNjM3MS4wIGtpbG9tZXRlcnMuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IHRoYXQgdGhlIEFWLkdlb1BvaW50IGlzIHN0b3JlZCBpbi5cbiAgICAgKiBAcGFyYW0ge0FWLkdlb1BvaW50fSBwb2ludCBUaGUgcmVmZXJlbmNlIEFWLkdlb1BvaW50IHRoYXQgaXMgdXNlZC5cbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbWF4RGlzdGFuY2UgTWF4aW11bSBkaXN0YW5jZSAoaW4ga2lsb21ldGVycykgb2YgcmVzdWx0c1xuICAgICAqICAgICB0byByZXR1cm4uXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICB3aXRoaW5LaWxvbWV0ZXJzOiBmdW5jdGlvbihrZXksIHBvaW50LCBkaXN0YW5jZSkge1xuICAgICAgcmV0dXJuIHRoaXMud2l0aGluUmFkaWFucyhrZXksIHBvaW50LCBkaXN0YW5jZSAvIDYzNzEuMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNvbnN0cmFpbnQgdG8gdGhlIHF1ZXJ5IHRoYXQgcmVxdWlyZXMgYSBwYXJ0aWN1bGFyIGtleSdzXG4gICAgICogY29vcmRpbmF0ZXMgYmUgY29udGFpbmVkIHdpdGhpbiBhIGdpdmVuIHJlY3Rhbmd1bGFyIGdlb2dyYXBoaWMgYm91bmRpbmdcbiAgICAgKiBib3guXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IHRvIGJlIGNvbnN0cmFpbmVkLlxuICAgICAqIEBwYXJhbSB7QVYuR2VvUG9pbnR9IHNvdXRod2VzdFxuICAgICAqICAgICBUaGUgbG93ZXItbGVmdCBpbmNsdXNpdmUgY29ybmVyIG9mIHRoZSBib3guXG4gICAgICogQHBhcmFtIHtBVi5HZW9Qb2ludH0gbm9ydGhlYXN0XG4gICAgICogICAgIFRoZSB1cHBlci1yaWdodCBpbmNsdXNpdmUgY29ybmVyIG9mIHRoZSBib3guXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICB3aXRoaW5HZW9Cb3g6IGZ1bmN0aW9uKGtleSwgc291dGh3ZXN0LCBub3J0aGVhc3QpIHtcbiAgICAgIGlmICghKHNvdXRod2VzdCBpbnN0YW5jZW9mIEFWLkdlb1BvaW50KSkge1xuICAgICAgICBzb3V0aHdlc3QgPSBuZXcgQVYuR2VvUG9pbnQoc291dGh3ZXN0KTtcbiAgICAgIH1cbiAgICAgIGlmICghKG5vcnRoZWFzdCBpbnN0YW5jZW9mIEFWLkdlb1BvaW50KSkge1xuICAgICAgICBub3J0aGVhc3QgPSBuZXcgQVYuR2VvUG9pbnQobm9ydGhlYXN0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FkZENvbmRpdGlvbihrZXksICckd2l0aGluJywgeyAnJGJveCc6IFtzb3V0aHdlc3QsIG5vcnRoZWFzdF0gfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW5jbHVkZSBuZXN0ZWQgQVYuT2JqZWN0cyBmb3IgdGhlIHByb3ZpZGVkIGtleS4gIFlvdSBjYW4gdXNlIGRvdFxuICAgICAqIG5vdGF0aW9uIHRvIHNwZWNpZnkgd2hpY2ggZmllbGRzIGluIHRoZSBpbmNsdWRlZCBvYmplY3QgYXJlIGFsc28gZmV0Y2guXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUgbmFtZSBvZiB0aGUga2V5IHRvIGluY2x1ZGUuXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBpbmNsdWRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIEFWLl9hcnJheUVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKF8uaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgc2VsZi5faW5jbHVkZSA9IHNlbGYuX2luY2x1ZGUuY29uY2F0KGtleSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2VsZi5faW5jbHVkZS5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlc3RyaWN0IHRoZSBmaWVsZHMgb2YgdGhlIHJldHVybmVkIEFWLk9iamVjdHMgdG8gaW5jbHVkZSBvbmx5IHRoZVxuICAgICAqIHByb3ZpZGVkIGtleXMuICBJZiB0aGlzIGlzIGNhbGxlZCBtdWx0aXBsZSB0aW1lcywgdGhlbiBhbGwgb2YgdGhlIGtleXNcbiAgICAgKiBzcGVjaWZpZWQgaW4gZWFjaCBvZiB0aGUgY2FsbHMgd2lsbCBiZSBpbmNsdWRlZC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIFRoZSBuYW1lcyBvZiB0aGUga2V5cyB0byBpbmNsdWRlLlxuICAgICAqIEByZXR1cm4ge0FWLlF1ZXJ5fSBSZXR1cm5zIHRoZSBxdWVyeSwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgc2VsZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIHRoaXMuX3NlbGVjdCA9IHRoaXMuX3NlbGVjdCB8fCBbXTtcbiAgICAgIEFWLl9hcnJheUVhY2goYXJndW1lbnRzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKF8uaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgc2VsZi5fc2VsZWN0ID0gc2VsZi5fc2VsZWN0LmNvbmNhdChrZXkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlbGYuX3NlbGVjdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWFjaCByZXN1bHQgb2YgYSBxdWVyeSwgY2FsbGluZyBhIGNhbGxiYWNrIGZvciBlYWNoIG9uZS4gSWZcbiAgICAgKiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHByb21pc2UsIHRoZSBpdGVyYXRpb24gd2lsbCBub3QgY29udGludWUgdW50aWxcbiAgICAgKiB0aGF0IHByb21pc2UgaGFzIGJlZW4gZnVsZmlsbGVkLiBJZiB0aGUgY2FsbGJhY2sgcmV0dXJucyBhIHJlamVjdGVkXG4gICAgICogcHJvbWlzZSwgdGhlbiBpdGVyYXRpb24gd2lsbCBzdG9wIHdpdGggdGhhdCBlcnJvci4gVGhlIGl0ZW1zIGFyZVxuICAgICAqIHByb2Nlc3NlZCBpbiBhbiB1bnNwZWNpZmllZCBvcmRlci4gVGhlIHF1ZXJ5IG1heSBub3QgaGF2ZSBhbnkgc29ydCBvcmRlcixcbiAgICAgKiBhbmQgbWF5IG5vdCB1c2UgbGltaXQgb3Igc2tpcC5cbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sge0Z1bmN0aW9ufSBDYWxsYmFjayB0aGF0IHdpbGwgYmUgY2FsbGVkIHdpdGggZWFjaCByZXN1bHRcbiAgICAgKiAgICAgb2YgdGhlIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHtPYmplY3R9IEFuIG9wdGlvbmFsIEJhY2tib25lLWxpa2Ugb3B0aW9ucyBvYmplY3Qgd2l0aFxuICAgICAqICAgICBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIGludm9rZWQgb25jZSB0aGUgaXRlcmF0aW9uXG4gICAgICogICAgIGhhcyBmaW5pc2hlZC5cbiAgICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIGZ1bGZpbGxlZCBvbmNlIHRoZVxuICAgICAqICAgICBpdGVyYXRpb24gaGFzIGNvbXBsZXRlZC5cbiAgICAgKi9cbiAgICBlYWNoOiBmdW5jdGlvbihjYWxsYmFjaywgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIGlmICh0aGlzLl9vcmRlciB8fCB0aGlzLl9za2lwIHx8ICh0aGlzLl9saW1pdCA+PSAwKSkge1xuICAgICAgICB2YXIgZXJyb3IgPVxuICAgICAgICAgIFwiQ2Fubm90IGl0ZXJhdGUgb24gYSBxdWVyeSB3aXRoIHNvcnQsIHNraXAsIG9yIGxpbWl0LlwiO1xuICAgICAgICByZXR1cm4gQVYuUHJvbWlzZS5lcnJvcihlcnJvcikuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9taXNlID0gbmV3IEFWLlByb21pc2UoKTtcblxuICAgICAgdmFyIHF1ZXJ5ID0gbmV3IEFWLlF1ZXJ5KHRoaXMub2JqZWN0Q2xhc3MpO1xuICAgICAgLy8gV2UgY2FuIG92ZXJyaWRlIHRoZSBiYXRjaCBzaXplIGZyb20gdGhlIG9wdGlvbnMuXG4gICAgICAvLyBUaGlzIGlzIHVuZG9jdW1lbnRlZCwgYnV0IHVzZWZ1bCBmb3IgdGVzdGluZy5cbiAgICAgIHF1ZXJ5Ll9saW1pdCA9IG9wdGlvbnMuYmF0Y2hTaXplIHx8IDEwMDtcbiAgICAgIHF1ZXJ5Ll93aGVyZSA9IF8uY2xvbmUodGhpcy5fd2hlcmUpO1xuICAgICAgcXVlcnkuX2luY2x1ZGUgPSBfLmNsb25lKHRoaXMuX2luY2x1ZGUpO1xuXG4gICAgICBxdWVyeS5hc2NlbmRpbmcoJ29iamVjdElkJyk7XG5cbiAgICAgIHZhciBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIEFWLlByb21pc2UuX2NvbnRpbnVlV2hpbGUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhZmluaXNoZWQ7XG5cbiAgICAgIH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcXVlcnkuZmluZCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0cykge1xuICAgICAgICAgIHZhciBjYWxsYmFja3NEb25lID0gQVYuUHJvbWlzZS5hcygpO1xuICAgICAgICAgIEFWLl8uZWFjaChyZXN1bHRzLCBmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrc0RvbmUgPSBjYWxsYmFja3NEb25lLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2tzRG9uZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID49IHF1ZXJ5Ll9saW1pdCkge1xuICAgICAgICAgICAgICBxdWVyeS5ncmVhdGVyVGhhbihcIm9iamVjdElkXCIsIHJlc3VsdHNbcmVzdWx0cy5sZW5ndGggLSAxXS5pZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBmaW5pc2hlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSkuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gICAgfVxuICB9O1xuXG4gICBBVi5GcmllbmRTaGlwUXVlcnkgPSBBVi5RdWVyeS5fZXh0ZW5kKHtcbiAgICAgX29iamVjdENsYXNzOiBBVi5Vc2VyLFxuICAgICBfbmV3T2JqZWN0OiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIG5ldyBBVi5Vc2VyKCk7XG4gICAgfSxcbiAgICAgX3Byb2Nlc3NSZXN1bHQ6IGZ1bmN0aW9uKGpzb24pe1xuICAgICAgIGlmKGpzb24gJiYganNvblt0aGlzLl9mcmllbmRzaGlwVGFnXSkge1xuICAgICAgICAgdmFyIHVzZXIgPSBqc29uW3RoaXMuX2ZyaWVuZHNoaXBUYWddO1xuICAgICAgICAgaWYodXNlci5fX3R5cGUgPT09ICdQb2ludGVyJyAmJiB1c2VyLmNsYXNzTmFtZSA9PT0gJ19Vc2VyJyl7XG4gICAgICAgICAgIGRlbGV0ZSB1c2VyLl9fdHlwZTtcbiAgICAgICAgICAgZGVsZXRlIHVzZXIuY2xhc3NOYW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdXNlcjtcbiAgICAgICB9IGVsc2Uge1xuICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgfVxuICAgIH0sXG4gICB9KTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL3F1ZXJ5LmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xudmFyIF8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oQVYpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUmVsYXRpb24gZm9yIHRoZSBnaXZlbiBwYXJlbnQgb2JqZWN0IGFuZCBrZXkuIFRoaXNcbiAgICogY29uc3RydWN0b3Igc2hvdWxkIHJhcmVseSBiZSB1c2VkIGRpcmVjdGx5LCBidXQgcmF0aGVyIGNyZWF0ZWQgYnlcbiAgICogQVYuT2JqZWN0LnJlbGF0aW9uLlxuICAgKiBAcGFyYW0ge0FWLk9iamVjdH0gcGFyZW50IFRoZSBwYXJlbnQgb2YgdGhpcyByZWxhdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IGZvciB0aGlzIHJlbGF0aW9uIG9uIHRoZSBwYXJlbnQuXG4gICAqIEBzZWUgQVYuT2JqZWN0I3JlbGF0aW9uXG4gICAqIEBjbGFzc1xuICAgKlxuICAgKiA8cD5cbiAgICogQSBjbGFzcyB0aGF0IGlzIHVzZWQgdG8gYWNjZXNzIGFsbCBvZiB0aGUgY2hpbGRyZW4gb2YgYSBtYW55LXRvLW1hbnlcbiAgICogcmVsYXRpb25zaGlwLiAgRWFjaCBpbnN0YW5jZSBvZiBBVi5SZWxhdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGggYVxuICAgKiBwYXJ0aWN1bGFyIHBhcmVudCBvYmplY3QgYW5kIGtleS5cbiAgICogPC9wPlxuICAgKi9cbiAgQVYuUmVsYXRpb24gPSBmdW5jdGlvbihwYXJlbnQsIGtleSkge1xuICAgIGlmICghIF8uaXNTdHJpbmcoa2V5KSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigna2V5IG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy50YXJnZXRDbGFzc05hbWUgPSBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgcXVlcnkgdGhhdCBjYW4gYmUgdXNlZCB0byBxdWVyeSB0aGUgcGFyZW50IG9iamVjdHMgaW4gdGhpcyByZWxhdGlvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudENsYXNzIFRoZSBwYXJlbnQgY2xhc3Mgb3IgbmFtZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aW9uS2V5IFRoZSByZWxhdGlvbiBmaWVsZCBrZXkgaW4gcGFyZW50LlxuICAgKiBAcGFyYW0ge0FWLk9iamVjdH0gY2hpbGQgVGhlIGNoaWxkIG9iamVjdC5cbiAgICogQHJldHVybiB7QVYuUXVlcnl9XG4gICAqL1xuICBBVi5SZWxhdGlvbi5yZXZlcnNlUXVlcnkgPSBmdW5jdGlvbihwYXJlbnRDbGFzcywgcmVsYXRpb25LZXksIGNoaWxkKXtcbiAgICB2YXIgcXVlcnkgPSBuZXcgQVYuUXVlcnkocGFyZW50Q2xhc3MpO1xuICAgIHF1ZXJ5LmVxdWFsVG8ocmVsYXRpb25LZXksIGNoaWxkLl90b1BvaW50ZXIoKSk7XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9O1xuXG4gIEFWLlJlbGF0aW9uLnByb3RvdHlwZSA9IHtcbiAgICAvKipcbiAgICAgKiBNYWtlcyBzdXJlIHRoYXQgdGhpcyByZWxhdGlvbiBoYXMgdGhlIHJpZ2h0IHBhcmVudCBhbmQga2V5LlxuICAgICAqL1xuICAgIF9lbnN1cmVQYXJlbnRBbmRLZXk6IGZ1bmN0aW9uKHBhcmVudCwga2V5KSB7XG4gICAgICB0aGlzLnBhcmVudCA9IHRoaXMucGFyZW50IHx8IHBhcmVudDtcbiAgICAgIHRoaXMua2V5ID0gdGhpcy5rZXkgfHwga2V5O1xuICAgICAgaWYgKHRoaXMucGFyZW50ICE9PSBwYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgXCJJbnRlcm5hbCBFcnJvci4gUmVsYXRpb24gcmV0cmlldmVkIGZyb20gdHdvIGRpZmZlcmVudCBPYmplY3RzLlwiO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMua2V5ICE9PSBrZXkpIHtcbiAgICAgICAgdGhyb3cgXCJJbnRlcm5hbCBFcnJvci4gUmVsYXRpb24gcmV0cmlldmVkIGZyb20gdHdvIGRpZmZlcmVudCBrZXlzLlwiO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgQVYuT2JqZWN0IG9yIGFuIGFycmF5IG9mIEFWLk9iamVjdHMgdG8gdGhlIHJlbGF0aW9uLlxuICAgICAqIEBwYXJhbSB7fSBvYmplY3RzIFRoZSBpdGVtIG9yIGl0ZW1zIHRvIGFkZC5cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKG9iamVjdHMpIHtcbiAgICAgIGlmICghXy5pc0FycmF5KG9iamVjdHMpKSB7XG4gICAgICAgIG9iamVjdHMgPSBbb2JqZWN0c107XG4gICAgICB9XG5cbiAgICAgIHZhciBjaGFuZ2UgPSBuZXcgQVYuT3AuUmVsYXRpb24ob2JqZWN0cywgW10pO1xuICAgICAgdGhpcy5wYXJlbnQuc2V0KHRoaXMua2V5LCBjaGFuZ2UpO1xuICAgICAgdGhpcy50YXJnZXRDbGFzc05hbWUgPSBjaGFuZ2UuX3RhcmdldENsYXNzTmFtZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIEFWLk9iamVjdCBvciBhbiBhcnJheSBvZiBBVi5PYmplY3RzIGZyb20gdGhpcyByZWxhdGlvbi5cbiAgICAgKiBAcGFyYW0ge30gb2JqZWN0cyBUaGUgaXRlbSBvciBpdGVtcyB0byByZW1vdmUuXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihvYmplY3RzKSB7XG4gICAgICBpZiAoIV8uaXNBcnJheShvYmplY3RzKSkge1xuICAgICAgICBvYmplY3RzID0gW29iamVjdHNdO1xuICAgICAgfVxuXG4gICAgICB2YXIgY2hhbmdlID0gbmV3IEFWLk9wLlJlbGF0aW9uKFtdLCBvYmplY3RzKTtcbiAgICAgIHRoaXMucGFyZW50LnNldCh0aGlzLmtleSwgY2hhbmdlKTtcbiAgICAgIHRoaXMudGFyZ2V0Q2xhc3NOYW1lID0gY2hhbmdlLl90YXJnZXRDbGFzc05hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBKU09OIHZlcnNpb24gb2YgdGhlIG9iamVjdCBzdWl0YWJsZSBmb3Igc2F2aW5nIHRvIGRpc2suXG4gICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geyBcIl9fdHlwZVwiOiBcIlJlbGF0aW9uXCIsIFwiY2xhc3NOYW1lXCI6IHRoaXMudGFyZ2V0Q2xhc3NOYW1lIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBBVi5RdWVyeSB0aGF0IGlzIGxpbWl0ZWQgdG8gb2JqZWN0cyBpbiB0aGlzXG4gICAgICogcmVsYXRpb24uXG4gICAgICogQHJldHVybiB7QVYuUXVlcnl9XG4gICAgICovXG4gICAgcXVlcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRhcmdldENsYXNzO1xuICAgICAgdmFyIHF1ZXJ5O1xuICAgICAgaWYgKCF0aGlzLnRhcmdldENsYXNzTmFtZSkge1xuICAgICAgICB0YXJnZXRDbGFzcyA9IEFWLk9iamVjdC5fZ2V0U3ViY2xhc3ModGhpcy5wYXJlbnQuY2xhc3NOYW1lKTtcbiAgICAgICAgcXVlcnkgPSBuZXcgQVYuUXVlcnkodGFyZ2V0Q2xhc3MpO1xuICAgICAgICBxdWVyeS5fZXh0cmFPcHRpb25zLnJlZGlyZWN0Q2xhc3NOYW1lRm9yS2V5ID0gdGhpcy5rZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRDbGFzcyA9IEFWLk9iamVjdC5fZ2V0U3ViY2xhc3ModGhpcy50YXJnZXRDbGFzc05hbWUpO1xuICAgICAgICBxdWVyeSA9IG5ldyBBVi5RdWVyeSh0YXJnZXRDbGFzcyk7XG4gICAgICB9XG4gICAgICBxdWVyeS5fYWRkQ29uZGl0aW9uKFwiJHJlbGF0ZWRUb1wiLCBcIm9iamVjdFwiLCB0aGlzLnBhcmVudC5fdG9Qb2ludGVyKCkpO1xuICAgICAgcXVlcnkuX2FkZENvbmRpdGlvbihcIiRyZWxhdGVkVG9cIiwgXCJrZXlcIiwgdGhpcy5rZXkpO1xuXG4gICAgICByZXR1cm4gcXVlcnk7XG4gICAgfVxuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJvTWZwQW5cIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvcmVsYXRpb24uanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEFWKSB7XG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgUm9sZSBvbiB0aGUgQVYgc2VydmVyLiBSb2xlcyByZXByZXNlbnQgZ3JvdXBpbmdzIG9mXG4gICAqIFVzZXJzIGZvciB0aGUgcHVycG9zZXMgb2YgZ3JhbnRpbmcgcGVybWlzc2lvbnMgKGUuZy4gc3BlY2lmeWluZyBhbiBBQ0xcbiAgICogZm9yIGFuIE9iamVjdCkuIFJvbGVzIGFyZSBzcGVjaWZpZWQgYnkgdGhlaXIgc2V0cyBvZiBjaGlsZCB1c2VycyBhbmRcbiAgICogY2hpbGQgcm9sZXMsIGFsbCBvZiB3aGljaCBhcmUgZ3JhbnRlZCBhbnkgcGVybWlzc2lvbnMgdGhhdCB0aGUgcGFyZW50XG4gICAqIHJvbGUgaGFzLlxuICAgKlxuICAgKiA8cD5Sb2xlcyBtdXN0IGhhdmUgYSBuYW1lICh3aGljaCBjYW5ub3QgYmUgY2hhbmdlZCBhZnRlciBjcmVhdGlvbiBvZiB0aGVcbiAgICogcm9sZSksIGFuZCBtdXN0IHNwZWNpZnkgYW4gQUNMLjwvcD5cbiAgICogQGNsYXNzXG4gICAqIEEgQVYuUm9sZSBpcyBhIGxvY2FsIHJlcHJlc2VudGF0aW9uIG9mIGEgcm9sZSBwZXJzaXN0ZWQgdG8gdGhlIEFWXG4gICAqIGNsb3VkLlxuICAgKi9cbiAgQVYuUm9sZSA9IEFWLk9iamVjdC5leHRlbmQoXCJfUm9sZVwiLCAvKiogQGxlbmRzIEFWLlJvbGUucHJvdG90eXBlICovIHtcbiAgICAvLyBJbnN0YW5jZSBNZXRob2RzXG5cbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RzIGEgbmV3IEFWUm9sZSB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCBBQ0wuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBUaGUgbmFtZSBvZiB0aGUgUm9sZSB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtBVi5BQ0x9IFthY2xdIFRoZSBBQ0wgZm9yIHRoaXMgcm9sZS4gaWYgYWJzZW50LCB0aGUgZGVmYXVsdCBBQ0xcbiAgICAgKiAgICBgeycqJzogeyByZWFkOiB0cnVlIH19YCB3aWxsIGJlIHVzZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uKG5hbWUsIGFjbCkge1xuICAgICAgaWYgKF8uaXNTdHJpbmcobmFtZSkpIHtcbiAgICAgICAgQVYuT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5jYWxsKHRoaXMsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnNldE5hbWUobmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBBVi5PYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLmNhbGwodGhpcywgbmFtZSwgYWNsKTtcbiAgICAgIH1cbiAgICAgIGlmIChhY2wgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgZGVmYXVsdEFjbCA9IG5ldyBBVi5BQ0woKTtcbiAgICAgICAgZGVmYXVsdEFjbC5zZXRQdWJsaWNSZWFkQWNjZXNzKHRydWUpO1xuICAgICAgICBpZighdGhpcy5nZXRBQ0woKSkge1xuICAgICAgICAgIHRoaXMuc2V0QUNMKGRlZmF1bHRBY2wpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCEoYWNsIGluc3RhbmNlb2YgQVYuQUNMKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhY2wgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiBBVi5BQ0wnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0QUNMKGFjbCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgdGhlIHJvbGUuICBZb3UgY2FuIGFsdGVybmF0aXZlbHkgY2FsbCByb2xlLmdldChcIm5hbWVcIilcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIHJvbGUuXG4gICAgICovXG4gICAgZ2V0TmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXQoXCJuYW1lXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBuYW1lIGZvciBhIHJvbGUuIFRoaXMgdmFsdWUgbXVzdCBiZSBzZXQgYmVmb3JlIHRoZSByb2xlIGhhc1xuICAgICAqIGJlZW4gc2F2ZWQgdG8gdGhlIHNlcnZlciwgYW5kIGNhbm5vdCBiZSBzZXQgb25jZSB0aGUgcm9sZSBoYXMgYmVlblxuICAgICAqIHNhdmVkLlxuICAgICAqXG4gICAgICogPHA+XG4gICAgICogICBBIHJvbGUncyBuYW1lIGNhbiBvbmx5IGNvbnRhaW4gYWxwaGFudW1lcmljIGNoYXJhY3RlcnMsIF8sIC0sIGFuZFxuICAgICAqICAgc3BhY2VzLlxuICAgICAqIDwvcD5cbiAgICAgKlxuICAgICAqIDxwPlRoaXMgaXMgZXF1aXZhbGVudCB0byBjYWxsaW5nIHJvbGUuc2V0KFwibmFtZVwiLCBuYW1lKTwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFRoZSBuYW1lIG9mIHRoZSByb2xlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIFN0YW5kYXJkIG9wdGlvbnMgb2JqZWN0IHdpdGggc3VjY2VzcyBhbmQgZXJyb3JcbiAgICAgKiAgICAgY2FsbGJhY2tzLlxuICAgICAqL1xuICAgIHNldE5hbWU6IGZ1bmN0aW9uKG5hbWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChcIm5hbWVcIiwgbmFtZSwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIEFWLlJlbGF0aW9uIGZvciB0aGUgQVYuVXNlcnMgdGhhdCBhcmUgZGlyZWN0XG4gICAgICogY2hpbGRyZW4gb2YgdGhpcyByb2xlLiBUaGVzZSB1c2VycyBhcmUgZ3JhbnRlZCBhbnkgcHJpdmlsZWdlcyB0aGF0IHRoaXNcbiAgICAgKiByb2xlIGhhcyBiZWVuIGdyYW50ZWQgKGUuZy4gcmVhZCBvciB3cml0ZSBhY2Nlc3MgdGhyb3VnaCBBQ0xzKS4gWW91IGNhblxuICAgICAqIGFkZCBvciByZW1vdmUgdXNlcnMgZnJvbSB0aGUgcm9sZSB0aHJvdWdoIHRoaXMgcmVsYXRpb24uXG4gICAgICpcbiAgICAgKiA8cD5UaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyByb2xlLnJlbGF0aW9uKFwidXNlcnNcIik8L3A+XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBVi5SZWxhdGlvbn0gdGhlIHJlbGF0aW9uIGZvciB0aGUgdXNlcnMgYmVsb25naW5nIHRvIHRoaXNcbiAgICAgKiAgICAgcm9sZS5cbiAgICAgKi9cbiAgICBnZXRVc2VyczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWxhdGlvbihcInVzZXJzXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBBVi5SZWxhdGlvbiBmb3IgdGhlIEFWLlJvbGVzIHRoYXQgYXJlIGRpcmVjdFxuICAgICAqIGNoaWxkcmVuIG9mIHRoaXMgcm9sZS4gVGhlc2Ugcm9sZXMnIHVzZXJzIGFyZSBncmFudGVkIGFueSBwcml2aWxlZ2VzIHRoYXRcbiAgICAgKiB0aGlzIHJvbGUgaGFzIGJlZW4gZ3JhbnRlZCAoZS5nLiByZWFkIG9yIHdyaXRlIGFjY2VzcyB0aHJvdWdoIEFDTHMpLiBZb3VcbiAgICAgKiBjYW4gYWRkIG9yIHJlbW92ZSBjaGlsZCByb2xlcyBmcm9tIHRoaXMgcm9sZSB0aHJvdWdoIHRoaXMgcmVsYXRpb24uXG4gICAgICpcbiAgICAgKiA8cD5UaGlzIGlzIGVxdWl2YWxlbnQgdG8gY2FsbGluZyByb2xlLnJlbGF0aW9uKFwicm9sZXNcIik8L3A+XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBVi5SZWxhdGlvbn0gdGhlIHJlbGF0aW9uIGZvciB0aGUgcm9sZXMgYmVsb25naW5nIHRvIHRoaXNcbiAgICAgKiAgICAgcm9sZS5cbiAgICAgKi9cbiAgICBnZXRSb2xlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWxhdGlvbihcInJvbGVzXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uKGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBpZiAoXCJuYW1lXCIgaW4gYXR0cnMgJiYgYXR0cnMubmFtZSAhPT0gdGhpcy5nZXROYW1lKCkpIHtcbiAgICAgICAgdmFyIG5ld05hbWUgPSBhdHRycy5uYW1lO1xuICAgICAgICBpZiAodGhpcy5pZCAmJiB0aGlzLmlkICE9PSBhdHRycy5vYmplY3RJZCkge1xuICAgICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgb2JqZWN0SWQgYmVpbmcgc2V0IG1hdGNoZXMgdGhpcy5pZC5cbiAgICAgICAgICAvLyBUaGlzIGhhcHBlbnMgZHVyaW5nIGEgZmV0Y2ggLS0gdGhlIGlkIGlzIHNldCBiZWZvcmUgY2FsbGluZyBmZXRjaC5cbiAgICAgICAgICAvLyBMZXQgdGhlIG5hbWUgYmUgc2V0IGluIHRoaXMgY2FzZS5cbiAgICAgICAgICByZXR1cm4gbmV3IEFWLkVycm9yKEFWLkVycm9yLk9USEVSX0NBVVNFLFxuICAgICAgICAgICAgICBcIkEgcm9sZSdzIG5hbWUgY2FuIG9ubHkgYmUgc2V0IGJlZm9yZSBpdCBoYXMgYmVlbiBzYXZlZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfLmlzU3RyaW5nKG5ld05hbWUpKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBBVi5FcnJvcihBVi5FcnJvci5PVEhFUl9DQVVTRSxcbiAgICAgICAgICAgICAgXCJBIHJvbGUncyBuYW1lIG11c3QgYmUgYSBTdHJpbmcuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKC9eWzAtOWEtekEtWlxcLV8gXSskLykudGVzdChuZXdOYW1lKSkge1xuICAgICAgICAgIHJldHVybiBuZXcgQVYuRXJyb3IoQVYuRXJyb3IuT1RIRVJfQ0FVU0UsXG4gICAgICAgICAgICAgIFwiQSByb2xlJ3MgbmFtZSBjYW4gb25seSBjb250YWluIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLCBfLFwiICtcbiAgICAgICAgICAgICAgXCIgLSwgYW5kIHNwYWNlcy5cIik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChBVi5PYmplY3QucHJvdG90eXBlLnZhbGlkYXRlKSB7XG4gICAgICAgIHJldHVybiBBVi5PYmplY3QucHJvdG90eXBlLnZhbGlkYXRlLmNhbGwodGhpcywgYXR0cnMsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9yb2xlLmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuLypnbG9iYWwgXzogZmFsc2UqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihBVikge1xuICAvKipcbiAgICogUm91dGVycyBtYXAgZmF1eC1VUkxzIHRvIGFjdGlvbnMsIGFuZCBmaXJlIGV2ZW50cyB3aGVuIHJvdXRlcyBhcmVcbiAgICogbWF0Y2hlZC4gQ3JlYXRpbmcgYSBuZXcgb25lIHNldHMgaXRzIGByb3V0ZXNgIGhhc2gsIGlmIG5vdCBzZXQgc3RhdGljYWxseS5cbiAgICogQGNsYXNzXG4gICAqXG4gICAqIDxwPkEgZm9yayBvZiBCYWNrYm9uZS5Sb3V0ZXIsIHByb3ZpZGVkIGZvciB5b3VyIGNvbnZlbmllbmNlLlxuICAgKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlIHRoZVxuICAgKiA8YSBocmVmPVwiaHR0cDovL2RvY3VtZW50Y2xvdWQuZ2l0aHViLmNvbS9iYWNrYm9uZS8jUm91dGVyXCI+QmFja2JvbmVcbiAgICogZG9jdW1lbnRhdGlvbjwvYT4uPC9wPlxuICAgKiA8cD48c3Ryb25nPjxlbT5BdmFpbGFibGUgaW4gdGhlIGNsaWVudCBTREsgb25seS48L2VtPjwvc3Ryb25nPjwvcD5cbiAgICovXG4gIEFWLlJvdXRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zb2xlLndhcm4oXCJBVi5Sb3V0ZXIgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIGRvbid0IHVzZSBpdCBhbnltb3JlLlwiKTtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy5yb3V0ZXMpIHtcbiAgICAgIHRoaXMucm91dGVzID0gb3B0aW9ucy5yb3V0ZXM7XG4gICAgfVxuICAgIHRoaXMuX2JpbmRSb3V0ZXMoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDYWNoZWQgcmVndWxhciBleHByZXNzaW9ucyBmb3IgbWF0Y2hpbmcgbmFtZWQgcGFyYW0gcGFydHMgYW5kIHNwbGF0dGVkXG4gIC8vIHBhcnRzIG9mIHJvdXRlIHN0cmluZ3MuXG4gIHZhciBuYW1lZFBhcmFtICAgID0gLzpcXHcrL2c7XG4gIHZhciBzcGxhdFBhcmFtICAgID0gL1xcKlxcdysvZztcbiAgdmFyIGVzY2FwZVJlZ0V4cCAgPSAvW1xcLVxcW1xcXXt9KCkrPy4sXFxcXFxcXlxcJFxcfCNcXHNdL2c7XG5cbiAgLy8gU2V0IHVwIGFsbCBpbmhlcml0YWJsZSAqKkFWLlJvdXRlcioqIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXG4gIF8uZXh0ZW5kKEFWLlJvdXRlci5wcm90b3R5cGUsIEFWLkV2ZW50cyxcbiAgICAgICAgICAgLyoqIEBsZW5kcyBBVi5Sb3V0ZXIucHJvdG90eXBlICovIHtcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgICAqIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8qKlxuICAgICAqIE1hbnVhbGx5IGJpbmQgYSBzaW5nbGUgbmFtZWQgcm91dGUgdG8gYSBjYWxsYmFjay4gRm9yIGV4YW1wbGU6XG4gICAgICpcbiAgICAgKiA8cHJlPnRoaXMucm91dGUoJ3NlYXJjaC86cXVlcnkvcDpudW0nLCAnc2VhcmNoJywgZnVuY3Rpb24ocXVlcnksIG51bSkge1xuICAgICAqICAgICAgIC4uLlxuICAgICAqICAgICB9KTs8L3ByZT5cbiAgICAgKi9cbiAgICByb3V0ZTogZnVuY3Rpb24ocm91dGUsIG5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICBBVi5oaXN0b3J5ID0gQVYuaGlzdG9yeSB8fCBuZXcgQVYuSGlzdG9yeSgpO1xuICAgICAgaWYgKCFfLmlzUmVnRXhwKHJvdXRlKSkge1xuICAgICAgICByb3V0ZSA9IHRoaXMuX3JvdXRlVG9SZWdFeHAocm91dGUpO1xuICAgICAgfVxuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IHRoaXNbbmFtZV07XG4gICAgICB9XG4gICAgICBBVi5oaXN0b3J5LnJvdXRlKHJvdXRlLCBfLmJpbmQoZnVuY3Rpb24oZnJhZ21lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB0aGlzLl9leHRyYWN0UGFyYW1ldGVycyhyb3V0ZSwgZnJhZ21lbnQpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyaWdnZXIuYXBwbHkodGhpcywgWydyb3V0ZTonICsgbmFtZV0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgQVYuaGlzdG9yeS50cmlnZ2VyKCdyb3V0ZScsIHRoaXMsIG5hbWUsIGFyZ3MpO1xuICAgICAgfSwgdGhpcykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFdoZW5ldmVyIHlvdSByZWFjaCBhIHBvaW50IGluIHlvdXIgYXBwbGljYXRpb24gdGhhdCB5b3UnZFxuICAgICAqIGxpa2UgdG8gc2F2ZSBhcyBhIFVSTCwgY2FsbCBuYXZpZ2F0ZSBpbiBvcmRlciB0byB1cGRhdGUgdGhlXG4gICAgICogVVJMLiBJZiB5b3Ugd2lzaCB0byBhbHNvIGNhbGwgdGhlIHJvdXRlIGZ1bmN0aW9uLCBzZXQgdGhlXG4gICAgICogdHJpZ2dlciBvcHRpb24gdG8gdHJ1ZS4gVG8gdXBkYXRlIHRoZSBVUkwgd2l0aG91dCBjcmVhdGluZ1xuICAgICAqIGFuIGVudHJ5IGluIHRoZSBicm93c2VyJ3MgaGlzdG9yeSwgc2V0IHRoZSByZXBsYWNlIG9wdGlvblxuICAgICAqIHRvIHRydWUuXG4gICAgICovXG4gICAgbmF2aWdhdGU6IGZ1bmN0aW9uKGZyYWdtZW50LCBvcHRpb25zKSB7XG4gICAgICBBVi5oaXN0b3J5Lm5hdmlnYXRlKGZyYWdtZW50LCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLy8gQmluZCBhbGwgZGVmaW5lZCByb3V0ZXMgdG8gYEFWLmhpc3RvcnlgLiBXZSBoYXZlIHRvIHJldmVyc2UgdGhlXG4gICAgLy8gb3JkZXIgb2YgdGhlIHJvdXRlcyBoZXJlIHRvIHN1cHBvcnQgYmVoYXZpb3Igd2hlcmUgdGhlIG1vc3QgZ2VuZXJhbFxuICAgIC8vIHJvdXRlcyBjYW4gYmUgZGVmaW5lZCBhdCB0aGUgYm90dG9tIG9mIHRoZSByb3V0ZSBtYXAuXG4gICAgX2JpbmRSb3V0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnJvdXRlcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgcm91dGVzID0gW107XG4gICAgICBmb3IgKHZhciByb3V0ZSBpbiB0aGlzLnJvdXRlcykge1xuICAgICAgICBpZiAodGhpcy5yb3V0ZXMuaGFzT3duUHJvcGVydHkocm91dGUpKSB7XG4gICAgICAgICAgcm91dGVzLnVuc2hpZnQoW3JvdXRlLCB0aGlzLnJvdXRlc1tyb3V0ZV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSByb3V0ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMucm91dGUocm91dGVzW2ldWzBdLCByb3V0ZXNbaV1bMV0sIHRoaXNbcm91dGVzW2ldWzFdXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSByb3V0ZSBzdHJpbmcgaW50byBhIHJlZ3VsYXIgZXhwcmVzc2lvbiwgc3VpdGFibGUgZm9yIG1hdGNoaW5nXG4gICAgLy8gYWdhaW5zdCB0aGUgY3VycmVudCBsb2NhdGlvbiBoYXNoLlxuICAgIF9yb3V0ZVRvUmVnRXhwOiBmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgcm91dGUgPSByb3V0ZS5yZXBsYWNlKGVzY2FwZVJlZ0V4cCwgJ1xcXFwkJicpXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2UobmFtZWRQYXJhbSwgJyhbXlxcL10rKScpXG4gICAgICAgICAgICAgICAgICAgLnJlcGxhY2Uoc3BsYXRQYXJhbSwgJyguKj8pJyk7XG4gICAgICByZXR1cm4gbmV3IFJlZ0V4cCgnXicgKyByb3V0ZSArICckJyk7XG4gICAgfSxcblxuICAgIC8vIEdpdmVuIGEgcm91dGUsIGFuZCBhIFVSTCBmcmFnbWVudCB0aGF0IGl0IG1hdGNoZXMsIHJldHVybiB0aGUgYXJyYXkgb2ZcbiAgICAvLyBleHRyYWN0ZWQgcGFyYW1ldGVycy5cbiAgICBfZXh0cmFjdFBhcmFtZXRlcnM6IGZ1bmN0aW9uKHJvdXRlLCBmcmFnbWVudCkge1xuICAgICAgcmV0dXJuIHJvdXRlLmV4ZWMoZnJhZ21lbnQpLnNsaWNlKDEpO1xuICAgIH1cbiAgfSk7XG5cbiAgLyoqXG4gICAqIEBmdW5jdGlvblxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VQcm9wcyBJbnN0YW5jZSBwcm9wZXJ0aWVzIGZvciB0aGUgcm91dGVyLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2xhc3NQcm9wcyBDbGFzcyBwcm9wZXJpZXMgZm9yIHRoZSByb3V0ZXIuXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIG5ldyBzdWJjbGFzcyBvZiA8Y29kZT5BVi5Sb3V0ZXI8L2NvZGU+LlxuICAgKi9cbiAgQVYuUm91dGVyLmV4dGVuZCA9IEFWLl9leHRlbmQ7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9yb3V0ZXIuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEFWKSB7XG4gIC8qKlxuICAgKiBBIGJ1aWxkZXIgdG8gZ2VuZXJhdGUgc29ydCBzdHJpbmcgZm9yIGFwcCBzZWFyY2hpbmcuRm9yIGV4YW1wbGU6XG4gICAqIDxwcmU+PGNvZGU+XG4gICAqICAgdmFyIGJ1aWxkZXIgPSBuZXcgQVYuU2VhcmNoU29ydEJ1aWxkZXIoKTtcbiAgICogICBidWlsZGVyLmFzY2VuZGluZygna2V5MScpLmRlc2NlbmRpbmcoJ2tleTInLCdtYXgnKTtcbiAgICogICB2YXIgcXVlcnkgPSBuZXcgQVYuU2VhcmNoUXVlcnkoJ1BsYXllcicpO1xuICAgKiAgIHF1ZXJ5LnNvcnRCeShidWlsZGVyKTtcbiAgICogICBxdWVyeS5maW5kKCkudGhlbiAuLi5cbiAgICogPC9jb2RlPjwvcHJlPlxuICAgKiBAY2xhc3NcbiAgICogQHNpbmNlIDAuNS4xXG4gICAqL1xuICBBVi5TZWFyY2hTb3J0QnVpbGRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuX3NvcnRGaWVsZHMgPSBbXTtcbiAgfTtcblxuICBBVi5TZWFyY2hTb3J0QnVpbGRlci5wcm90b3R5cGUgPSB7XG4gICAgX2FkZEZpZWxkOiBmdW5jdGlvbihrZXksIG9yZGVyLCBtb2RlLCBtaXNzaW5nKSB7XG4gICAgICB2YXIgZmllbGQgPSB7fTtcbiAgICAgIGZpZWxkW2tleV0gPSB7XG4gICAgICAgIG9yZGVyOiBvcmRlciB8fCAnYXNjJyxcbiAgICAgICAgbW9kZTogbW9kZSB8fCdhdmcnLFxuICAgICAgICBtaXNzaW5nOiAnXycgKyAobWlzc2luZyB8fCAnbGFzdCcpXG4gICAgICB9O1xuICAgICAgdGhpcy5fc29ydEZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSByZXN1bHRzIGluIGFzY2VuZGluZyBvcmRlciBieSB0aGUgZ2l2ZW4ga2V5IGFuZCBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IHRvIG9yZGVyIGJ5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIFRoZSBzb3J0IG1vZGUsIGRlZmF1bHQgaXMgJ2F2ZycsIHlvdSBjYW4gY2hvb3NlXG4gICAgICogICAgICAgICAgICAgICAgICAnbWF4JyBvciAnbWluJyB0b28uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pc3NpbmcgVGhlIG1pc3Npbmcga2V5IGJlaGF2aW91ciwgZGVmYXVsdCBpcyAnbGFzdCcsXG4gICAgICogICAgICAgICAgICAgICAgICB5b3UgY2FuIGNob29zZSAnZmlyc3QnIHRvby5cbiAgICAgKiBAcmV0dXJuIHtBVi5TZWFyY2hTb3J0QnVpbGRlcn0gUmV0dXJucyB0aGUgYnVpbGRlciwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgYXNjZW5kaW5nOiBmdW5jdGlvbihrZXksIG1vZGUsIG1pc3NpbmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9hZGRGaWVsZChrZXksICdhc2MnLCBtb2RlLCBtaXNzaW5nKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIHJlc3VsdHMgaW4gZGVzY2VuZGluZyBvcmRlciBieSB0aGUgZ2l2ZW4ga2V5IGFuZCBvcHRpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGtleSBUaGUga2V5IHRvIG9yZGVyIGJ5LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2RlIFRoZSBzb3J0IG1vZGUsIGRlZmF1bHQgaXMgJ2F2ZycsIHlvdSBjYW4gY2hvb3NlXG4gICAgICogICAgICAgICAgICAgICAgICAnbWF4JyBvciAnbWluJyB0b28uXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1pc3NpbmcgVGhlIG1pc3Npbmcga2V5IGJlaGF2aW91ciwgZGVmYXVsdCBpcyAnbGFzdCcsXG4gICAgICogICAgICAgICAgICAgICAgICB5b3UgY2FuIGNob29zZSAnZmlyc3QnIHRvby5cbiAgICAgKiBAcmV0dXJuIHtBVi5TZWFyY2hTb3J0QnVpbGRlcn0gUmV0dXJucyB0aGUgYnVpbGRlciwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgZGVzY2VuZGluZzogZnVuY3Rpb24oa2V5LCBtb2RlLCBtaXNzaW5nKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYWRkRmllbGQoa2V5LCAnZGVzYycsIG1vZGUsIG1pc3NpbmcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBwcm94aW1pdHkgYmFzZWQgY29uc3RyYWludCBmb3IgZmluZGluZyBvYmplY3RzIHdpdGgga2V5IHBvaW50XG4gICAgICogdmFsdWVzIG5lYXIgdGhlIHBvaW50IGdpdmVuLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIGtleSB0aGF0IHRoZSBBVi5HZW9Qb2ludCBpcyBzdG9yZWQgaW4uXG4gICAgICogQHBhcmFtIHtBVi5HZW9Qb2ludH0gcG9pbnQgVGhlIHJlZmVyZW5jZSBBVi5HZW9Qb2ludCB0aGF0IGlzIHVzZWQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG90aGVyIG9wdGlvbnMgc3VjaCBhcyBtb2RlLG9yZGVyLCB1bml0IGV0Yy5cbiAgICAgKiBAcmV0dXJuIHtBVi5TZWFyY2hTb3J0QnVpbGRlcn0gUmV0dXJucyB0aGUgYnVpbGRlciwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgd2hlcmVOZWFyOiBmdW5jdGlvbihrZXksIHBvaW50LCBvcHRpb25zKSB7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgIHZhciBmaWVsZCA9IHt9O1xuICAgICAgdmFyIGdlbyA9IHtcbiAgICAgICAgbGF0OiBwb2ludC5sYXRpdHVkZSxcbiAgICAgICAgbG9uOiBwb2ludC5sb25naXR1ZGVcbiAgICAgIH07XG4gICAgICB2YXIgbSA9IHtcbiAgICAgICAgb3JkZXI6IG9wdGlvbnMub3JkZXIgfHwgJ2FzYycsXG4gICAgICAgIG1vZGU6IG9wdGlvbnMubW9kZSB8fCAnYXZnJyxcbiAgICAgICAgdW5pdDogb3B0aW9ucy51bml0IHx8ICdrbSdcbiAgICAgIH07XG4gICAgICBtW2tleV0gPSBnZW87XG4gICAgICBmaWVsZFsnX2dlb19kaXN0YW5jZSddID0gbTtcblxuICAgICAgdGhpcy5fc29ydEZpZWxkcy5wdXNoKGZpZWxkKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBCdWlsZCBhIHNvcnQgc3RyaW5nIGJ5IGNvbmZpZ3VyYXRpb24uXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgc29ydCBzdHJpbmcuXG4gICAgICovXG4gICAgYnVpbGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KEFWLl9lbmNvZGUodGhpcy5fc29ydEZpZWxkcykpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQXBwIHNlYXJjaGluZyBxdWVyeS5Vc2UganVzdCBsaWtlIEFWLlF1ZXJ5OlxuICAgKiA8cHJlPjxjb2RlPlxuICAgKiAgIHZhciBxdWVyeSA9IG5ldyBBVi5TZWFyY2hRdWVyeSgnUGxheWVyJyk7XG4gICAqICAgcXVlcnkucXVlcnlTdHJpbmcoJyonKTtcbiAgICogICBxdWVyeS5maW5kKCkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7XG4gICAqICAgICBjb25zb2xlLmxvZygnRm91bmQgJWQgb2JqZWN0cycsIHF1ZXJ5LmhpdHMoKSk7XG4gICAqICAgICAvL1Byb2Nlc3MgcmVzdWx0c1xuICAgKiAgIH0pO1xuICAgKlxuICAgKiA8L2NvZGU+PC9wcmU+XG4gICAqIFZpc2l0ZSA8YSBocmVmPSdodHRwczovL2xlYW5jbG91ZC5jbi9kb2NzL2FwcF9zZWFyY2hfZ3VpZGUuaHRtbCc+QXBwIFNlYXJjaGluZyBHdWlkZTwvYT5cbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICogQGNsYXNzXG4gICAqIEBzaW5jZSAwLjUuMVxuICAgKlxuICAgKi9cbiAgQVYuU2VhcmNoUXVlcnkgPSBBVi5RdWVyeS5fZXh0ZW5kKC8qKiBAbGVuZHMgQVYuU2VhcmNoUXVlcnkucHJvdG90eXBlICove1xuICAgICBfc2lkOiBudWxsLFxuICAgICBfaGl0czogIDAsXG4gICAgIF9xdWVyeVN0cmluZzogbnVsbCxcbiAgICAgX2hpZ2hsaWdodHM6IG51bGwsXG4gICAgIF9zb3J0QnVpbGRlcjogbnVsbCxcbiAgICBfY3JlYXRlUmVxdWVzdDogZnVuY3Rpb24ocGFyYW1zKXtcbiAgICAgIHJldHVybiBBVi5fcmVxdWVzdChcInNlYXJjaC9zZWxlY3RcIiwgbnVsbCwgbnVsbCwgXCJHRVRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zIHx8IHRoaXMudG9KU09OKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzaWQgb2YgYXBwIHNlYXJjaGluZyBxdWVyeS5EZWZhdWx0IGlzIG51bGwuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNpZCAgU2Nyb2xsIGlkIGZvciBzZWFyY2hpbmcuXG4gICAgICogQHJldHVybiB7QVYuU2VhcmNoUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBzaWQ6IGZ1bmN0aW9uKHNpZCkge1xuICAgICAgdGhpcy5fc2lkID0gc2lkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHF1ZXJ5IHN0cmluZyBvZiBhcHAgc2VhcmNoaW5nLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBxICBUaGUgcXVlcnkgc3RyaW5nLlxuICAgICAqIEByZXR1cm4ge0FWLlNlYXJjaFF1ZXJ5fSBSZXR1cm5zIHRoZSBxdWVyeSwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgcXVlcnlTdHJpbmc6IGZ1bmN0aW9uKHEpIHtcbiAgICAgIHRoaXMuX3F1ZXJ5U3RyaW5nID0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGhpZ2hsaWdodCBmaWVsZHMuIFN1Y2ggYXNcbiAgICAgKiA8cHJlPjxjb2RlPlxuICAgICAqICAgcXVlcnkuaGlnaGxpZ2h0cygndGl0bGUnKTtcbiAgICAgKiAgIC8vb3IgcGFzcyBhbiBhcnJheS5cbiAgICAgKiAgIHF1ZXJ5LmhpZ2hsaWdodHMoWyd0aXRsZScsICdjb250ZW50J10pXG4gICAgICogPC9jb2RlPjwvcHJlPlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhpZ2hsaWdodHMgYSBsaXN0IG9mIGZpZWxkcy5cbiAgICAgKiBAcmV0dXJuIHtBVi5TZWFyY2hRdWVyeX0gUmV0dXJucyB0aGUgcXVlcnksIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGhpZ2hsaWdodHM6IGZ1bmN0aW9uKGhpZ2hsaWdodHMpIHtcbiAgICAgIHZhciBvYmplY3RzO1xuICAgICAgaWYgKGhpZ2hsaWdodHMgJiYgXy5pc1N0cmluZyhoaWdobGlnaHRzKSkge1xuICAgICAgICBvYmplY3RzID0gYXJndW1lbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0cyA9IGhpZ2hsaWdodHM7XG4gICAgICB9XG4gICAgICB0aGlzLl9oaWdobGlnaHRzID0gb2JqZWN0cztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzb3J0IGJ1aWxkZXIgZm9yIHRoaXMgcXVlcnkuXG4gICAgICogQHNlZSBBVi5TZWFyY2hTb3J0QnVpbGRlclxuICAgICAqIEBwYXJhbSB7IEFWLlNlYXJjaFNvcnRCdWlsZGVyfSBidWlsZGVyIFRoZSBzb3J0IGJ1aWxkZXIuXG4gICAgICogQHJldHVybiB7QVYuU2VhcmNoUXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnRCeTogZnVuY3Rpb24oYnVpbGRlcikge1xuICAgICAgdGhpcy5fc29ydEJ1aWxkZXIgPSBidWlsZGVyO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG51bWJlciBvZiBvYmplY3RzIHRoYXQgbWF0Y2ggdGhpcyBxdWVyeS5cbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAgICovXG4gICAgaGl0czogZnVuY3Rpb24oKSB7XG4gICAgICAgaWYgKCF0aGlzLl9oaXRzKSB7XG4gICAgICAgIHRoaXMuX2hpdHMgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2hpdHM7XG4gICAgfSxcblxuICAgIF9wcm9jZXNzUmVzdWx0OiBmdW5jdGlvbihqc29uKXtcbiAgICAgICBkZWxldGUganNvblsnY2xhc3NOYW1lJ107XG4gICAgICAgZGVsZXRlIGpzb25bJ19hcHBfdXJsJ107XG4gICAgICAgZGVsZXRlIGpzb25bJ19kZWVwbGluayddO1xuICAgICAgIHJldHVybiBqc29uO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgd2hlbiB0aGVyZSBhcmUgbW9yZSBkb2N1bWVudHMgY2FuIGJlIHJldHJpZXZlZCBieSB0aGlzXG4gICAgICogcXVlcnkgaW5zdGFuY2UsIHlvdSBjYW4gY2FsbCBmaW5kIGZ1bmN0aW9uIHRvIGdldCBtb3JlIHJlc3VsdHMuXG4gICAgICogQHNlZSBBVi5TZWFyY2hRdWVyeSNmaW5kXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNNb3JlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhdGhpcy5faGl0RW5kO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXNldCBjdXJyZW50IHF1ZXJ5IGluc3RhbmNlIHN0YXRlKHN1Y2ggYXMgc2lkLCBoaXRzIGV0YykgZXhjZXB0IHBhcmFtc1xuICAgICAqIGZvciBhIG5ldyBzZWFyY2hpbmcuIEFmdGVyIHJlc2V0dGluZywgaGFzTW9yZSgpIHdpbGwgcmV0dXJuIHRydWUuXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5faGl0RW5kID0gZmFsc2U7XG4gICAgICB0aGlzLl9zaWQgPSBudWxsO1xuICAgICAgdGhpcy5faGl0cyA9IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIGxpc3Qgb2YgQVZPYmplY3RzIHRoYXQgc2F0aXNmeSB0aGlzIHF1ZXJ5LlxuICAgICAqIEVpdGhlciBvcHRpb25zLnN1Y2Nlc3Mgb3Igb3B0aW9ucy5lcnJvciBpcyBjYWxsZWQgd2hlbiB0aGUgZmluZFxuICAgICAqIGNvbXBsZXRlcy5cbiAgICAgKlxuICAgICAqIEBzZWUgQVYuUXVlcnkjZmluZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0cyB3aGVuXG4gICAgICogdGhlIHF1ZXJ5IGNvbXBsZXRlcy5cbiAgICAgKi9cbiAgICBmaW5kOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5fY3JlYXRlUmVxdWVzdCgpO1xuXG4gICAgICByZXR1cm4gcmVxdWVzdC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgIC8vdXBkYXRlIHNpZCBmb3IgbmV4dCBxdWVyeWluZy5cbiAgICAgICAgaWYocmVzcG9uc2Uuc2lkKSB7XG4gICAgICAgICAgc2VsZi5fb2xkU2lkID0gc2VsZi5fc2lkO1xuICAgICAgICAgIHNlbGYuX3NpZCA9IHJlc3BvbnNlLnNpZDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLl9zaWQgPSBudWxsO1xuICAgICAgICAgIHNlbGYuX2hpdEVuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi5faGl0cyA9IHJlc3BvbnNlLmhpdHMgfHwgMDtcblxuICAgICAgICByZXR1cm4gXy5tYXAocmVzcG9uc2UucmVzdWx0cywgZnVuY3Rpb24oanNvbikge1xuICAgICAgICAgIGlmKGpzb24uY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICByZXNwb25zZS5jbGFzc05hbWUgPSBqc29uLmNsYXNzTmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIG9iaiA9IHNlbGYuX25ld09iamVjdChyZXNwb25zZSk7XG4gICAgICAgICAgb2JqLmFwcFVSTCA9IGpzb25bJ19hcHBfdXJsJ107XG4gICAgICAgICAgb2JqLl9maW5pc2hGZXRjaChzZWxmLl9wcm9jZXNzUmVzdWx0KGpzb24pLCB0cnVlKTtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9KTtcbiAgICAgIH0pLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcGFyYW1zID0gQVYuU2VhcmNoUXVlcnkuX19zdXBlcl9fLnRvSlNPTi5jYWxsKHRoaXMpO1xuICAgICAgZGVsZXRlIHBhcmFtcy53aGVyZTtcbiAgICAgIGlmKHRoaXMuY2xhc3NOYW1lKSB7XG4gICAgICAgIHBhcmFtcy5jbGF6eiA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgfVxuICAgICAgaWYodGhpcy5fc2lkKSB7XG4gICAgICAgIHBhcmFtcy5zaWQgPSB0aGlzLl9zaWQ7XG4gICAgICB9XG4gICAgICBpZighdGhpcy5fcXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgJ1BsZWFzZSBzZXQgcXVlcnkgc3RyaW5nLic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwYXJhbXMucSA9IHRoaXMuX3F1ZXJ5U3RyaW5nO1xuICAgICAgfVxuICAgICAgaWYodGhpcy5faGlnaGxpZ2h0cykge1xuICAgICAgICBwYXJhbXMuaGlnaGxpZ2h0cyA9IHRoaXMuX2hpZ2hsaWdodHMuam9pbignLCcpO1xuICAgICAgfVxuICAgICAgaWYodGhpcy5fc29ydEJ1aWxkZXIgJiYgcGFyYW1zLm9yZGVyKSB7XG4gICAgICAgIHRocm93ICdzb3J0IGFuZCBvcmRlciBjYW4gbm90IGJlIHNldCBhdCBzYW1lIHRpbWUuJztcbiAgICAgIH1cbiAgICAgIGlmKHRoaXMuX3NvcnRCdWlsZGVyKSB7XG4gICAgICAgIHBhcmFtcy5zb3J0ID0gdGhpcy5fc29ydEJ1aWxkZXIuYnVpbGQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gIH0pO1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJvTWZwQW5cIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvc2VhcmNoLmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihBVikge1xuICAvKipcbiAgICogQ29udGFpbnMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBTdGF0dXMgaW4gQVZPUyBDbG91ZC5cbiAgICogQG5hbWUgQVYuU3RhdHVzXG4gICAqIEBuYW1lc3BhY2VcbiAgICovXG4gIEFWLlN0YXR1cyA9IGZ1bmN0aW9uKGltYWdlVXJsLCBtZXNzYWdlKSB7XG4gICAgdGhpcy5kYXRhID0ge307XG4gICAgdGhpcy5pbmJveFR5cGUgPSAnZGVmYXVsdCc7XG4gICAgdGhpcy5xdWVyeSA9IG51bGw7XG4gICAgaWYoaW1hZ2VVcmwgJiYgdHlwZW9mIGltYWdlVXJsID09PSAnb2JqZWN0Jykge1xuICAgICAgICB0aGlzLmRhdGEgPSBpbWFnZVVybDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYoaW1hZ2VVcmwpe1xuICAgICAgICB0aGlzLmRhdGEuaW1hZ2UgPSBpbWFnZVVybDtcbiAgICAgIH1cbiAgICAgIGlmKG1lc3NhZ2Upe1xuICAgICAgICB0aGlzLmRhdGEubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEFWLlN0YXR1cy5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgdmFsdWUgb2YgYW4gYXR0cmlidXRlIGluIHN0YXR1cyBkYXRhLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyIFRoZSBzdHJpbmcgbmFtZSBvZiBhbiBhdHRyaWJ1dGUuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihhdHRyKXtcbiAgICAgIHJldHVybiB0aGlzLmRhdGFbYXR0cl07XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXRzIGEgaGFzaCBvZiBtb2RlbCBhdHRyaWJ1dGVzIG9uIHRoZSBzdGF0dXMgZGF0YS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30ga2V5IFRoZSBrZXkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7fSB2YWx1ZSBUaGUgdmFsdWUgdG8gZ2l2ZSBpdC5cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKGtleSwgdmFsdWUpe1xuICAgICAgdGhpcy5kYXRhW2tleV0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogRGVzdHJveSB0aGlzIHN0YXR1cyx0aGVuIGl0IHdpbGwgbm90IGJlIGF2YWlhYmxlIGluIG90aGVyIHVzZXIncyBpbmJveGVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIEJhY2tib25lLWxpa2Ugb3B0aW9ucyBvYmplY3Qgd2l0aFxuICAgICAqICAgICBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIGludm9rZWQgb25jZSB0aGUgaXRlcmF0aW9uXG4gICAgICogICAgIGhhcyBmaW5pc2hlZC5cbiAgICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiB0aGUgZGVzdHJveVxuICAgICAqICAgICBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgZGVzdHJveTogZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgICBpZighdGhpcy5pZClcbiAgICAgICAgcmV0dXJuIEFWLlByb21pc2UuZXJyb3IoJ1RoZSBzdGF0dXMgaWQgaXMgbm90IGV4aXN0cy4nKS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zKTtcbiAgICAgIHZhciByZXF1ZXN0ID0gQVYuX3JlcXVlc3QoXCJzdGF0dXNlc1wiLCBudWxsLCB0aGlzLmlkLCAnREVMRVRFJyk7XG4gICAgICByZXR1cm4gcmVxdWVzdC5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgKiBDYXN0IHRoZSBBVi5TdGF0dXMgb2JqZWN0IHRvIGFuIEFWLk9iamVjdCBwb2ludGVyLlxuICAgICAgKiBAcmV0dXJuIHtBVi5PYmplY3R9IEEgQVYuT2JqZWN0IHBvaW50ZXIuXG4gICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpe1xuICAgICAgaWYoIXRoaXMuaWQpXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICByZXR1cm4gQVYuT2JqZWN0LmNyZWF0ZVdpdGhvdXREYXRhKCdfU3RhdHVzJywgdGhpcy5pZCk7XG4gICAgfSxcbiAgICBfZ2V0RGF0YUpTT046IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGpzb24gPSBBVi5fLmNsb25lKHRoaXMuZGF0YSk7XG4gICAgICByZXR1cm4gQVYuX2VuY29kZShqc29uKTtcbiAgICB9LFxuICAgLyoqXG4gICAgKiBTZW5kICBhIHN0YXR1cyBieSBhIEFWLlF1ZXJ5IG9iamVjdC5cbiAgICAqIDxwPkZvciBleGFtcGxlLHNlbmQgYSBzdGF0dXMgdG8gbWFsZSB1c2Vyczo8YnIvPjxwcmU+XG4gICAgKiAgICAgdmFyIHN0YXR1cyA9IG5ldyBBVlN0YXR1cygnaW1hZ2UgdXJsJywgJ2EgbWVzc2FnZScpO1xuICAgICogICAgIHN0YXR1cy5xdWVyeSA9IG5ldyBBVi5RdWVyeSgnX1VzZXInKTtcbiAgICAqICAgICBzdGF0dXMucXVlcnkuZXF1YWxUbygnZ2VuZGVyJywgJ21hbGUnKTtcbiAgICAqICAgICBzdGF0dXMuc2VuZCgpLnRoZW4oZnVuY3Rpb24oKXtcbiAgICAqICAgICAgICAgICAgICAvL3NlbmQgc3RhdHVzIHN1Y2Nlc3NmdWxseS5cbiAgICAqICAgICAgfSwgZnVuY3Rpb24oZXJyKXtcbiAgICAqICAgICAgICAgICAgIC8vYW4gZXJyb3IgdGhyZXcuXG4gICAgKiAgICAgICAgICAgICBjb25zb2xlLmRpcihlcnIpO1xuICAgICogICAgICB9KTtcbiAgICAqIDwvcHJlPjwvcD5cbiAgICAqIEBzaW5jZSAwLjMuMFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9uYWwgQmFja2JvbmUtbGlrZSBvcHRpb25zIG9iamVjdCB3aXRoXG4gICAgKiAgICAgc3VjY2VzcyBhbmQgZXJyb3IgY2FsbGJhY2tzIHRoYXQgd2lsbCBiZSBpbnZva2VkIG9uY2UgdGhlIGl0ZXJhdGlvblxuICAgICogICAgIGhhcyBmaW5pc2hlZC5cbiAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIHRoZSBzZW5kXG4gICAgKiAgICAgY29tcGxldGVzLlxuICAgICovXG4gICAgc2VuZDogZnVuY3Rpb24ob3B0aW9ucyl7XG4gICAgICBpZighQVYuVXNlci5jdXJyZW50KCkpe1xuICAgICAgICB0aHJvdyAnUGxlYXNlIHNpZ25pbiBhbiB1c2VyLic7XG4gICAgICB9XG4gICAgICBpZighdGhpcy5xdWVyeSl7XG4gICAgICAgIHJldHVybiBBVi5TdGF0dXMuc2VuZFN0YXR1c1RvRm9sbG93ZXJzKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcXVlcnkgPSB0aGlzLnF1ZXJ5LnRvSlNPTigpO1xuICAgICAgcXVlcnkuY2xhc3NOYW1lID0gdGhpcy5xdWVyeS5jbGFzc05hbWU7XG4gICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgZGF0YS5xdWVyeSA9IHF1ZXJ5O1xuICAgICAgdGhpcy5kYXRhID0gdGhpcy5kYXRhIHx8IHt9O1xuICAgICAgdmFyIGN1cnJVc2VyID0gIEFWLk9iamVjdC5jcmVhdGVXaXRob3V0RGF0YSgnX1VzZXInLCBBVi5Vc2VyLmN1cnJlbnQoKS5pZCkuX3RvUG9pbnRlcigpO1xuICAgICAgdGhpcy5kYXRhLnNvdXJjZSA9ICB0aGlzLmRhdGEuc291cmNlIHx8IGN1cnJVc2VyO1xuICAgICAgZGF0YS5kYXRhID0gdGhpcy5fZ2V0RGF0YUpTT04oKTtcbiAgICAgIGRhdGEuaW5ib3hUeXBlID0gdGhpcy5pbmJveFR5cGUgfHwgJ2RlZmF1bHQnO1xuXG4gICAgICB2YXIgcmVxdWVzdCA9IEFWLl9yZXF1ZXN0KCdzdGF0dXNlcycsIG51bGwsIG51bGwsICdQT1NUJywgZGF0YSk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gcmVxdWVzdC50aGVuKGZ1bmN0aW9uKHJlc3BvbnNlKXtcbiAgICAgICAgc2VsZi5pZCA9IHJlc3BvbnNlLm9iamVjdElkO1xuICAgICAgICBzZWxmLmNyZWF0ZWRBdCA9IEFWLl9wYXJzZURhdGUocmVzcG9uc2UuY3JlYXRlZEF0KTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9KS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgX2ZpbmlzaEZldGNoOiBmdW5jdGlvbihzZXJ2ZXJEYXRhKXtcbiAgICAgICAgdGhpcy5pZCA9IHNlcnZlckRhdGEub2JqZWN0SWQ7XG4gICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gQVYuX3BhcnNlRGF0ZShzZXJ2ZXJEYXRhLmNyZWF0ZWRBdCk7XG4gICAgICAgIHRoaXMudXBkYXRlZEF0ID0gQVYuX3BhcnNlRGF0ZShzZXJ2ZXJEYXRhLnVwZGF0ZWRBdCk7XG4gICAgICAgIHRoaXMubWVzc2FnZUlkID0gc2VydmVyRGF0YS5tZXNzYWdlSWQ7XG4gICAgICAgIGRlbGV0ZSBzZXJ2ZXJEYXRhLm1lc3NhZ2VJZDtcbiAgICAgICAgZGVsZXRlIHNlcnZlckRhdGEub2JqZWN0SWQ7XG4gICAgICAgIGRlbGV0ZSBzZXJ2ZXJEYXRhLmNyZWF0ZWRBdDtcbiAgICAgICAgZGVsZXRlIHNlcnZlckRhdGEudXBkYXRlZEF0O1xuICAgICAgICB0aGlzLmRhdGEgPSBBVi5fZGVjb2RlKHVuZGVmaW5lZCwgc2VydmVyRGF0YSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZW5kICBhIHN0YXR1cyB0byBjdXJyZW50IHNpZ25pbmVkIHVzZXIncyBmb2xsb3dlcnMuRm9yIGV4YW1wbGU6XG4gICAqIDxwPjxwcmU+XG4gICAqICAgICB2YXIgc3RhdHVzID0gbmV3IEFWU3RhdHVzKCdpbWFnZSB1cmwnLCAnYSBtZXNzYWdlJyk7XG4gICAqICAgICBBVi5TdGF0dXMuc2VuZFN0YXR1c1RvRm9sbG93ZXJzKHN0YXR1cykudGhlbihmdW5jdGlvbigpe1xuICAgKiAgICAgICAgICAgICAgLy9zZW5kIHN0YXR1cyBzdWNjZXNzZnVsbHkuXG4gICAqICAgICAgfSwgZnVuY3Rpb24oZXJyKXtcbiAgICogICAgICAgICAgICAgLy9hbiBlcnJvciB0aHJldy5cbiAgICogICAgICAgICAgICAgY29uc29sZS5kaXIoZXJyKTtcbiAgICogICAgICB9KTtcbiAgICogPC9wcmU+PC9wPlxuICAgKiBAc2luY2UgMC4zLjBcbiAgICogQHBhcmFtIHtBVi5TdGF0dXN9IHN0YXR1cyAgQSBzdGF0dXMgb2JqZWN0IHRvIGJlIHNlbmQgdG8gZm9sbG93ZXJzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25hbCBCYWNrYm9uZS1saWtlIG9wdGlvbnMgb2JqZWN0IHdpdGhcbiAgICogICAgIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrcyB0aGF0IHdpbGwgYmUgaW52b2tlZCBvbmNlIHRoZSBpdGVyYXRpb25cbiAgICogICAgIGhhcyBmaW5pc2hlZC5cbiAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gdGhlIHNlbmRcbiAgICogICAgIGNvbXBsZXRlcy5cbiAgICovXG4gIEFWLlN0YXR1cy5zZW5kU3RhdHVzVG9Gb2xsb3dlcnMgPSBmdW5jdGlvbihzdGF0dXMsIG9wdGlvbnMpIHtcbiAgICBpZighQVYuVXNlci5jdXJyZW50KCkpe1xuICAgICAgdGhyb3cgJ1BsZWFzZSBzaWduaW4gYW4gdXNlci4nO1xuICAgIH1cbiAgICB2YXIgcXVlcnkgPSB7fTtcbiAgICBxdWVyeS5jbGFzc05hbWUgPSAnX0ZvbGxvd2VyJztcbiAgICBxdWVyeS5rZXlzID0gJ2ZvbGxvd2VyJztcbiAgICB2YXIgY3VyclVzZXIgPSAgQVYuT2JqZWN0LmNyZWF0ZVdpdGhvdXREYXRhKCdfVXNlcicsIEFWLlVzZXIuY3VycmVudCgpLmlkKS4gX3RvUG9pbnRlcigpO1xuICAgIHF1ZXJ5LndoZXJlID0ge3VzZXI6IGN1cnJVc2VyfTtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIGRhdGEucXVlcnkgPSBxdWVyeTtcbiAgICBzdGF0dXMuZGF0YSA9IHN0YXR1cy5kYXRhIHx8IHt9O1xuICAgIHN0YXR1cy5kYXRhLnNvdXJjZSA9ICBzdGF0dXMuZGF0YS5zb3VyY2UgfHwgY3VyclVzZXI7XG4gICAgZGF0YS5kYXRhID0gc3RhdHVzLl9nZXREYXRhSlNPTigpO1xuICAgIGRhdGEuaW5ib3hUeXBlID0gc3RhdHVzLmluYm94VHlwZSB8fCAnZGVmYXVsdCc7XG5cbiAgICB2YXIgcmVxdWVzdCA9IEFWLl9yZXF1ZXN0KCdzdGF0dXNlcycsIG51bGwsIG51bGwsICdQT1NUJywgZGF0YSk7XG4gICAgcmV0dXJuIHJlcXVlc3QudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICBzdGF0dXMuaWQgPSByZXNwb25zZS5vYmplY3RJZDtcbiAgICAgIHN0YXR1cy5jcmVhdGVkQXQgPSBBVi5fcGFyc2VEYXRlKHJlc3BvbnNlLmNyZWF0ZWRBdCk7XG4gICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH0pLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiA8cD5TZW5kICBhIHN0YXR1cyBmcm9tIGN1cnJlbnQgc2lnbmluZWQgdXNlciB0byBvdGhlciB1c2VyJ3MgcHJpdmF0ZSBzdGF0dXMgaW5ib3guPC9wPlxuICAgKiA8cD5Gb3IgZXhhbXBsZSxzZW5kIGEgcHJpdmF0ZSBzdGF0dXMgdG8gdXNlciAnNTJlODRlNDdlNGIwZjhkZTI4M2IwNzliJzo8YnIvPlxuICAgKiA8cHJlPlxuICAgKiAgICB2YXIgc3RhdHVzID0gbmV3IEFWU3RhdHVzKCdpbWFnZSB1cmwnLCAnYSBtZXNzYWdlJyk7XG4gICAqICAgICBBVi5TdGF0dXMuc2VuZFByaXZhdGVTdGF0dXMoc3RhdHVzLCAnNTJlODRlNDdlNGIwZjhkZTI4M2IwNzliJykudGhlbihmdW5jdGlvbigpe1xuICAgKiAgICAgICAgICAgICAgLy9zZW5kIHN0YXR1cyBzdWNjZXNzZnVsbHkuXG4gICAqICAgICAgfSwgZnVuY3Rpb24oZXJyKXtcbiAgICogICAgICAgICAgICAgLy9hbiBlcnJvciB0aHJldy5cbiAgICogICAgICAgICAgICAgY29uc29sZS5kaXIoZXJyKTtcbiAgICogICAgICB9KTtcbiAgICogPC9wcmU+PC9wPlxuICAgKiBAc2luY2UgMC4zLjBcbiAgICogQHBhcmFtIHtBVi5TdGF0dXN9IHN0YXR1cyAgQSBzdGF0dXMgb2JqZWN0IHRvIGJlIHNlbmQgdG8gZm9sbG93ZXJzLlxuICAgKiBAcGFyYW0ge30gdGFyZ2V0IFRoZSB0YXJnZXQgdXNlciBvciB1c2VyJ3Mgb2JqZWN0SWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIEJhY2tib25lLWxpa2Ugb3B0aW9ucyBvYmplY3Qgd2l0aFxuICAgKiAgICAgc3VjY2VzcyBhbmQgZXJyb3IgY2FsbGJhY2tzIHRoYXQgd2lsbCBiZSBpbnZva2VkIG9uY2UgdGhlIGl0ZXJhdGlvblxuICAgKiAgICAgaGFzIGZpbmlzaGVkLlxuICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiB0aGUgc2VuZFxuICAgKiAgICAgY29tcGxldGVzLlxuICAgKi9cbiAgQVYuU3RhdHVzLnNlbmRQcml2YXRlU3RhdHVzID0gZnVuY3Rpb24oc3RhdHVzLCB0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICBpZighQVYuVXNlci5jdXJyZW50KCkpe1xuICAgICAgdGhyb3cgJ1BsZWFzZSBzaWduaW4gYW4gdXNlci4nO1xuICAgIH1cbiAgICBpZighdGFyZ2V0KXtcbiAgICAgICAgICB0aHJvdyBcIkludmFsaWQgdGFyZ2V0IHVzZXIuXCI7XG4gICAgfVxuICAgIHZhciB1c2VyT2JqZWN0SWQgPSBfLmlzU3RyaW5nKHRhcmdldCkgPyB0YXJnZXQ6IHRhcmdldC5pZDtcbiAgICBpZighdXNlck9iamVjdElkKXtcbiAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhcmdldCB1c2VyLlwiO1xuICAgIH1cblxuICAgIHZhciBxdWVyeSA9IHt9O1xuICAgIHF1ZXJ5LmNsYXNzTmFtZSA9ICdfVXNlcic7XG4gICAgdmFyIGN1cnJVc2VyID0gIEFWLk9iamVjdC5jcmVhdGVXaXRob3V0RGF0YSgnX1VzZXInLCBBVi5Vc2VyLmN1cnJlbnQoKS5pZCkuIF90b1BvaW50ZXIoKTtcbiAgICBxdWVyeS53aGVyZSA9IHtvYmplY3RJZDogdXNlck9iamVjdElkfTtcbiAgICB2YXIgZGF0YSA9IHt9O1xuICAgIGRhdGEucXVlcnkgPSBxdWVyeTtcbiAgICBzdGF0dXMuZGF0YSA9IHN0YXR1cy5kYXRhIHx8IHt9O1xuICAgIHN0YXR1cy5kYXRhLnNvdXJjZSA9ICBzdGF0dXMuZGF0YS5zb3VyY2UgfHwgY3VyclVzZXI7XG4gICAgZGF0YS5kYXRhID0gc3RhdHVzLl9nZXREYXRhSlNPTigpO1xuICAgIGRhdGEuaW5ib3hUeXBlID0gJ3ByaXZhdGUnO1xuICAgIHN0YXR1cy5pbmJveFR5cGUgPSAncHJpdmF0ZSc7XG5cbiAgICB2YXIgcmVxdWVzdCA9IEFWLl9yZXF1ZXN0KCdzdGF0dXNlcycsIG51bGwsIG51bGwsICdQT1NUJywgZGF0YSk7XG4gICAgcmV0dXJuIHJlcXVlc3QudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAgICBzdGF0dXMuaWQgPSByZXNwb25zZS5vYmplY3RJZDtcbiAgICAgIHN0YXR1cy5jcmVhdGVkQXQgPSBBVi5fcGFyc2VEYXRlKHJlc3BvbnNlLmNyZWF0ZWRBdCk7XG4gICAgICByZXR1cm4gc3RhdHVzO1xuICAgIH0pLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb3VudCB1bnJlYWQgc3RhdHVzZXMgaW4gc29tZW9uZSdzIGluYm94LkZvciBleGFtcGxlOjxici8+XG4gICAqIDxwPjxwcmU+XG4gICAqICBBVi5TdGF0dXMuY291bnRVbnJlYWRTdGF0dXNlcyhBVi5Vc2VyLmN1cnJlbnQoKSkudGhlbihmdW5jdGlvbihyZXNwb25zZSl7XG4gICAqICAgIGNvbnNvbGUubG9nKHJlc3BvbnNlLnVucmVhZCk7IC8vdW5yZWFkIHN0YXR1c2VzIG51bWJlci5cbiAgICogICAgY29uc29sZS5sb2cocmVzcG9uc2UudG90YWwpOyAgLy90b3RhbCBzdGF0dXNlcyBudW1iZXIuXG4gICAqICB9KTtcbiAgICogPC9wcmU+PC9wPlxuICAgKiBAc2luY2UgMC4zLjBcbiAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc3RhdHVzIHNvdXJjZS5cbiAgICogQHJldHVybiB7QVYuUXVlcnl9IFRoZSBxdWVyeSBvYmplY3QgZm9yIHN0YXR1cy5cbiAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gdGhlIGNvdW50XG4gICAqICAgICBjb21wbGV0ZXMuXG4gICAqL1xuICBBVi5TdGF0dXMuY291bnRVbnJlYWRTdGF0dXNlcyA9IGZ1bmN0aW9uKG93bmVyKXtcbiAgICBpZighQVYuVXNlci5jdXJyZW50KCkgJiYgb3duZXIgPT0gbnVsbCl7XG4gICAgICB0aHJvdyAnUGxlYXNlIHNpZ25pbiBhbiB1c2VyIG9yIHBhc3MgdGhlIG93bmVyIG9iamVjdElkLic7XG4gICAgfVxuICAgIG93bmVyID0gb3duZXIgfHwgQVYuVXNlci5jdXJyZW50KCk7XG4gICAgdmFyIG9wdGlvbnMgPSAhXy5pc1N0cmluZyhhcmd1bWVudHNbMV0pID8gYXJndW1lbnRzWzFdIDogYXJndW1lbnRzWzJdO1xuICAgIHZhciBpbmJveFR5cGUgPSAgIV8uaXNTdHJpbmcoYXJndW1lbnRzWzFdKSA/ICdkZWZhdWx0JyA6IGFyZ3VtZW50c1sxXTtcbiAgICB2YXIgcGFyYW1zID0ge307XG4gICAgcGFyYW1zLmluYm94VHlwZSA9IEFWLl9lbmNvZGUoaW5ib3hUeXBlKTtcbiAgICBwYXJhbXMub3duZXIgPSBBVi5fZW5jb2RlKG93bmVyKTtcbiAgICB2YXIgcmVxdWVzdCA9IEFWLl9yZXF1ZXN0KCdzdWJzY3JpYmUvc3RhdHVzZXMvY291bnQnLCBudWxsLCBudWxsLCAnR0VUJywgcGFyYW1zKTtcbiAgICByZXR1cm4gcmVxdWVzdC5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlIGEgc3RhdHVzIHF1ZXJ5IHRvIGZpbmQgc29tZW9uZSdzIHB1Ymxpc2hlZCBzdGF0dXNlcy5Gb3IgZXhhbXBsZTo8YnIvPlxuICAgKiA8cD48cHJlPlxuICAgKiAgIC8vRmluZCBjdXJyZW50IHVzZXIncyBwdWJsaXNoZWQgc3RhdHVzZXMuXG4gICAqICAgdmFyIHF1ZXJ5ID0gQVYuU3RhdHVzLnN0YXR1c1F1ZXJ5KEFWLlVzZXIuY3VycmVudCgpKTtcbiAgICogICBxdWVyeS5maW5kKCkudGhlbihmdW5jdGlvbihzdGF0dXNlcyl7XG4gICAqICAgICAgLy9wcm9jZXNzIHN0YXR1c2VzXG4gICAqICAgfSk7XG4gICAqIDwvcHJlPjwvcD5cbiAgICogQHNpbmNlIDAuMy4wXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHN0YXR1cyBzb3VyY2UuXG4gICAqIEByZXR1cm4ge0FWLlF1ZXJ5fSBUaGUgcXVlcnkgb2JqZWN0IGZvciBzdGF0dXMuXG4gICAqL1xuICBBVi5TdGF0dXMuc3RhdHVzUXVlcnkgPSBmdW5jdGlvbihzb3VyY2Upe1xuICAgIHZhciBxdWVyeSA9IG5ldyBBVi5RdWVyeSgnX1N0YXR1cycpO1xuICAgIGlmKHNvdXJjZSl7XG4gICAgICBxdWVyeS5lcXVhbFRvKCdzb3VyY2UnLCBzb3VyY2UpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnk7XG4gIH07XG5cbiAgIC8qKlxuICAgICogPHA+QVYuSW5ib3hRdWVyeSBkZWZpbmVzIGEgcXVlcnkgdGhhdCBpcyB1c2VkIHRvIGZldGNoIHNvbWVib2R5J3MgaW5ib3ggc3RhdHVzZXMuPC9wPlxuICAgICogQHNlZSBBVi5TdGF0dXMjaW5ib3hRdWVyeVxuICAgICogQGNsYXNzXG4gICAgKi9cbiAgIEFWLkluYm94UXVlcnkgPSBBVi5RdWVyeS5fZXh0ZW5kKC8qKiBAbGVuZHMgQVYuSW5ib3hRdWVyeS5wcm90b3R5cGUgKi97XG4gICAgIF9vYmplY3RDbGFzczogQVYuU3RhdHVzLFxuICAgICBfc2luY2VJZDogMCxcbiAgICAgX21heElkOiAgMCxcbiAgICAgX2luYm94VHlwZTogJ2RlZmF1bHQnLFxuICAgICBfb3duZXI6IG51bGwsXG4gICAgIF9uZXdPYmplY3Q6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gbmV3IEFWLlN0YXR1cygpO1xuICAgIH0sXG4gICAgX2NyZWF0ZVJlcXVlc3Q6IGZ1bmN0aW9uKHBhcmFtcyl7XG4gICAgICByZXR1cm4gQVYuX3JlcXVlc3QoXCJzdWJzY3JpYmUvc3RhdHVzZXNcIiwgbnVsbCwgbnVsbCwgXCJHRVRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zIHx8IHRoaXMudG9KU09OKCkpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG1lc3NhZ2VJZCBvZiByZXN1bHRzIHRvIHNraXAgYmVmb3JlIHJldHVybmluZyBhbnkgcmVzdWx0cy5cbiAgICAgKiBUaGlzIGlzIHVzZWZ1bCBmb3IgcGFnaW5hdGlvbi5cbiAgICAgKiBEZWZhdWx0IGlzIHplcm8uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gdGhlIG1lc2FnZSBpZC5cbiAgICAgKiBAcmV0dXJuIHtBVi5JbmJveFF1ZXJ5fSBSZXR1cm5zIHRoZSBxdWVyeSwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgc2luY2VJZDogZnVuY3Rpb24oaWQpe1xuICAgICAgdGhpcy5fc2luY2VJZCA9IGlkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXhpbWFsIG1lc3NhZ2VJZCBvZiByZXN1bHRz44CCXG4gICAgICogVGhpcyBpcyB1c2VmdWwgZm9yIHBhZ2luYXRpb24uXG4gICAgICogRGVmYXVsdCBpcyB6ZXJvIHRoYXQgaXMgbm8gbGltaXRpb24uXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG4gdGhlIG1lc2FnZSBpZC5cbiAgICAgKiBAcmV0dXJuIHtBVi5JbmJveFF1ZXJ5fSBSZXR1cm5zIHRoZSBxdWVyeSwgc28geW91IGNhbiBjaGFpbiB0aGlzIGNhbGwuXG4gICAgICovXG4gICAgbWF4SWQ6IGZ1bmN0aW9uKGlkKXtcbiAgICAgIHRoaXMuX21heElkID0gaWQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG93bmVyIG9mIHRoZSBxdWVyeWluZyBpbmJveC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3duZXIgVGhlIGluYm94IG93bmVyLlxuICAgICAqIEByZXR1cm4ge0FWLkluYm94UXVlcnl9IFJldHVybnMgdGhlIHF1ZXJ5LCBzbyB5b3UgY2FuIGNoYWluIHRoaXMgY2FsbC5cbiAgICAgKi9cbiAgICBvd25lcjogZnVuY3Rpb24ob3duZXIpe1xuICAgICAgdGhpcy5fb3duZXIgPSBvd25lcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcXVlcnlpbmcgaW5ib3ggdHlwZS5kZWZhdWx0IGlzICdkZWZhdWx0Jy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3duZXIgVGhlIGluYm94IHR5cGUuXG4gICAgICogQHJldHVybiB7QVYuSW5ib3hRdWVyeX0gUmV0dXJucyB0aGUgcXVlcnksIHNvIHlvdSBjYW4gY2hhaW4gdGhpcyBjYWxsLlxuICAgICAqL1xuICAgIGluYm94VHlwZTogZnVuY3Rpb24odHlwZSl7XG4gICAgICB0aGlzLl9pbmJveFR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICB0b0pTT046IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgcGFyYW1zID0gQVYuSW5ib3hRdWVyeS5fX3N1cGVyX18udG9KU09OLmNhbGwodGhpcyk7XG4gICAgICBwYXJhbXMub3duZXIgPSBBVi5fZW5jb2RlKHRoaXMuX293bmVyKTtcbiAgICAgIHBhcmFtcy5pbmJveFR5cGUgPSBBVi5fZW5jb2RlKHRoaXMuX2luYm94VHlwZSk7XG4gICAgICBwYXJhbXMuc2luY2VJZCA9IEFWLl9lbmNvZGUodGhpcy5fc2luY2VJZCk7XG4gICAgICBwYXJhbXMubWF4SWQgPSBBVi5fZW5jb2RlKHRoaXMuX21heElkKTtcbiAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgfVxuICAgfSk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIGluYm94IHN0YXR1cyBxdWVyeSB0byBmaW5kIHNvbWVvbmUncyBpbmJveCBzdGF0dXNlcy5Gb3IgZXhhbXBsZTo8YnIvPlxuICAgKiA8cD48cHJlPlxuICAgKiAgIC8vRmluZCBjdXJyZW50IHVzZXIncyBkZWZhdWx0IGluYm94IHN0YXR1c2VzLlxuICAgKiAgIHZhciBxdWVyeSA9IEFWLlN0YXR1cy5pbmJveFF1ZXJ5KEFWLlVzZXIuY3VycmVudCgpKTtcbiAgICogICAvL2ZpbmQgdGhlIHN0YXR1c2VzIGFmdGVyIHRoZSBsYXN0IG1lc3NhZ2UgaWRcbiAgICogICBxdWVyeS5zaW5jZUlkKGxhc3RNZXNzYWdlSWQpO1xuICAgKiAgIHF1ZXJ5LmZpbmQoKS50aGVuKGZ1bmN0aW9uKHN0YXR1c2VzKXtcbiAgICogICAgICAvL3Byb2Nlc3Mgc3RhdHVzZXNcbiAgICogICB9KTtcbiAgICogPC9wcmU+PC9wPlxuICAgKiBAc2luY2UgMC4zLjBcbiAgICogQHBhcmFtIHtPYmplY3R9IG93bmVyIFRoZSBpbmJveCdzIG93bmVyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpbmJveFR5cGUgVGhlIGluYm94IHR5cGUsJ2RlZmF1bHQnIGJ5IGRlZmF1bHQuXG4gICAqIEByZXR1cm4ge0FWLkluYm94UXVlcnl9IFRoZSBpbmJveCBxdWVyeSBvYmplY3QuXG4gICAqIEBzZWUgQVYuSW5ib3hRdWVyeVxuICAgKi9cbiAgQVYuU3RhdHVzLmluYm94UXVlcnkgPSBmdW5jdGlvbihvd25lciwgaW5ib3hUeXBlKXtcbiAgICB2YXIgcXVlcnkgPSBuZXcgQVYuSW5ib3hRdWVyeShBVi5TdGF0dXMpO1xuICAgIGlmKG93bmVyKXtcbiAgICAgIHF1ZXJ5Ll9vd25lciA9IG93bmVyO1xuICAgIH1cbiAgICBpZihpbmJveFR5cGUpe1xuICAgICAgcXVlcnkuX2luYm94VHlwZSA9IGluYm94VHlwZTtcbiAgICB9XG4gICAgcmV0dXJuIHF1ZXJ5O1xuICB9O1xuXG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi9zdGF0dXMuanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEFWKSB7XG4gIC8qKlxuICAgKiBAY2xhc3NcbiAgICpcbiAgICogPHA+QSBBVi5Vc2VyIG9iamVjdCBpcyBhIGxvY2FsIHJlcHJlc2VudGF0aW9uIG9mIGEgdXNlciBwZXJzaXN0ZWQgdG8gdGhlXG4gICAqIEFWIGNsb3VkLiBUaGlzIGNsYXNzIGlzIGEgc3ViY2xhc3Mgb2YgYSBBVi5PYmplY3QsIGFuZCByZXRhaW5zIHRoZVxuICAgKiBzYW1lIGZ1bmN0aW9uYWxpdHkgb2YgYSBBVi5PYmplY3QsIGJ1dCBhbHNvIGV4dGVuZHMgaXQgd2l0aCB2YXJpb3VzXG4gICAqIHVzZXIgc3BlY2lmaWMgbWV0aG9kcywgbGlrZSBhdXRoZW50aWNhdGlvbiwgc2lnbmluZyB1cCwgYW5kIHZhbGlkYXRpb24gb2ZcbiAgICogdW5pcXVlbmVzcy48L3A+XG4gICAqL1xuICBBVi5Vc2VyID0gQVYuT2JqZWN0LmV4dGVuZChcIl9Vc2VyXCIsIC8qKiBAbGVuZHMgQVYuVXNlci5wcm90b3R5cGUgKi8ge1xuICAgIC8vIEluc3RhbmNlIFZhcmlhYmxlc1xuICAgIF9pc0N1cnJlbnRVc2VyOiBmYWxzZSxcblxuXG4gICAgLy8gSW5zdGFuY2UgTWV0aG9kc1xuXG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgbWV0aG9kIHRvIGhhbmRsZSBzcGVjaWFsIGZpZWxkcyBpbiBhIF9Vc2VyIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIF9tZXJnZU1hZ2ljRmllbGRzOiBmdW5jdGlvbihhdHRycykge1xuICAgICAgaWYgKGF0dHJzLnNlc3Npb25Ub2tlbikge1xuICAgICAgICB0aGlzLl9zZXNzaW9uVG9rZW4gPSBhdHRycy5zZXNzaW9uVG9rZW47XG4gICAgICAgIGRlbGV0ZSBhdHRycy5zZXNzaW9uVG9rZW47XG4gICAgICB9XG4gICAgICBBVi5Vc2VyLl9fc3VwZXJfXy5fbWVyZ2VNYWdpY0ZpZWxkcy5jYWxsKHRoaXMsIGF0dHJzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBudWxsIHZhbHVlcyBmcm9tIGF1dGhEYXRhICh3aGljaCBleGlzdCB0ZW1wb3JhcmlseSBmb3JcbiAgICAgKiB1bmxpbmtpbmcpXG4gICAgICovXG4gICAgX2NsZWFudXBBdXRoRGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaXNDdXJyZW50KCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGF1dGhEYXRhID0gdGhpcy5nZXQoJ2F1dGhEYXRhJyk7XG4gICAgICBpZiAoIWF1dGhEYXRhKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIEFWLl9vYmplY3RFYWNoKHRoaXMuZ2V0KCdhdXRoRGF0YScpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIGlmICghYXV0aERhdGFba2V5XSkge1xuICAgICAgICAgIGRlbGV0ZSBhdXRoRGF0YVtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU3luY2hyb25pemVzIGF1dGhEYXRhIGZvciBhbGwgcHJvdmlkZXJzLlxuICAgICAqL1xuICAgIF9zeW5jaHJvbml6ZUFsbEF1dGhEYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhdXRoRGF0YSA9IHRoaXMuZ2V0KCdhdXRoRGF0YScpO1xuICAgICAgaWYgKCFhdXRoRGF0YSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIEFWLl9vYmplY3RFYWNoKHRoaXMuZ2V0KCdhdXRoRGF0YScpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgIHNlbGYuX3N5bmNocm9uaXplQXV0aERhdGEoa2V5KTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbml6ZXMgYXV0aCBkYXRhIGZvciBhIHByb3ZpZGVyIChlLmcuIHB1dHMgdGhlIGFjY2VzcyB0b2tlbiBpbiB0aGVcbiAgICAgKiByaWdodCBwbGFjZSB0byBiZSB1c2VkIGJ5IHRoZSBGYWNlYm9vayBTREspLlxuICAgICAqL1xuICAgIF9zeW5jaHJvbml6ZUF1dGhEYXRhOiBmdW5jdGlvbihwcm92aWRlcikge1xuICAgICAgaWYgKCF0aGlzLmlzQ3VycmVudCgpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBhdXRoVHlwZTtcbiAgICAgIGlmIChfLmlzU3RyaW5nKHByb3ZpZGVyKSkge1xuICAgICAgICBhdXRoVHlwZSA9IHByb3ZpZGVyO1xuICAgICAgICBwcm92aWRlciA9IEFWLlVzZXIuX2F1dGhQcm92aWRlcnNbYXV0aFR5cGVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXV0aFR5cGUgPSBwcm92aWRlci5nZXRBdXRoVHlwZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGF1dGhEYXRhID0gdGhpcy5nZXQoJ2F1dGhEYXRhJyk7XG4gICAgICBpZiAoIWF1dGhEYXRhIHx8ICFwcm92aWRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgc3VjY2VzcyA9IHByb3ZpZGVyLnJlc3RvcmVBdXRoZW50aWNhdGlvbihhdXRoRGF0YVthdXRoVHlwZV0pO1xuICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgIHRoaXMuX3VubGlua0Zyb20ocHJvdmlkZXIpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBfaGFuZGxlU2F2ZVJlc3VsdDogZnVuY3Rpb24obWFrZUN1cnJlbnQpIHtcbiAgICAgIC8vIENsZWFuIHVwIGFuZCBzeW5jaHJvbml6ZSB0aGUgYXV0aERhdGEgb2JqZWN0LCByZW1vdmluZyBhbnkgdW5zZXQgdmFsdWVzXG4gICAgICBpZiAobWFrZUN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5faXNDdXJyZW50VXNlciA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9jbGVhbnVwQXV0aERhdGEoKTtcbiAgICAgIHRoaXMuX3N5bmNocm9uaXplQWxsQXV0aERhdGEoKTtcbiAgICAgIC8vIERvbid0IGtlZXAgdGhlIHBhc3N3b3JkIGFyb3VuZC5cbiAgICAgIGRlbGV0ZSB0aGlzLl9zZXJ2ZXJEYXRhLnBhc3N3b3JkO1xuICAgICAgdGhpcy5fcmVidWlsZEVzdGltYXRlZERhdGFGb3JLZXkoXCJwYXNzd29yZFwiKTtcbiAgICAgIHRoaXMuX3JlZnJlc2hDYWNoZSgpO1xuICAgICAgaWYgKG1ha2VDdXJyZW50IHx8IHRoaXMuaXNDdXJyZW50KCkpIHtcbiAgICAgICAgLy8gU29tZSBvbGQgdmVyc2lvbiBvZiBsZWFuZW5naW5lLW5vZGUtc2RrIHdpbGwgb3ZlcndyaXRlXG4gICAgICAgIC8vIEFWLlVzZXIuX3NhdmVDdXJyZW50VXNlciB3aGljaCByZXR1cm5zIG5vIFByb21pc2UuXG4gICAgICAgIC8vIFNvIHdlIG5lZWQgYSBQcm9taXNlIHdyYXBwZXIuXG4gICAgICAgIHJldHVybiBBVi5Qcm9taXNlLmFzKEFWLlVzZXIuX3NhdmVDdXJyZW50VXNlcih0aGlzKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gQVYuUHJvbWlzZS5hcygpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbmxpa2UgaW4gdGhlIEFuZHJvaWQvaU9TIFNES3MsIGxvZ0luV2l0aCBpcyB1bm5lY2Vzc2FyeSwgc2luY2UgeW91IGNhblxuICAgICAqIGNhbGwgbGlua1dpdGggb24gdGhlIHVzZXIgKGV2ZW4gaWYgaXQgZG9lc24ndCBleGlzdCB5ZXQgb24gdGhlIHNlcnZlcikuXG4gICAgICovXG4gICAgX2xpbmtXaXRoOiBmdW5jdGlvbihwcm92aWRlciwgb3B0aW9ucykge1xuICAgICAgdmFyIGF1dGhUeXBlO1xuICAgICAgaWYgKF8uaXNTdHJpbmcocHJvdmlkZXIpKSB7XG4gICAgICAgIGF1dGhUeXBlID0gcHJvdmlkZXI7XG4gICAgICAgIHByb3ZpZGVyID0gQVYuVXNlci5fYXV0aFByb3ZpZGVyc1twcm92aWRlcl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdXRoVHlwZSA9IHByb3ZpZGVyLmdldEF1dGhUeXBlKCk7XG4gICAgICB9XG4gICAgICBpZiAoXy5oYXMob3B0aW9ucywgJ2F1dGhEYXRhJykpIHtcbiAgICAgICAgdmFyIGF1dGhEYXRhID0gdGhpcy5nZXQoJ2F1dGhEYXRhJykgfHwge307XG4gICAgICAgIGF1dGhEYXRhW2F1dGhUeXBlXSA9IG9wdGlvbnMuYXV0aERhdGE7XG4gICAgICAgIHRoaXMuc2V0KCdhdXRoRGF0YScsIGF1dGhEYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2F2ZSh7J2F1dGhEYXRhJzogYXV0aERhdGF9LCBmaWx0ZXJPdXRDYWxsYmFja3Mob3B0aW9ucykpXG4gICAgICAgICAgLnRoZW4oZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC5faGFuZGxlU2F2ZVJlc3VsdCh0cnVlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHByb21pc2UgPSBuZXcgQVYuUHJvbWlzZSgpO1xuICAgICAgICBwcm92aWRlci5hdXRoZW50aWNhdGUoe1xuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHByb3ZpZGVyLCByZXN1bHQpIHtcbiAgICAgICAgICAgIHNlbGYuX2xpbmtXaXRoKHByb3ZpZGVyLCB7XG4gICAgICAgICAgICAgIGF1dGhEYXRhOiByZXN1bHQsXG4gICAgICAgICAgICAgIHN1Y2Nlc3M6IG9wdGlvbnMuc3VjY2VzcyxcbiAgICAgICAgICAgICAgZXJyb3I6IG9wdGlvbnMuZXJyb3JcbiAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShzZWxmKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHByb3ZpZGVyLCBlcnJvcikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgb3B0aW9ucy5lcnJvcihzZWxmLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm9taXNlLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubGlua3MgYSB1c2VyIGZyb20gYSBzZXJ2aWNlLlxuICAgICAqL1xuICAgIF91bmxpbmtGcm9tOiBmdW5jdGlvbihwcm92aWRlciwgb3B0aW9ucykge1xuICAgICAgdmFyIGF1dGhUeXBlO1xuICAgICAgaWYgKF8uaXNTdHJpbmcocHJvdmlkZXIpKSB7XG4gICAgICAgIGF1dGhUeXBlID0gcHJvdmlkZXI7XG4gICAgICAgIHByb3ZpZGVyID0gQVYuVXNlci5fYXV0aFByb3ZpZGVyc1twcm92aWRlcl07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdXRoVHlwZSA9IHByb3ZpZGVyLmdldEF1dGhUeXBlKCk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3T3B0aW9ucyA9IF8uY2xvbmUob3B0aW9ucyk7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBuZXdPcHRpb25zLmF1dGhEYXRhID0gbnVsbDtcbiAgICAgIG5ld09wdGlvbnMuc3VjY2VzcyA9IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHNlbGYuX3N5bmNocm9uaXplQXV0aERhdGEocHJvdmlkZXIpO1xuICAgICAgICBpZiAob3B0aW9ucy5zdWNjZXNzKSB7XG4gICAgICAgICAgb3B0aW9ucy5zdWNjZXNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5fbGlua1dpdGgocHJvdmlkZXIsIG5ld09wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciBhIHVzZXIgaXMgbGlua2VkIHRvIGEgc2VydmljZS5cbiAgICAgKi9cbiAgICBfaXNMaW5rZWQ6IGZ1bmN0aW9uKHByb3ZpZGVyKSB7XG4gICAgICB2YXIgYXV0aFR5cGU7XG4gICAgICBpZiAoXy5pc1N0cmluZyhwcm92aWRlcikpIHtcbiAgICAgICAgYXV0aFR5cGUgPSBwcm92aWRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1dGhUeXBlID0gcHJvdmlkZXIuZ2V0QXV0aFR5cGUoKTtcbiAgICAgIH1cbiAgICAgIHZhciBhdXRoRGF0YSA9IHRoaXMuZ2V0KCdhdXRoRGF0YScpIHx8IHt9O1xuICAgICAgcmV0dXJuICEhYXV0aERhdGFbYXV0aFR5cGVdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZWF1dGhlbnRpY2F0ZXMgYWxsIHByb3ZpZGVycy5cbiAgICAgKi9cbiAgICBfbG9nT3V0V2l0aEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXV0aERhdGEgPSB0aGlzLmdldCgnYXV0aERhdGEnKTtcbiAgICAgIGlmICghYXV0aERhdGEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgQVYuX29iamVjdEVhY2godGhpcy5nZXQoJ2F1dGhEYXRhJyksIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgc2VsZi5fbG9nT3V0V2l0aChrZXkpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERlYXV0aGVudGljYXRlcyBhIHNpbmdsZSBwcm92aWRlciAoZS5nLiByZW1vdmluZyBhY2Nlc3MgdG9rZW5zIGZyb20gdGhlXG4gICAgICogRmFjZWJvb2sgU0RLKS5cbiAgICAgKi9cbiAgICBfbG9nT3V0V2l0aDogZnVuY3Rpb24ocHJvdmlkZXIpIHtcbiAgICAgIGlmICghdGhpcy5pc0N1cnJlbnQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoXy5pc1N0cmluZyhwcm92aWRlcikpIHtcbiAgICAgICAgcHJvdmlkZXIgPSBBVi5Vc2VyLl9hdXRoUHJvdmlkZXJzW3Byb3ZpZGVyXTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm92aWRlciAmJiBwcm92aWRlci5kZWF1dGhlbnRpY2F0ZSkge1xuICAgICAgICBwcm92aWRlci5kZWF1dGhlbnRpY2F0ZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaWducyB1cCBhIG5ldyB1c2VyLiBZb3Ugc2hvdWxkIGNhbGwgdGhpcyBpbnN0ZWFkIG9mIHNhdmUgZm9yXG4gICAgICogbmV3IEFWLlVzZXJzLiBUaGlzIHdpbGwgY3JlYXRlIGEgbmV3IEFWLlVzZXIgb24gdGhlIHNlcnZlciwgYW5kXG4gICAgICogYWxzbyBwZXJzaXN0IHRoZSBzZXNzaW9uIG9uIGRpc2sgc28gdGhhdCB5b3UgY2FuIGFjY2VzcyB0aGUgdXNlciB1c2luZ1xuICAgICAqIDxjb2RlPmN1cnJlbnQ8L2NvZGU+LlxuICAgICAqXG4gICAgICogPHA+QSB1c2VybmFtZSBhbmQgcGFzc3dvcmQgbXVzdCBiZSBzZXQgYmVmb3JlIGNhbGxpbmcgc2lnblVwLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPkNhbGxzIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIG9uIGNvbXBsZXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIEV4dHJhIGZpZWxkcyB0byBzZXQgb24gdGhlIG5ldyB1c2VyLCBvciBudWxsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gdGhlIHNpZ251cFxuICAgICAqICAgICBmaW5pc2hlcy5cbiAgICAgKiBAc2VlIEFWLlVzZXIuc2lnblVwXG4gICAgICovXG4gICAgc2lnblVwOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHZhciB1c2VybmFtZSA9IChhdHRycyAmJiBhdHRycy51c2VybmFtZSkgfHwgdGhpcy5nZXQoXCJ1c2VybmFtZVwiKTtcbiAgICAgIGlmICghdXNlcm5hbWUgfHwgKHVzZXJuYW1lID09PSBcIlwiKSkge1xuICAgICAgICBlcnJvciA9IG5ldyBBVi5FcnJvcihcbiAgICAgICAgICAgIEFWLkVycm9yLk9USEVSX0NBVVNFLFxuICAgICAgICAgICAgXCJDYW5ub3Qgc2lnbiB1cCB1c2VyIHdpdGggYW4gZW1wdHkgbmFtZS5cIik7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZXJyb3IpIHtcbiAgICAgICAgICBvcHRpb25zLmVycm9yKHRoaXMsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQVYuUHJvbWlzZS5lcnJvcihlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXNzd29yZCA9IChhdHRycyAmJiBhdHRycy5wYXNzd29yZCkgfHwgdGhpcy5nZXQoXCJwYXNzd29yZFwiKTtcbiAgICAgIGlmICghcGFzc3dvcmQgfHwgKHBhc3N3b3JkID09PSBcIlwiKSkge1xuICAgICAgICBlcnJvciA9IG5ldyBBVi5FcnJvcihcbiAgICAgICAgICAgIEFWLkVycm9yLk9USEVSX0NBVVNFLFxuICAgICAgICAgICAgXCJDYW5ub3Qgc2lnbiB1cCB1c2VyIHdpdGggYW4gZW1wdHkgcGFzc3dvcmQuXCIpO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVycm9yKSB7XG4gICAgICAgICAgb3B0aW9ucy5lcnJvcih0aGlzLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFWLlByb21pc2UuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zYXZlKGF0dHJzLCBmaWx0ZXJPdXRDYWxsYmFja3Mob3B0aW9ucykpLnRoZW4oZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgcmV0dXJuIG1vZGVsLl9oYW5kbGVTYXZlUmVzdWx0KHRydWUpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9KTtcbiAgICAgIH0pLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTaWducyB1cCBhIG5ldyB1c2VyIHdpdGggbW9iaWxlIHBob25lIGFuZCBzbXMgY29kZS5cbiAgICAgKiBZb3Ugc2hvdWxkIGNhbGwgdGhpcyBpbnN0ZWFkIG9mIHNhdmUgZm9yXG4gICAgICogbmV3IEFWLlVzZXJzLiBUaGlzIHdpbGwgY3JlYXRlIGEgbmV3IEFWLlVzZXIgb24gdGhlIHNlcnZlciwgYW5kXG4gICAgICogYWxzbyBwZXJzaXN0IHRoZSBzZXNzaW9uIG9uIGRpc2sgc28gdGhhdCB5b3UgY2FuIGFjY2VzcyB0aGUgdXNlciB1c2luZ1xuICAgICAqIDxjb2RlPmN1cnJlbnQ8L2NvZGU+LlxuICAgICAqXG4gICAgICogPHA+QSB1c2VybmFtZSBhbmQgcGFzc3dvcmQgbXVzdCBiZSBzZXQgYmVmb3JlIGNhbGxpbmcgc2lnblVwLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPkNhbGxzIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIG9uIGNvbXBsZXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIEV4dHJhIGZpZWxkcyB0byBzZXQgb24gdGhlIG5ldyB1c2VyLCBvciBudWxsLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdoZW4gdGhlIHNpZ251cFxuICAgICAqICAgICBmaW5pc2hlcy5cbiAgICAgKiBAc2VlIEFWLlVzZXIuc2lnblVwT3Jsb2dJbldpdGhNb2JpbGVQaG9uZVxuICAgICAqIEBzZWUgQVYuQ2xvdWQucmVxdWVzdFNtc0NvZGVcbiAgICAgKi9cbiAgICBzaWduVXBPcmxvZ0luV2l0aE1vYmlsZVBob25lOiBmdW5jdGlvbihhdHRycywgb3B0aW9ucykge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIHZhciBtb2JpbGVQaG9uZU51bWJlciA9IChhdHRycyAmJiBhdHRycy5tb2JpbGVQaG9uZU51bWJlcikgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0KFwibW9iaWxlUGhvbmVOdW1iZXJcIik7XG4gICAgICBpZiAoIW1vYmlsZVBob25lTnVtYmVyIHx8IChtb2JpbGVQaG9uZU51bWJlciA9PT0gXCJcIikpIHtcbiAgICAgICAgZXJyb3IgPSBuZXcgQVYuRXJyb3IoXG4gICAgICAgICAgICBBVi5FcnJvci5PVEhFUl9DQVVTRSxcbiAgICAgICAgICAgIFwiQ2Fubm90IHNpZ24gdXAgb3IgbG9naW4gdXNlciBieSBtb2JpbGVQaG9uZU51bWJlciBcIiArXG4gICAgICAgICAgICBcIndpdGggYW4gZW1wdHkgbW9iaWxlUGhvbmVOdW1iZXIuXCIpO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVycm9yKSB7XG4gICAgICAgICAgb3B0aW9ucy5lcnJvcih0aGlzLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFWLlByb21pc2UuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc21zQ29kZSA9IChhdHRycyAmJiBhdHRycy5zbXNDb2RlKSB8fCB0aGlzLmdldChcInNtc0NvZGVcIik7XG4gICAgICBpZiAoIXNtc0NvZGUgfHwgKHNtc0NvZGUgPT09IFwiXCIpKSB7XG4gICAgICAgIGVycm9yID0gbmV3IEFWLkVycm9yKFxuICAgICAgICAgICAgQVYuRXJyb3IuT1RIRVJfQ0FVU0UsXG4gICAgICAgICAgICAgXCJDYW5ub3Qgc2lnbiB1cCBvciBsb2dpbiB1c2VyIGJ5IG1vYmlsZVBob25lTnVtYmVyICBcIiArXG4gICAgICAgICAgICAgXCJ3aXRoIGFuIGVtcHR5IHNtc0NvZGUuXCIpO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmVycm9yKSB7XG4gICAgICAgICAgb3B0aW9ucy5lcnJvcih0aGlzLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEFWLlByb21pc2UuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3T3B0aW9ucyA9IGZpbHRlck91dENhbGxiYWNrcyhvcHRpb25zKTtcbiAgICAgIG5ld09wdGlvbnMuX21ha2VSZXF1ZXN0ID0gZnVuY3Rpb24ocm91dGUsIGNsYXNzTmFtZSwgaWQsIG1ldGhvZCwganNvbikge1xuICAgICAgICByZXR1cm4gQVYuX3JlcXVlc3QoJ3VzZXJzQnlNb2JpbGVQaG9uZScsIG51bGwsIG51bGwsIFwiUE9TVFwiLCBqc29uKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5zYXZlKGF0dHJzLCBuZXdPcHRpb25zKS50aGVuKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIGRlbGV0ZSBtb2RlbC5hdHRyaWJ1dGVzLnNtc0NvZGU7XG4gICAgICAgIGRlbGV0ZSBtb2RlbC5fc2VydmVyRGF0YS5zbXNDb2RlO1xuICAgICAgICByZXR1cm4gbW9kZWwuX2hhbmRsZVNhdmVSZXN1bHQodHJ1ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgIH0pO1xuICAgICAgfSkuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvZ3MgaW4gYSBBVi5Vc2VyLiBPbiBzdWNjZXNzLCB0aGlzIHNhdmVzIHRoZSBzZXNzaW9uIHRvIGxvY2FsU3RvcmFnZSxcbiAgICAgKiBzbyB5b3UgY2FuIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIgdXNpbmdcbiAgICAgKiA8Y29kZT5jdXJyZW50PC9jb2RlPi5cbiAgICAgKlxuICAgICAqIDxwPkEgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIG11c3QgYmUgc2V0IGJlZm9yZSBjYWxsaW5nIGxvZ0luLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPkNhbGxzIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIG9uIGNvbXBsZXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAc2VlIEFWLlVzZXIubG9nSW5cbiAgICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB0aGUgdXNlciB3aGVuXG4gICAgICogICAgIHRoZSBsb2dpbiBpcyBjb21wbGV0ZS5cbiAgICAgKi9cbiAgICBsb2dJbjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgdmFyIG1vZGVsID0gdGhpcztcbiAgICAgIHZhciByZXF1ZXN0ID0gQVYuX3JlcXVlc3QoXCJsb2dpblwiLCBudWxsLCBudWxsLCBcIkdFVFwiLCB0aGlzLnRvSlNPTigpKTtcbiAgICAgIHJldHVybiByZXF1ZXN0LnRoZW4oZnVuY3Rpb24ocmVzcCwgc3RhdHVzLCB4aHIpIHtcbiAgICAgICAgdmFyIHNlcnZlckF0dHJzID0gbW9kZWwucGFyc2UocmVzcCwgc3RhdHVzLCB4aHIpO1xuICAgICAgICBtb2RlbC5fZmluaXNoRmV0Y2goc2VydmVyQXR0cnMpO1xuICAgICAgICByZXR1cm4gbW9kZWwuX2hhbmRsZVNhdmVSZXN1bHQodHJ1ZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZighc2VydmVyQXR0cnMuc21zQ29kZSlcbiAgICAgICAgICAgIGRlbGV0ZSBtb2RlbC5hdHRyaWJ1dGVzWydzbXNDb2RlJ107XG4gICAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgICAgICB9KTtcbiAgICAgIH0pLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc2VlIEFWLk9iamVjdCNzYXZlXG4gICAgICovXG4gICAgc2F2ZTogZnVuY3Rpb24oYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgdmFyIGksIGF0dHJzLCBjdXJyZW50LCBvcHRpb25zLCBzYXZlZDtcbiAgICAgIGlmIChfLmlzT2JqZWN0KGFyZzEpIHx8IF8uaXNOdWxsKGFyZzEpIHx8IF8uaXNVbmRlZmluZWQoYXJnMSkpIHtcbiAgICAgICAgYXR0cnMgPSBhcmcxO1xuICAgICAgICBvcHRpb25zID0gYXJnMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJzID0ge307XG4gICAgICAgIGF0dHJzW2FyZzFdID0gYXJnMjtcbiAgICAgICAgb3B0aW9ucyA9IGFyZzM7XG4gICAgICB9XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAgICAgcmV0dXJuIEFWLk9iamVjdC5wcm90b3R5cGUuc2F2ZVxuICAgICAgICAuY2FsbCh0aGlzLCBhdHRycywgZmlsdGVyT3V0Q2FsbGJhY2tzKG9wdGlvbnMpKVxuICAgICAgICAudGhlbihmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgIHJldHVybiBtb2RlbC5faGFuZGxlU2F2ZVJlc3VsdChmYWxzZSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEZvbGxvdyBhIHVzZXJcbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAcGFyYW0ge30gdGFyZ2V0IFRoZSB0YXJnZXQgdXNlciBvciB1c2VyJ3Mgb2JqZWN0SWQgdG8gZm9sbG93LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIEJhY2tib25lLWxpa2Ugb3B0aW9ucyBvYmplY3Qgd2l0aFxuICAgICAqICAgICBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIGludm9rZWQgb25jZSB0aGUgaXRlcmF0aW9uXG4gICAgICogICAgIGhhcyBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICBmb2xsb3c6IGZ1bmN0aW9uKHRhcmdldCwgb3B0aW9ucyl7XG4gICAgICBpZighdGhpcy5pZCl7XG4gICAgICAgICAgdGhyb3cgXCJQbGVhc2Ugc2lnbmluLlwiO1xuICAgICAgfVxuICAgICAgaWYoIXRhcmdldCl7XG4gICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhcmdldCB1c2VyLlwiO1xuICAgICAgfVxuICAgICAgdmFyIHVzZXJPYmplY3RJZCA9IF8uaXNTdHJpbmcodGFyZ2V0KSA/IHRhcmdldDogdGFyZ2V0LmlkO1xuICAgICAgaWYoIXVzZXJPYmplY3RJZCl7XG4gICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHRhcmdldCB1c2VyLlwiO1xuICAgICAgfVxuICAgICAgdmFyIHJvdXRlID0gJ3VzZXJzLycgKyB0aGlzLmlkICsgJy9mcmllbmRzaGlwLycgKyB1c2VyT2JqZWN0SWQ7XG4gICAgICB2YXIgcmVxdWVzdCA9IEFWLl9yZXF1ZXN0KHJvdXRlLCBudWxsLCBudWxsLCAnUE9TVCcsIG51bGwpO1xuICAgICAgcmV0dXJuIHJlcXVlc3QuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVuZm9sbG93IGEgdXNlci5cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAcGFyYW0ge30gdGFyZ2V0IFRoZSB0YXJnZXQgdXNlciBvciB1c2VyJ3Mgb2JqZWN0SWQgdG8gdW5mb2xsb3cuXG4gICAgICogQHBhcmFtIG9wdGlvbnMge09iamVjdH0gQW4gb3B0aW9uYWwgQmFja2JvbmUtbGlrZSBvcHRpb25zIG9iamVjdCB3aXRoXG4gICAgICogICAgIHN1Y2Nlc3MgYW5kIGVycm9yIGNhbGxiYWNrcyB0aGF0IHdpbGwgYmUgaW52b2tlZCBvbmNlIHRoZSBpdGVyYXRpb25cbiAgICAgKiAgICAgaGFzIGZpbmlzaGVkLlxuICAgICAqL1xuICAgIHVuZm9sbG93OiBmdW5jdGlvbih0YXJnZXQsIG9wdGlvbnMpe1xuICAgICAgaWYoIXRoaXMuaWQpe1xuICAgICAgICAgIHRocm93IFwiUGxlYXNlIHNpZ25pbi5cIjtcbiAgICAgIH1cbiAgICAgIGlmKCF0YXJnZXQpe1xuICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0YXJnZXQgdXNlci5cIjtcbiAgICAgIH1cbiAgICAgIHZhciB1c2VyT2JqZWN0SWQgPSBfLmlzU3RyaW5nKHRhcmdldCkgPyB0YXJnZXQ6IHRhcmdldC5pZDtcbiAgICAgIGlmKCF1c2VyT2JqZWN0SWQpe1xuICAgICAgICAgIHRocm93IFwiSW52YWxpZCB0YXJnZXQgdXNlci5cIjtcbiAgICAgIH1cbiAgICAgIHZhciByb3V0ZSA9ICd1c2Vycy8nICsgdGhpcy5pZCArICcvZnJpZW5kc2hpcC8nICsgdXNlck9iamVjdElkO1xuICAgICAgdmFyIHJlcXVlc3QgPSBBVi5fcmVxdWVzdChyb3V0ZSwgbnVsbCwgbnVsbCwgJ0RFTEVURScsIG51bGwpO1xuICAgICAgcmV0dXJuIHJlcXVlc3QuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqQ3JlYXRlIGEgZm9sbG93ZXIgcXVlcnkgdG8gcXVlcnkgdGhlIHVzZXIncyBmb2xsb3dlcnMuXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQHNlZSBBVi5Vc2VyI2ZvbGxvd2VyUXVlcnlcbiAgICAgKi9cbiAgICBmb2xsb3dlclF1ZXJ5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFWLlVzZXIuZm9sbG93ZXJRdWVyeSh0aGlzLmlkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpDcmVhdGUgYSBmb2xsb3dlZSBxdWVyeSB0byBxdWVyeSB0aGUgdXNlcidzIGZvbGxvd2Vlcy5cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKiBAc2VlIEFWLlVzZXIjZm9sbG93ZWVRdWVyeVxuICAgICAqL1xuICAgIGZvbGxvd2VlUXVlcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQVYuVXNlci5mb2xsb3dlZVF1ZXJ5KHRoaXMuaWQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc2VlIEFWLk9iamVjdCNmZXRjaFxuICAgICAqL1xuICAgIGZldGNoOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICByZXR1cm4gQVYuT2JqZWN0LnByb3RvdHlwZS5mZXRjaC5jYWxsKHRoaXMsIGZpbHRlck91dENhbGxiYWNrcyhvcHRpb25zKSlcbiAgICAgICAgLnRoZW4oZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICByZXR1cm4gbW9kZWwuX2hhbmRsZVNhdmVSZXN1bHQoZmFsc2UpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgdXNlcidzIG5ldyBwYXNzd29yZCBzYWZlbHkgYmFzZWQgb24gb2xkIHBhc3N3b3JkLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvbGRQYXNzd29yZCwgdGhlIG9sZCBwYXNzd29yZC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmV3UGFzc3dvcmQsIHRoZSBuZXcgcGFzc3dvcmQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IEFuIG9wdGlvbmFsIEJhY2tib25lLWxpa2Ugb3B0aW9ucyBvYmplY3Qgd2l0aFxuICAgICAqICAgICBzdWNjZXNzIGFuZCBlcnJvciBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIGludm9rZWQgb25jZSB0aGUgaXRlcmF0aW9uXG4gICAgICogICAgIGhhcyBmaW5pc2hlZC5cbiAgICAgKi9cbiAgICB1cGRhdGVQYXNzd29yZDogZnVuY3Rpb24ob2xkUGFzc3dvcmQsIG5ld1Bhc3N3b3JkLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcm91dGUgPSAndXNlcnMvJyArIHRoaXMuaWQgKyAnL3VwZGF0ZVBhc3N3b3JkJztcbiAgICAgIHZhciBwYXJhbXMgPSB7XG4gICAgICAgIG9sZF9wYXNzd29yZDogb2xkUGFzc3dvcmQsXG4gICAgICAgIG5ld19wYXNzd29yZDogbmV3UGFzc3dvcmRcbiAgICAgIH07XG4gICAgICB2YXIgcmVxdWVzdCA9IEFWLl9yZXF1ZXN0KHJvdXRlLCBudWxsLCBudWxsLCAnUFVUJywgcGFyYW1zKTtcbiAgICAgIHJldHVybiByZXF1ZXN0Ll90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMsIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgPGNvZGU+Y3VycmVudDwvY29kZT4gd291bGQgcmV0dXJuIHRoaXMgdXNlci5cbiAgICAgKiBAc2VlIEFWLlVzZXIjY3VycmVudFxuICAgICAqL1xuICAgIGlzQ3VycmVudDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNDdXJyZW50VXNlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBnZXQoXCJ1c2VybmFtZVwiKS5cbiAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICogQHNlZSBBVi5PYmplY3QjZ2V0XG4gICAgICovXG4gICAgZ2V0VXNlcm5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwidXNlcm5hbWVcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZ2V0KFwibW9iaWxlUGhvbmVOdW1iZXJcIikuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBzZWUgQVYuT2JqZWN0I2dldFxuICAgICAqL1xuICAgIGdldE1vYmlsZVBob25lTnVtYmVyOiBmdW5jdGlvbigpe1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwibW9iaWxlUGhvbmVOdW1iZXJcIik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbGxzIHNldChcIm1vYmlsZVBob25lTnVtYmVyXCIsIHBob25lTnVtYmVyLCBvcHRpb25zKSBhbmQgcmV0dXJucyB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2JpbGVQaG9uZU51bWJlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKiBAc2VlIEFWLk9iamVjdC5zZXRcbiAgICAgKi9cbiAgICBzZXRNb2JpbGVQaG9uZU51bWJlcjogZnVuY3Rpb24ocGhvbmUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChcIm1vYmlsZVBob25lTnVtYmVyXCIsIHBob25lLCBvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2FsbHMgc2V0KFwidXNlcm5hbWVcIiwgdXNlcm5hbWUsIG9wdGlvbnMpIGFuZCByZXR1cm5zIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufVxuICAgICAqIEBzZWUgQVYuT2JqZWN0LnNldFxuICAgICAqL1xuICAgIHNldFVzZXJuYW1lOiBmdW5jdGlvbih1c2VybmFtZSwgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0KFwidXNlcm5hbWVcIiwgdXNlcm5hbWUsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBzZXQoXCJwYXNzd29yZFwiLCBwYXNzd29yZCwgb3B0aW9ucykgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBBVi5PYmplY3Quc2V0XG4gICAgICovXG4gICAgc2V0UGFzc3dvcmQ6IGZ1bmN0aW9uKHBhc3N3b3JkLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoXCJwYXNzd29yZFwiLCBwYXNzd29yZCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgZ2V0KFwiZW1haWxcIikuXG4gICAgICogQHJldHVybiB7U3RyaW5nfVxuICAgICAqIEBzZWUgQVYuT2JqZWN0I2dldFxuICAgICAqL1xuICAgIGdldEVtYWlsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldChcImVtYWlsXCIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYWxscyBzZXQoXCJlbWFpbFwiLCBlbWFpbCwgb3B0aW9ucykgYW5kIHJldHVybnMgdGhlIHJlc3VsdC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW1haWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59XG4gICAgICogQHNlZSBBVi5PYmplY3Quc2V0XG4gICAgICovXG4gICAgc2V0RW1haWw6IGZ1bmN0aW9uKGVtYWlsLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gdGhpcy5zZXQoXCJlbWFpbFwiLCBlbWFpbCwgb3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoaXMgdXNlciBpcyB0aGUgY3VycmVudCB1c2VyIGFuZCBoYXMgYmVlbiBhdXRoZW50aWNhdGVkLlxuICAgICAqIEByZXR1cm4gKEJvb2xlYW4pIHdoZXRoZXIgdGhpcyB1c2VyIGlzIHRoZSBjdXJyZW50IHVzZXIgYW5kIGlzIGxvZ2dlZCBpbi5cbiAgICAgKi9cbiAgICBhdXRoZW50aWNhdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuX3Nlc3Npb25Ub2tlbiAmJlxuICAgICAgICAgIChBVi5Vc2VyLmN1cnJlbnQoKSAmJiBBVi5Vc2VyLmN1cnJlbnQoKS5pZCA9PT0gdGhpcy5pZCk7XG4gICAgfVxuXG4gIH0sIC8qKiBAbGVuZHMgQVYuVXNlciAqLyB7XG4gICAgLy8gQ2xhc3MgVmFyaWFibGVzXG5cbiAgICAvLyBUaGUgY3VycmVudGx5IGxvZ2dlZC1pbiB1c2VyLlxuICAgIF9jdXJyZW50VXNlcjogbnVsbCxcblxuICAgIC8vIFdoZXRoZXIgY3VycmVudFVzZXIgaXMga25vd24gdG8gbWF0Y2ggdGhlIHNlcmlhbGl6ZWQgdmVyc2lvbiBvbiBkaXNrLlxuICAgIC8vIFRoaXMgaXMgdXNlZnVsIGZvciBzYXZpbmcgYSBsb2NhbHN0b3JhZ2UgY2hlY2sgaWYgeW91IHRyeSB0byBsb2FkXG4gICAgLy8gX2N1cnJlbnRVc2VyIGZyZXF1ZW50bHkgd2hpbGUgdGhlcmUgaXMgbm9uZSBzdG9yZWQuXG4gICAgX2N1cnJlbnRVc2VyTWF0Y2hlc0Rpc2s6IGZhbHNlLFxuXG4gICAgLy8gVGhlIGxvY2FsU3RvcmFnZSBrZXkgc3VmZml4IHRoYXQgdGhlIGN1cnJlbnQgdXNlciBpcyBzdG9yZWQgdW5kZXIuXG4gICAgX0NVUlJFTlRfVVNFUl9LRVk6IFwiY3VycmVudFVzZXJcIixcblxuICAgIC8vIFRoZSBtYXBwaW5nIG9mIGF1dGggcHJvdmlkZXIgbmFtZXMgdG8gYWN0dWFsIHByb3ZpZGVyc1xuICAgIF9hdXRoUHJvdmlkZXJzOiB7fSxcblxuXG4gICAgLy8gQ2xhc3MgTWV0aG9kc1xuXG4gICAgLyoqXG4gICAgICogU2lnbnMgdXAgYSBuZXcgdXNlciB3aXRoIGEgdXNlcm5hbWUgKG9yIGVtYWlsKSBhbmQgcGFzc3dvcmQuXG4gICAgICogVGhpcyB3aWxsIGNyZWF0ZSBhIG5ldyBBVi5Vc2VyIG9uIHRoZSBzZXJ2ZXIsIGFuZCBhbHNvIHBlcnNpc3QgdGhlXG4gICAgICogc2Vzc2lvbiBpbiBsb2NhbFN0b3JhZ2Ugc28gdGhhdCB5b3UgY2FuIGFjY2VzcyB0aGUgdXNlciB1c2luZ1xuICAgICAqIHtAbGluayAjY3VycmVudH0uXG4gICAgICpcbiAgICAgKiA8cD5DYWxscyBvcHRpb25zLnN1Y2Nlc3Mgb3Igb3B0aW9ucy5lcnJvciBvbiBjb21wbGV0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZSBUaGUgdXNlcm5hbWUgKG9yIGVtYWlsKSB0byBzaWduIHVwIHdpdGguXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBzaWduIHVwIHdpdGguXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJzIEV4dHJhIGZpZWxkcyB0byBzZXQgb24gdGhlIG5ldyB1c2VyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIHVzZXIgd2hlblxuICAgICAqICAgICB0aGUgc2lnbnVwIGNvbXBsZXRlcy5cbiAgICAgKiBAc2VlIEFWLlVzZXIjc2lnblVwXG4gICAgICovXG4gICAgc2lnblVwOiBmdW5jdGlvbih1c2VybmFtZSwgcGFzc3dvcmQsIGF0dHJzLCBvcHRpb25zKSB7XG4gICAgICBhdHRycyA9IGF0dHJzIHx8IHt9O1xuICAgICAgYXR0cnMudXNlcm5hbWUgPSB1c2VybmFtZTtcbiAgICAgIGF0dHJzLnBhc3N3b3JkID0gcGFzc3dvcmQ7XG4gICAgICB2YXIgdXNlciA9IEFWLk9iamVjdC5fY3JlYXRlKFwiX1VzZXJcIik7XG4gICAgICByZXR1cm4gdXNlci5zaWduVXAoYXR0cnMsIG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGluIGEgdXNlciB3aXRoIGEgdXNlcm5hbWUgKG9yIGVtYWlsKSBhbmQgcGFzc3dvcmQuIE9uIHN1Y2Nlc3MsIHRoaXNcbiAgICAgKiBzYXZlcyB0aGUgc2Vzc2lvbiB0byBkaXNrLCBzbyB5b3UgY2FuIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluXG4gICAgICogdXNlciB1c2luZyA8Y29kZT5jdXJyZW50PC9jb2RlPi5cbiAgICAgKlxuICAgICAqIDxwPkNhbGxzIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIG9uIGNvbXBsZXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lIFRoZSB1c2VybmFtZSAob3IgZW1haWwpIHRvIGxvZyBpbiB3aXRoLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gbG9nIGluIHdpdGguXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB0aGUgdXNlciB3aGVuXG4gICAgICogICAgIHRoZSBsb2dpbiBjb21wbGV0ZXMuXG4gICAgICogQHNlZSBBVi5Vc2VyI2xvZ0luXG4gICAgICovXG4gICAgbG9nSW46IGZ1bmN0aW9uKHVzZXJuYW1lLCBwYXNzd29yZCwgb3B0aW9ucykge1xuICAgICAgdmFyIHVzZXIgPSBBVi5PYmplY3QuX2NyZWF0ZShcIl9Vc2VyXCIpO1xuICAgICAgdXNlci5fZmluaXNoRmV0Y2goeyB1c2VybmFtZTogdXNlcm5hbWUsIHBhc3N3b3JkOiBwYXNzd29yZCB9KTtcbiAgICAgIHJldHVybiB1c2VyLmxvZ0luKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGluIGEgdXNlciB3aXRoIGEgc2Vzc2lvbiB0b2tlbi4gT24gc3VjY2VzcywgdGhpcyBzYXZlcyB0aGUgc2Vzc2lvblxuICAgICAqIHRvIGRpc2ssIHNvIHlvdSBjYW4gcmV0cmlldmUgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlciB1c2luZ1xuICAgICAqIDxjb2RlPmN1cnJlbnQ8L2NvZGU+LlxuICAgICAqXG4gICAgICogPHA+Q2FsbHMgb3B0aW9ucy5zdWNjZXNzIG9yIG9wdGlvbnMuZXJyb3Igb24gY29tcGxldGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2Vzc2lvblRva2VuIFRoZSBzZXNzaW9uVG9rZW4gdG8gbG9nIGluIHdpdGguXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB0aGUgdXNlciB3aGVuXG4gICAgICogICAgIHRoZSBsb2dpbiBjb21wbGV0ZXMuXG4gICAgICovXG4gICAgYmVjb21lOiBmdW5jdGlvbihzZXNzaW9uVG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICB2YXIgdXNlciA9IEFWLk9iamVjdC5fY3JlYXRlKFwiX1VzZXJcIik7XG4gICAgICByZXR1cm4gQVYuX3JlcXVlc3QoXG4gICAgICAgICAgXCJ1c2Vyc1wiLFxuICAgICAgICAgIFwibWVcIixcbiAgICAgICAgICBudWxsLFxuICAgICAgICAgIFwiR0VUXCIsXG4gICAgICAgICAge1xuICAgICAgICAgICAgdXNlTWFzdGVyS2V5OiBvcHRpb25zLnVzZU1hc3RlcktleSxcbiAgICAgICAgICAgIHNlc3Npb25fdG9rZW46IHNlc3Npb25Ub2tlblxuICAgICAgICAgIH1cbiAgICAgICkudGhlbihmdW5jdGlvbihyZXNwLCBzdGF0dXMsIHhocikge1xuICAgICAgICAgIHZhciBzZXJ2ZXJBdHRycyA9IHVzZXIucGFyc2UocmVzcCwgc3RhdHVzLCB4aHIpO1xuICAgICAgICAgIHVzZXIuX2ZpbmlzaEZldGNoKHNlcnZlckF0dHJzKTtcbiAgICAgICAgICByZXR1cm4gdXNlci5faGFuZGxlU2F2ZVJlc3VsdCh0cnVlKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXI7XG4gICAgICAgICAgfSk7XG4gICAgICB9KS5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zLCB1c2VyKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9ncyBpbiBhIHVzZXIgd2l0aCBhIG1vYmlsZSBwaG9uZSBudW1iZXIgYW5kIHNtcyBjb2RlIHNlbnQgYnlcbiAgICAgKiBBVi5Vc2VyLnJlcXVlc3RMb2dpblNtc0NvZGUuT24gc3VjY2VzcywgdGhpc1xuICAgICAqIHNhdmVzIHRoZSBzZXNzaW9uIHRvIGRpc2ssIHNvIHlvdSBjYW4gcmV0cmlldmUgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW5cbiAgICAgKiB1c2VyIHVzaW5nIDxjb2RlPmN1cnJlbnQ8L2NvZGU+LlxuICAgICAqXG4gICAgICogPHA+Q2FsbHMgb3B0aW9ucy5zdWNjZXNzIG9yIG9wdGlvbnMuZXJyb3Igb24gY29tcGxldGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9iaWxlUGhvbmUgVGhlIHVzZXIncyBtb2JpbGVQaG9uZU51bWJlclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzbXNDb2RlIFRoZSBzbXMgY29kZSBzZW50IGJ5IEFWLlVzZXIucmVxdWVzdExvZ2luU21zQ29kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIHVzZXIgd2hlblxuICAgICAqICAgICB0aGUgbG9naW4gY29tcGxldGVzLlxuICAgICAqIEBzZWUgQVYuVXNlciNsb2dJblxuICAgICAqL1xuICAgbG9nSW5XaXRoTW9iaWxlUGhvbmVTbXNDb2RlOiBmdW5jdGlvbihtb2JpbGVQaG9uZSwgc21zQ29kZSwgb3B0aW9ucyl7XG4gICAgICB2YXIgdXNlciA9IEFWLk9iamVjdC5fY3JlYXRlKFwiX1VzZXJcIik7XG4gICAgICB1c2VyLl9maW5pc2hGZXRjaCh7IG1vYmlsZVBob25lTnVtYmVyOiBtb2JpbGVQaG9uZSwgc21zQ29kZTogc21zQ29kZSB9KTtcbiAgICAgIHJldHVybiB1c2VyLmxvZ0luKG9wdGlvbnMpO1xuICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNpZ24gdXAgb3IgbG9ncyBpbiBhIHVzZXIgd2l0aCBhIG1vYmlsZVBob25lTnVtYmVyIGFuZCBzbXNDb2RlLlxuICAgICAqIE9uIHN1Y2Nlc3MsIHRoaXMgc2F2ZXMgdGhlIHNlc3Npb24gdG8gZGlzaywgc28geW91IGNhbiByZXRyaWV2ZSB0aGUgY3VycmVudGx5XG4gICAgICogbG9nZ2VkIGluIHVzZXIgdXNpbmcgPGNvZGU+Y3VycmVudDwvY29kZT4uXG4gICAgICpcbiAgICAgKiA8cD5DYWxscyBvcHRpb25zLnN1Y2Nlc3Mgb3Igb3B0aW9ucy5lcnJvciBvbiBjb21wbGV0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2JpbGVQaG9uZU51bWJlciBUaGUgdXNlcidzIG1vYmlsZVBob25lTnVtYmVyLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzbXNDb2RlIFRoZSBzbXMgY29kZSBzZW50IGJ5IEFWLkNsb3VkLnJlcXVlc3RTbXNDb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF0dHJpYnV0ZXMgIFRoZSB1c2VyJ3Mgb3RoZXIgYXR0cmlidXRlcyBzdWNoIGFzIHVzZXJuYW1lIGV0Yy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIHRoZSB1c2VyIHdoZW5cbiAgICAgKiAgICAgdGhlIGxvZ2luIGNvbXBsZXRlcy5cbiAgICAgKiBAc2VlIEFWLlVzZXIjc2lnblVwT3Jsb2dJbldpdGhNb2JpbGVQaG9uZVxuICAgICAqIEBzZWUgQVYuQ2xvdWQucmVxdWVzdFNtc0NvZGVcbiAgICAgKi9cbiAgICBzaWduVXBPcmxvZ0luV2l0aE1vYmlsZVBob25lOiBmdW5jdGlvbihtb2JpbGVQaG9uZU51bWJlciwgc21zQ29kZSwgYXR0cnMsIG9wdGlvbnMpIHtcbiAgICAgIGF0dHJzID0gYXR0cnMgfHwge307XG4gICAgICBhdHRycy5tb2JpbGVQaG9uZU51bWJlciA9IG1vYmlsZVBob25lTnVtYmVyO1xuICAgICAgYXR0cnMuc21zQ29kZSA9IHNtc0NvZGU7XG4gICAgICB2YXIgdXNlciA9IEFWLk9iamVjdC5fY3JlYXRlKFwiX1VzZXJcIik7XG4gICAgICByZXR1cm4gdXNlci5zaWduVXBPcmxvZ0luV2l0aE1vYmlsZVBob25lKGF0dHJzLCBvcHRpb25zKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGluIGEgdXNlciB3aXRoIGEgbW9iaWxlIHBob25lIG51bWJlciBhbmQgcGFzc3dvcmQuIE9uIHN1Y2Nlc3MsIHRoaXNcbiAgICAgKiBzYXZlcyB0aGUgc2Vzc2lvbiB0byBkaXNrLCBzbyB5b3UgY2FuIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluXG4gICAgICogdXNlciB1c2luZyA8Y29kZT5jdXJyZW50PC9jb2RlPi5cbiAgICAgKlxuICAgICAqIDxwPkNhbGxzIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIG9uIGNvbXBsZXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vYmlsZVBob25lIFRoZSB1c2VyJ3MgbW9iaWxlUGhvbmVOdW1iZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGxvZyBpbiB3aXRoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIHVzZXIgd2hlblxuICAgICAqICAgICB0aGUgbG9naW4gY29tcGxldGVzLlxuICAgICAqIEBzZWUgQVYuVXNlciNsb2dJblxuICAgICAqL1xuICAgbG9nSW5XaXRoTW9iaWxlUGhvbmU6IGZ1bmN0aW9uKG1vYmlsZVBob25lLCBwYXNzd29yZCwgb3B0aW9ucyl7XG4gICAgICB2YXIgdXNlciA9IEFWLk9iamVjdC5fY3JlYXRlKFwiX1VzZXJcIik7XG4gICAgICB1c2VyLl9maW5pc2hGZXRjaCh7IG1vYmlsZVBob25lTnVtYmVyOiBtb2JpbGVQaG9uZSwgcGFzc3dvcmQ6IHBhc3N3b3JkIH0pO1xuICAgICAgcmV0dXJuIHVzZXIubG9nSW4ob3B0aW9ucyk7XG4gICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9ncyBvdXQgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gdXNlciBzZXNzaW9uLiBUaGlzIHdpbGwgcmVtb3ZlIHRoZVxuICAgICAqIHNlc3Npb24gZnJvbSBkaXNrLCBsb2cgb3V0IG9mIGxpbmtlZCBzZXJ2aWNlcywgYW5kIGZ1dHVyZSBjYWxscyB0b1xuICAgICAqIDxjb2RlPmN1cnJlbnQ8L2NvZGU+IHdpbGwgcmV0dXJuIDxjb2RlPm51bGw8L2NvZGU+LlxuICAgICAqL1xuICAgIGxvZ091dDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoQVYuVXNlci5fY3VycmVudFVzZXIgIT09IG51bGwpIHtcbiAgICAgICAgQVYuVXNlci5fY3VycmVudFVzZXIuX2xvZ091dFdpdGhBbGwoKTtcbiAgICAgICAgQVYuVXNlci5fY3VycmVudFVzZXIuX2lzQ3VycmVudFVzZXIgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIEFWLlVzZXIuX2N1cnJlbnRVc2VyTWF0Y2hlc0Rpc2sgPSB0cnVlO1xuICAgICAgQVYuVXNlci5fY3VycmVudFVzZXIgPSBudWxsO1xuICAgICAgcmV0dXJuIEFWLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtQXN5bmMoXG4gICAgICAgICAgQVYuX2dldEFWUGF0aChBVi5Vc2VyLl9DVVJSRU5UX1VTRVJfS0VZKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqQ3JlYXRlIGEgZm9sbG93ZXIgcXVlcnkgZm9yIHNwZWNpYWwgdXNlciB0byBxdWVyeSB0aGUgdXNlcidzIGZvbGxvd2Vycy5cbiAgICAgKiBAcGFyYW0gdXNlck9iamVjdElkIHtTdHJpbmd9IFRoZSB1c2VyIG9iamVjdCBpZC5cbiAgICAgKiBAc2luY2UgMC4zLjBcbiAgICAgKi9cbiAgICBmb2xsb3dlclF1ZXJ5OiBmdW5jdGlvbih1c2VyT2JqZWN0SWQpIHtcbiAgICAgICAgaWYoIXVzZXJPYmplY3RJZCB8fCAhXy5pc1N0cmluZyh1c2VyT2JqZWN0SWQpKSB7XG4gICAgICAgICAgdGhyb3cgXCJJbnZhbGlkIHVzZXIgb2JqZWN0IGlkLlwiO1xuICAgICAgICB9XG4gICAgICAgIHZhciBxdWVyeSA9IG5ldyBBVi5GcmllbmRTaGlwUXVlcnkoJ19Gb2xsb3dlcicpO1xuICAgICAgICBxdWVyeS5fZnJpZW5kc2hpcFRhZyA9J2ZvbGxvd2VyJztcbiAgICAgICAgcXVlcnkuZXF1YWxUbygndXNlcicsIEFWLk9iamVjdC5jcmVhdGVXaXRob3V0RGF0YSgnX1VzZXInLCB1c2VyT2JqZWN0SWQpKTtcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKkNyZWF0ZSBhIGZvbGxvd2VlIHF1ZXJ5IGZvciBzcGVjaWFsIHVzZXIgdG8gcXVlcnkgdGhlIHVzZXIncyBmb2xsb3dlZXMuXG4gICAgICogQHBhcmFtIHVzZXJPYmplY3RJZCB7U3RyaW5nfSBUaGUgdXNlciBvYmplY3QgaWQuXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICovXG4gICAgZm9sbG93ZWVRdWVyeTogZnVuY3Rpb24odXNlck9iamVjdElkKSB7XG4gICAgICAgIGlmKCF1c2VyT2JqZWN0SWQgfHwgIV8uaXNTdHJpbmcodXNlck9iamVjdElkKSkge1xuICAgICAgICAgIHRocm93IFwiSW52YWxpZCB1c2VyIG9iamVjdCBpZC5cIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcXVlcnkgPSBuZXcgQVYuRnJpZW5kU2hpcFF1ZXJ5KCdfRm9sbG93ZWUnKTtcbiAgICAgICAgcXVlcnkuX2ZyaWVuZHNoaXBUYWcgPSdmb2xsb3dlZSc7XG4gICAgICAgIHF1ZXJ5LmVxdWFsVG8oJ3VzZXInLCBBVi5PYmplY3QuY3JlYXRlV2l0aG91dERhdGEoJ19Vc2VyJywgdXNlck9iamVjdElkKSk7XG4gICAgICAgIHJldHVybiBxdWVyeTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYSBwYXNzd29yZCByZXNldCBlbWFpbCB0byBiZSBzZW50IHRvIHRoZSBzcGVjaWZpZWQgZW1haWwgYWRkcmVzc1xuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciBhY2NvdW50LiBUaGlzIGVtYWlsIGFsbG93cyB0aGUgdXNlciB0byBzZWN1cmVseVxuICAgICAqIHJlc2V0IHRoZWlyIHBhc3N3b3JkIG9uIHRoZSBBViBzaXRlLlxuICAgICAqXG4gICAgICogPHA+Q2FsbHMgb3B0aW9ucy5zdWNjZXNzIG9yIG9wdGlvbnMuZXJyb3Igb24gY29tcGxldGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW1haWwgVGhlIGVtYWlsIGFkZHJlc3MgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyIHRoYXRcbiAgICAgKiAgICAgZm9yZ290IHRoZWlyIHBhc3N3b3JkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICovXG4gICAgcmVxdWVzdFBhc3N3b3JkUmVzZXQ6IGZ1bmN0aW9uKGVtYWlsLCBvcHRpb25zKSB7XG4gICAgICB2YXIganNvbiA9IHsgZW1haWw6IGVtYWlsIH07XG4gICAgICB2YXIgcmVxdWVzdCA9IEFWLl9yZXF1ZXN0KFwicmVxdWVzdFBhc3N3b3JkUmVzZXRcIiwgbnVsbCwgbnVsbCwgXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24pO1xuICAgICAgcmV0dXJuIHJlcXVlc3QuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGEgdmVyaWZ5IGVtYWlsIHRvIGJlIHNlbnQgdG8gdGhlIHNwZWNpZmllZCBlbWFpbCBhZGRyZXNzXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyIGFjY291bnQuIFRoaXMgZW1haWwgYWxsb3dzIHRoZSB1c2VyIHRvIHNlY3VyZWx5XG4gICAgICogdmVyaWZ5IHRoZWlyIGVtYWlsIGFkZHJlc3Mgb24gdGhlIEFWIHNpdGUuXG4gICAgICpcbiAgICAgKiA8cD5DYWxscyBvcHRpb25zLnN1Y2Nlc3Mgb3Igb3B0aW9ucy5lcnJvciBvbiBjb21wbGV0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbWFpbCBUaGUgZW1haWwgYWRkcmVzcyBhc3NvY2lhdGVkIHdpdGggdGhlIHVzZXIgdGhhdFxuICAgICAqICAgICBkb2Vzbid0IHZlcmlmeSB0aGVpciBlbWFpbCBhZGRyZXNzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICovXG4gICAgcmVxdWVzdEVtYWlsVmVyaWZ5OiBmdW5jdGlvbihlbWFpbCwgb3B0aW9ucykge1xuICAgICAgdmFyIGpzb24gPSB7IGVtYWlsOiBlbWFpbCB9O1xuICAgICAgdmFyIHJlcXVlc3QgPSBBVi5fcmVxdWVzdChcInJlcXVlc3RFbWFpbFZlcmlmeVwiLCBudWxsLCBudWxsLCBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbik7XG4gICAgICByZXR1cm4gcmVxdWVzdC5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zKTtcbiAgICB9LFxuXG4gICAvKipcbiAgICAqIEBEZXByZWNhdGVkIHR5cG8gZXJyb3IsIHBsZWFzZSB1c2UgcmVxdWVzdEVtYWlsVmVyaWZ5XG4gICAgKi9cbiAgICByZXF1ZXN0RW1haWxWZXJmaXk6IGZ1bmN0aW9uKGVtYWlsLCBvcHRpb25zKSB7XG4gICAgICB2YXIganNvbiA9IHsgZW1haWw6IGVtYWlsIH07XG4gICAgICB2YXIgcmVxdWVzdCA9IEFWLl9yZXF1ZXN0KFwicmVxdWVzdEVtYWlsVmVyaWZ5XCIsIG51bGwsIG51bGwsIFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uKTtcbiAgICAgIHJldHVybiByZXF1ZXN0Ll90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBhIHZlcmlmeSBzbXMgY29kZSB0byBiZSBzZW50IHRvIHRoZSBzcGVjaWZpZWQgbW9iaWxlIHBob25lXG4gICAgICogbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciBhY2NvdW50LiBUaGlzIHNtcyBjb2RlIGFsbG93cyB0aGUgdXNlciB0b1xuICAgICAqIHZlcmlmeSB0aGVpciBtb2JpbGUgcGhvbmUgbnVtYmVyIGJ5IGNhbGxpbmcgQVYuVXNlci52ZXJpZnlNb2JpbGVQaG9uZVxuICAgICAqXG4gICAgICogPHA+Q2FsbHMgb3B0aW9ucy5zdWNjZXNzIG9yIG9wdGlvbnMuZXJyb3Igb24gY29tcGxldGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbW9iaWxlUGhvbmUgVGhlIG1vYmlsZSBwaG9uZSBudW1iZXIgIGFzc29jaWF0ZWQgd2l0aCB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgIHVzZXIgdGhhdCBkb2Vzbid0IHZlcmlmeSB0aGVpciBtb2JpbGUgcGhvbmUgbnVtYmVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICovXG4gICAgcmVxdWVzdE1vYmlsZVBob25lVmVyaWZ5OiBmdW5jdGlvbihtb2JpbGVQaG9uZSwgb3B0aW9ucyl7XG4gICAgICB2YXIganNvbiA9IHsgbW9iaWxlUGhvbmVOdW1iZXI6IG1vYmlsZVBob25lIH07XG4gICAgICB2YXIgcmVxdWVzdCA9IEFWLl9yZXF1ZXN0KFwicmVxdWVzdE1vYmlsZVBob25lVmVyaWZ5XCIsIG51bGwsIG51bGwsIFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uKTtcbiAgICAgIHJldHVybiByZXF1ZXN0Ll90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGEgcmVzZXQgcGFzc3dvcmQgc21zIGNvZGUgdG8gYmUgc2VudCB0byB0aGUgc3BlY2lmaWVkIG1vYmlsZSBwaG9uZVxuICAgICAqIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIHVzZXIgYWNjb3VudC4gVGhpcyBzbXMgY29kZSBhbGxvd3MgdGhlIHVzZXIgdG9cbiAgICAgKiByZXNldCB0aGVpciBhY2NvdW50J3MgcGFzc3dvcmQgYnkgY2FsbGluZyBBVi5Vc2VyLnJlc2V0UGFzc3dvcmRCeVNtc0NvZGVcbiAgICAgKlxuICAgICAqIDxwPkNhbGxzIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIG9uIGNvbXBsZXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vYmlsZVBob25lIFRoZSBtb2JpbGUgcGhvbmUgbnVtYmVyICBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogICAgICAgICAgICAgICAgICB1c2VyIHRoYXQgZG9lc24ndCB2ZXJpZnkgdGhlaXIgbW9iaWxlIHBob25lIG51bWJlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqL1xuICAgIHJlcXVlc3RQYXNzd29yZFJlc2V0QnlTbXNDb2RlOiBmdW5jdGlvbihtb2JpbGVQaG9uZSwgb3B0aW9ucyl7XG4gICAgICB2YXIganNvbiA9IHsgbW9iaWxlUGhvbmVOdW1iZXI6IG1vYmlsZVBob25lIH07XG4gICAgICB2YXIgcmVxdWVzdCA9IEFWLl9yZXF1ZXN0KFwicmVxdWVzdFBhc3N3b3JkUmVzZXRCeVNtc0NvZGVcIiwgbnVsbCwgbnVsbCwgXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24pO1xuICAgICAgcmV0dXJuIHJlcXVlc3QuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgY2FsbCB0byByZXNldCB1c2VyJ3MgYWNjb3VudCBwYXNzd29yZCBieSBzbXMgY29kZSBhbmQgbmV3IHBhc3N3b3JkLlxuICAgICogVGhlIHNtcyBjb2RlIGlzIHNlbnQgYnkgQVYuVXNlci5yZXF1ZXN0UGFzc3dvcmRSZXNldEJ5U21zQ29kZS5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gY29kZSBUaGUgc21zIGNvZGUgc2VudCBieSBBVi5Vc2VyLkNsb3VkLnJlcXVlc3RTbXNDb2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhc3N3b3JkIFRoZSBuZXcgcGFzc3dvcmQuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdFxuICAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCB0aGUgcmVzdWx0XG4gICAgICogb2YgdGhlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHJlc2V0UGFzc3dvcmRCeVNtc0NvZGU6IGZ1bmN0aW9uKGNvZGUsIHBhc3N3b3JkLCBvcHRpb25zKXtcbiAgICAgIHZhciBqc29uID0geyBwYXNzd29yZDogcGFzc3dvcmR9O1xuICAgICAgdmFyIHJlcXVlc3QgPSBBVi5fcmVxdWVzdChcInJlc2V0UGFzc3dvcmRCeVNtc0NvZGVcIiwgbnVsbCwgY29kZSwgXCJQVVRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbik7XG4gICAgICByZXR1cm4gcmVxdWVzdC5fdGhlblJ1bkNhbGxiYWNrcyhvcHRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTWFrZXMgYSBjYWxsIHRvIHZlcmlmeSBzbXMgY29kZSB0aGF0IHNlbnQgYnkgQVYuVXNlci5DbG91ZC5yZXF1ZXN0U21zQ29kZVxuICAgICAqIElmIHZlcmlmeSBzdWNjZXNzZnVsbHksdGhlIHVzZXIgbW9iaWxlUGhvbmVWZXJpZmllZCBhdHRyaWJ1dGUgd2lsbCBiZSB0cnVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlIFRoZSBzbXMgY29kZSBzZW50IGJ5IEFWLlVzZXIuQ2xvdWQucmVxdWVzdFNtc0NvZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgKiBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICovXG4gICAgdmVyaWZ5TW9iaWxlUGhvbmU6IGZ1bmN0aW9uKGNvZGUsIG9wdGlvbnMpe1xuICAgICAgdmFyIHJlcXVlc3QgPSBBVi5fcmVxdWVzdChcInZlcmlmeU1vYmlsZVBob25lXCIsIG51bGwsIGNvZGUsIFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBudWxsKTtcbiAgICAgIHJldHVybiByZXF1ZXN0Ll90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBhIGxvZ0luIHNtcyBjb2RlIHRvIGJlIHNlbnQgdG8gdGhlIHNwZWNpZmllZCBtb2JpbGUgcGhvbmVcbiAgICAgKiBudW1iZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyIGFjY291bnQuIFRoaXMgc21zIGNvZGUgYWxsb3dzIHRoZSB1c2VyIHRvXG4gICAgICogbG9naW4gYnkgQVYuVXNlci5sb2dJbldpdGhNb2JpbGVQaG9uZVNtc0NvZGUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiA8cD5DYWxscyBvcHRpb25zLnN1Y2Nlc3Mgb3Igb3B0aW9ucy5lcnJvciBvbiBjb21wbGV0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2JpbGVQaG9uZSBUaGUgbW9iaWxlIHBob25lIG51bWJlciAgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqICAgICAgICAgICB1c2VyIHRoYXQgd2FudCB0byBsb2dpbiBieSBBVi5Vc2VyLmxvZ0luV2l0aE1vYmlsZVBob25lU21zQ29kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICovXG4gICAgcmVxdWVzdExvZ2luU21zQ29kZTogZnVuY3Rpb24obW9iaWxlUGhvbmUsIG9wdGlvbnMpe1xuICAgICAgdmFyIGpzb24gPSB7IG1vYmlsZVBob25lTnVtYmVyOiBtb2JpbGVQaG9uZSB9O1xuICAgICAgdmFyIHJlcXVlc3QgPSBBVi5fcmVxdWVzdChcInJlcXVlc3RMb2dpblNtc0NvZGVcIiwgbnVsbCwgbnVsbCwgXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzb24pO1xuICAgICAgcmV0dXJuIHJlcXVlc3QuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiBBVlVzZXIgd2l0aCBhIHZhbGlkIHNlc3Npb24sXG4gICAgICogZWl0aGVyIGZyb20gbWVtb3J5IG9yIGxvY2FsU3RvcmFnZSwgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IHJlc29sdmVkIHdpdGggdGhlIGN1cnJlbnRseSBsb2dnZWQgaW4gQVYuVXNlci5cbiAgICAgKi9cbiAgICBjdXJyZW50QXN5bmM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKEFWLlVzZXIuX2N1cnJlbnRVc2VyKSB7XG4gICAgICAgIHJldHVybiBBVi5Qcm9taXNlLmFzKEFWLlVzZXIuX2N1cnJlbnRVc2VyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKEFWLlVzZXIuX2N1cnJlbnRVc2VyTWF0Y2hlc0Rpc2spIHtcblxuICAgICAgICByZXR1cm4gQVYuUHJvbWlzZS5hcyhBVi5Vc2VyLl9jdXJyZW50VXNlcik7XG4gICAgICB9XG5cblxuICAgICAgcmV0dXJuIEFWLmxvY2FsU3RvcmFnZS5nZXRJdGVtQXN5bmMoXG4gICAgICAgIEFWLl9nZXRBVlBhdGgoQVYuVXNlci5fQ1VSUkVOVF9VU0VSX0tFWSlcbiAgICAgICkudGhlbihmdW5jdGlvbih1c2VyRGF0YSkge1xuICAgICAgICBpZiAoIXVzZXJEYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb2FkIHRoZSB1c2VyIGZyb20gbG9jYWwgc3RvcmFnZS5cbiAgICAgICAgQVYuVXNlci5fY3VycmVudFVzZXJNYXRjaGVzRGlzayA9IHRydWU7XG5cbiAgICAgICAgQVYuVXNlci5fY3VycmVudFVzZXIgPSBBVi5PYmplY3QuX2NyZWF0ZShcIl9Vc2VyXCIpO1xuICAgICAgICBBVi5Vc2VyLl9jdXJyZW50VXNlci5faXNDdXJyZW50VXNlciA9IHRydWU7XG5cbiAgICAgICAgdmFyIGpzb24gPSBKU09OLnBhcnNlKHVzZXJEYXRhKTtcbiAgICAgICAgQVYuVXNlci5fY3VycmVudFVzZXIuaWQgPSBqc29uLl9pZDtcbiAgICAgICAgZGVsZXRlIGpzb24uX2lkO1xuICAgICAgICBBVi5Vc2VyLl9jdXJyZW50VXNlci5fc2Vzc2lvblRva2VuID0ganNvbi5fc2Vzc2lvblRva2VuO1xuICAgICAgICBkZWxldGUganNvbi5fc2Vzc2lvblRva2VuO1xuICAgICAgICBBVi5Vc2VyLl9jdXJyZW50VXNlci5fZmluaXNoRmV0Y2goanNvbik7XG4gICAgICAgIC8vQVYuVXNlci5fY3VycmVudFVzZXIuc2V0KGpzb24pO1xuXG4gICAgICAgIEFWLlVzZXIuX2N1cnJlbnRVc2VyLl9zeW5jaHJvbml6ZUFsbEF1dGhEYXRhKCk7XG4gICAgICAgIEFWLlVzZXIuX2N1cnJlbnRVc2VyLl9yZWZyZXNoQ2FjaGUoKTtcbiAgICAgICAgQVYuVXNlci5fY3VycmVudFVzZXIuX29wU2V0UXVldWUgPSBbe31dO1xuICAgICAgICByZXR1cm4gQVYuVXNlci5fY3VycmVudFVzZXI7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIEFWVXNlciB3aXRoIGEgdmFsaWQgc2Vzc2lvbixcbiAgICAgKiBlaXRoZXIgZnJvbSBtZW1vcnkgb3IgbG9jYWxTdG9yYWdlLCBpZiBuZWNlc3NhcnkuXG4gICAgICogQHJldHVybiB7QVYuT2JqZWN0fSBUaGUgY3VycmVudGx5IGxvZ2dlZCBpbiBBVi5Vc2VyLlxuICAgICAqL1xuICAgIGN1cnJlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKEFWLlVzZXIuX2N1cnJlbnRVc2VyKSB7XG4gICAgICAgIHJldHVybiBBVi5Vc2VyLl9jdXJyZW50VXNlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKEFWLlVzZXIuX2N1cnJlbnRVc2VyTWF0Y2hlc0Rpc2spIHtcblxuICAgICAgICByZXR1cm4gQVYuVXNlci5fY3VycmVudFVzZXI7XG4gICAgICB9XG5cbiAgICAgIC8vIExvYWQgdGhlIHVzZXIgZnJvbSBsb2NhbCBzdG9yYWdlLlxuICAgICAgQVYuVXNlci5fY3VycmVudFVzZXJNYXRjaGVzRGlzayA9IHRydWU7XG5cbiAgICAgIHZhciB1c2VyRGF0YSA9IEFWLmxvY2FsU3RvcmFnZS5nZXRJdGVtKEFWLl9nZXRBVlBhdGgoXG4gICAgICAgICAgQVYuVXNlci5fQ1VSUkVOVF9VU0VSX0tFWSkpO1xuICAgICAgaWYgKCF1c2VyRGF0YSkge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgQVYuVXNlci5fY3VycmVudFVzZXIgPSBBVi5PYmplY3QuX2NyZWF0ZShcIl9Vc2VyXCIpO1xuICAgICAgQVYuVXNlci5fY3VycmVudFVzZXIuX2lzQ3VycmVudFVzZXIgPSB0cnVlO1xuXG4gICAgICB2YXIganNvbiA9IEpTT04ucGFyc2UodXNlckRhdGEpO1xuICAgICAgQVYuVXNlci5fY3VycmVudFVzZXIuaWQgPSBqc29uLl9pZDtcbiAgICAgIGRlbGV0ZSBqc29uLl9pZDtcbiAgICAgIEFWLlVzZXIuX2N1cnJlbnRVc2VyLl9zZXNzaW9uVG9rZW4gPSBqc29uLl9zZXNzaW9uVG9rZW47XG4gICAgICBkZWxldGUganNvbi5fc2Vzc2lvblRva2VuO1xuICAgICAgQVYuVXNlci5fY3VycmVudFVzZXIuX2ZpbmlzaEZldGNoKGpzb24pO1xuICAgICAgLy9BVi5Vc2VyLl9jdXJyZW50VXNlci5zZXQoanNvbik7XG5cbiAgICAgIEFWLlVzZXIuX2N1cnJlbnRVc2VyLl9zeW5jaHJvbml6ZUFsbEF1dGhEYXRhKCk7XG4gICAgICBBVi5Vc2VyLl9jdXJyZW50VXNlci5fcmVmcmVzaENhY2hlKCk7XG4gICAgICBBVi5Vc2VyLl9jdXJyZW50VXNlci5fb3BTZXRRdWV1ZSA9IFt7fV07XG4gICAgICByZXR1cm4gQVYuVXNlci5fY3VycmVudFVzZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBlcnNpc3RzIGEgdXNlciBhcyBjdXJyZW50VXNlciB0byBsb2NhbFN0b3JhZ2UsIGFuZCBpbnRvIHRoZSBzaW5nbGV0b24uXG4gICAgICovXG4gICAgX3NhdmVDdXJyZW50VXNlcjogZnVuY3Rpb24odXNlcikge1xuICAgICAgdmFyIHByb21pc2U7XG4gICAgICBpZiAoQVYuVXNlci5fY3VycmVudFVzZXIgIT09IHVzZXIpIHtcbiAgICAgICAgcHJvbWlzZSA9IEFWLlVzZXIubG9nT3V0KCk7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHJvbWlzZSA9IEFWLlByb21pc2UuYXMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwcm9taXNlLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgIHVzZXIuX2lzQ3VycmVudFVzZXIgPSB0cnVlO1xuICAgICAgICBBVi5Vc2VyLl9jdXJyZW50VXNlciA9IHVzZXI7XG5cbiAgICAgICAgdmFyIGpzb24gPSB1c2VyLnRvSlNPTigpO1xuICAgICAgICBqc29uLl9pZCA9IHVzZXIuaWQ7XG4gICAgICAgIGpzb24uX3Nlc3Npb25Ub2tlbiA9IHVzZXIuX3Nlc3Npb25Ub2tlbjtcbiAgICAgICAgcmV0dXJuIEFWLmxvY2FsU3RvcmFnZS5zZXRJdGVtQXN5bmMoXG4gICAgICAgICAgQVYuX2dldEFWUGF0aChBVi5Vc2VyLl9DVVJSRU5UX1VTRVJfS0VZKSxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShqc29uKVxuICAgICAgICApLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgQVYuVXNlci5fY3VycmVudFVzZXJNYXRjaGVzRGlzayA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9yZWdpc3RlckF1dGhlbnRpY2F0aW9uUHJvdmlkZXI6IGZ1bmN0aW9uKHByb3ZpZGVyKSB7XG4gICAgICBBVi5Vc2VyLl9hdXRoUHJvdmlkZXJzW3Byb3ZpZGVyLmdldEF1dGhUeXBlKCldID0gcHJvdmlkZXI7XG4gICAgICAvLyBTeW5jaHJvbml6ZSB0aGUgY3VycmVudCB1c2VyIHdpdGggdGhlIGF1dGggcHJvdmlkZXIuXG4gICAgICBpZiAoQVYuVXNlci5jdXJyZW50KCkpIHtcbiAgICAgICAgQVYuVXNlci5jdXJyZW50KCkuX3N5bmNocm9uaXplQXV0aERhdGEocHJvdmlkZXIuZ2V0QXV0aFR5cGUoKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIF9sb2dJbldpdGg6IGZ1bmN0aW9uKHByb3ZpZGVyLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdXNlciA9IEFWLk9iamVjdC5fY3JlYXRlKFwiX1VzZXJcIik7XG4gICAgICByZXR1cm4gdXNlci5fbGlua1dpdGgocHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH1cblxuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlck91dENhbGxiYWNrcyhvcHRpb25zKSB7XG4gIHZhciBuZXdPcHRpb25zID0gXy5jbG9uZShvcHRpb25zKSB8fCB7fTtcbiAgZGVsZXRlIG5ld09wdGlvbnMuc3VjY2VzcztcbiAgZGVsZXRlIG5ld09wdGlvbnMuZXJyb3I7XG4gIHJldHVybiBuZXdPcHRpb25zO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi91c2VyLmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ3VuZGVyc2NvcmUnKTtcblxuLypnbG9iYWwgXzogZmFsc2UsICQ6IGZhbHNlLCBsb2NhbFN0b3JhZ2U6IGZhbHNlLCBwcm9jZXNzOiB0cnVlLFxuICBYTUxIdHRwUmVxdWVzdDogZmFsc2UsIFhEb21haW5SZXF1ZXN0OiBmYWxzZSwgZXhwb3J0czogZmFsc2UsXG4gIHJlcXVpcmU6IGZhbHNlICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEFWKSB7XG4gIC8qKlxuICAgKiBDb250YWlucyBhbGwgQVYgQVBJIGNsYXNzZXMgYW5kIGZ1bmN0aW9ucy5cbiAgICogQG5hbWUgQVZcbiAgICogQG5hbWVzcGFjZVxuICAgKlxuICAgKiBDb250YWlucyBhbGwgQVYgQVBJIGNsYXNzZXMgYW5kIGZ1bmN0aW9ucy5cbiAgICovXG5cbiAgLy8gSWYgalF1ZXJ5IG9yIFplcHRvIGhhcyBiZWVuIGluY2x1ZGVkLCBncmFiIGEgcmVmZXJlbmNlIHRvIGl0LlxuICBpZiAodHlwZW9mKCQpICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgQVYuJCA9ICQ7XG4gIH1cblxuICAvLyBIZWxwZXJzXG4gIC8vIC0tLS0tLS1cblxuICAvLyBTaGFyZWQgZW1wdHkgY29uc3RydWN0b3IgZnVuY3Rpb24gdG8gYWlkIGluIHByb3RvdHlwZS1jaGFpbiBjcmVhdGlvbi5cbiAgdmFyIEVtcHR5Q29uc3RydWN0b3IgPSBmdW5jdGlvbigpIHt9O1xuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvcnJlY3RseSBzZXQgdXAgdGhlIHByb3RvdHlwZSBjaGFpbiwgZm9yIHN1YmNsYXNzZXMuXG4gIC8vIFNpbWlsYXIgdG8gYGdvb2cuaW5oZXJpdHNgLCBidXQgdXNlcyBhIGhhc2ggb2YgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kXG4gIC8vIGNsYXNzIHByb3BlcnRpZXMgdG8gYmUgZXh0ZW5kZWQuXG4gIHZhciBpbmhlcml0cyA9IGZ1bmN0aW9uKHBhcmVudCwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICB2YXIgY2hpbGQ7XG5cbiAgICAvLyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBuZXcgc3ViY2xhc3MgaXMgZWl0aGVyIGRlZmluZWQgYnkgeW91XG4gICAgLy8gKHRoZSBcImNvbnN0cnVjdG9yXCIgcHJvcGVydHkgaW4geW91ciBgZXh0ZW5kYCBkZWZpbml0aW9uKSwgb3IgZGVmYXVsdGVkXG4gICAgLy8gYnkgdXMgdG8gc2ltcGx5IGNhbGwgdGhlIHBhcmVudCdzIGNvbnN0cnVjdG9yLlxuICAgIGlmIChwcm90b1Byb3BzICYmIHByb3RvUHJvcHMuaGFzT3duUHJvcGVydHkoJ2NvbnN0cnVjdG9yJykpIHtcbiAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEBpZ25vcmUgKi9cbiAgICAgIGNoaWxkID0gZnVuY3Rpb24oKXsgcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XG4gICAgfVxuXG4gICAgLy8gSW5oZXJpdCBjbGFzcyAoc3RhdGljKSBwcm9wZXJ0aWVzIGZyb20gcGFyZW50LlxuICAgIEFWLl8uZXh0ZW5kKGNoaWxkLCBwYXJlbnQpO1xuXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcbiAgICAvLyBgcGFyZW50YCdzIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgIEVtcHR5Q29uc3RydWN0b3IucHJvdG90eXBlID0gcGFyZW50LnByb3RvdHlwZTtcbiAgICBjaGlsZC5wcm90b3R5cGUgPSBuZXcgRW1wdHlDb25zdHJ1Y3RvcigpO1xuXG4gICAgLy8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXG4gICAgLy8gaWYgc3VwcGxpZWQuXG4gICAgaWYgKHByb3RvUHJvcHMpIHtcbiAgICAgIEFWLl8uZXh0ZW5kKGNoaWxkLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG4gICAgaWYgKHN0YXRpY1Byb3BzKSB7XG4gICAgICBBVi5fLmV4dGVuZChjaGlsZCwgc3RhdGljUHJvcHMpO1xuICAgIH1cblxuICAgIC8vIENvcnJlY3RseSBzZXQgY2hpbGQncyBgcHJvdG90eXBlLmNvbnN0cnVjdG9yYC5cbiAgICBjaGlsZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjaGlsZDtcblxuICAgIC8vIFNldCBhIGNvbnZlbmllbmNlIHByb3BlcnR5IGluIGNhc2UgdGhlIHBhcmVudCdzIHByb3RvdHlwZSBpc1xuICAgIC8vIG5lZWRlZCBsYXRlci5cbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xuXG4gICAgcmV0dXJuIGNoaWxkO1xuICB9O1xuXG4gIC8vIFNldCB0aGUgc2VydmVyIGZvciBBViB0byB0YWxrIHRvLlxuICBBVi5zZXJ2ZXJVUkwgPSBcImh0dHBzOi8vYXBpLmxlYW5jbG91ZC5jblwiO1xuXG4gIC8vIENoZWNrIHdoZXRoZXIgd2UgYXJlIHJ1bm5pbmcgaW4gTm9kZS5qcy5cbiAgaWYgKHR5cGVvZihwcm9jZXNzKSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgcHJvY2Vzcy52ZXJzaW9ucyAmJlxuICAgICAgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlKSB7XG4gICAgQVYuX2lzTm9kZSA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCB0aGlzIG1ldGhvZCBmaXJzdCB0byBzZXQgdXAgeW91ciBhdXRoZW50aWNhdGlvbiB0b2tlbnMgZm9yIEFWLlxuICAgKiBZb3UgY2FuIGdldCB5b3VyIGtleXMgZnJvbSB0aGUgRGF0YSBCcm93c2VyIG9uIGF2b3NjbG91ZC5jb20uXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBsaWNhdGlvbklkIFlvdXIgQVYgQXBwbGljYXRpb24gSUQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhcHBsaWNhdGlvbktleSBZb3VyIEFWIEphdmFTY3JpcHQgS2V5LlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWFzdGVyS2V5IChvcHRpb25hbCkgWW91ciBBVk9TQ2xvdWQgTWFzdGVyIEtleS4gKE5vZGUuanMgb25seSEpLlxuICAgKi9cbiAgQVYuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKGFwcGxpY2F0aW9uSWQsIGFwcGxpY2F0aW9uS2V5LCBtYXN0ZXJLZXkpIHtcbiAgICBpZiAobWFzdGVyS2V5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBVi5pbml0aWFsaXplKCkgd2FzIHBhc3NlZCBhIE1hc3RlciBLZXksIHdoaWNoIGlzIG9ubHkgXCIgK1xuICAgICAgICBcImFsbG93ZWQgZnJvbSB3aXRoaW4gTm9kZS5qcy5cIik7XG4gICAgfVxuICAgIEFWLl9pbml0aWFsaXplKGFwcGxpY2F0aW9uSWQsIGFwcGxpY2F0aW9uS2V5LG1hc3RlcktleSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGwgdGhpcyBtZXRob2QgZmlyc3QgdG8gc2V0IHVwIGF1dGhlbnRpY2F0aW9uIHRva2VucyBmb3IgQVYuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGZvciBBVidzIG93biBwcml2YXRlIHVzZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFwcGxpY2F0aW9uSWQgWW91ciBBViBBcHBsaWNhdGlvbiBJRC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGFwcGxpY2F0aW9uS2V5IFlvdXIgQVYgQXBwbGljYXRpb24gS2V5XG4gICAqL1xuICAgQVYuX2luaXRpYWxpemUgPSBmdW5jdGlvbihhcHBsaWNhdGlvbklkLCBhcHBsaWNhdGlvbktleSwgbWFzdGVyS2V5KSB7XG4gICAgaWYgKEFWLmFwcGxpY2F0aW9uSWQgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBhcHBsaWNhdGlvbklkICE9PSBBVi5hcHBsaWNhdGlvbklkICAmJlxuICAgICAgICBhcHBsaWNhdGlvbktleSAhPT0gQVYuYXBwbGljYXRpb25LZXkgJiZcbiAgICAgICAgbWFzdGVyS2V5ICE9PSBBVi5tYXN0ZXJLZXkpIHtcbiAgICAgIGNvbnNvbGUud2FybignQVZPU0Nsb3VkIFNESyBpcyBhbHJlYWR5IGluaXRpYWxpemVkLCBwbGVhc2UgZG9uXFwndCByZWluaXRpYWxpemUgaXQuJyk7XG4gICAgfVxuICAgIEFWLmFwcGxpY2F0aW9uSWQgPSBhcHBsaWNhdGlvbklkO1xuICAgIEFWLmFwcGxpY2F0aW9uS2V5ID0gYXBwbGljYXRpb25LZXk7XG4gICAgQVYubWFzdGVyS2V5ID0gbWFzdGVyS2V5O1xuICAgIEFWLl91c2VNYXN0ZXJLZXkgPSBmYWxzZTtcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBDYWxsIHRoaXMgbWV0aG9kIHRvIHNldCBwcm9kdWN0aW9uIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IHByb2R1Y3Rpb24gVHJ1ZSBpcyBwcm9kdWN0aW9uIGVudmlyb25tZW50LGFuZFxuICAgKiAgaXQncyB0cnVlIGJ5IGRlZmF1bHQuXG4gICAqL1xuICBBVi5zZXRQcm9kdWN0aW9uID0gZnVuY3Rpb24ocHJvZHVjdGlvbil7XG4gICAgaWYoIUFWLl9pc051bGxPclVuZGVmaW5lZChwcm9kdWN0aW9uKSkge1xuICAgICAgLy9tYWtlIHN1cmUgaXQncyBhIG51bWJlclxuICAgICAgcHJvZHVjdGlvbiA9IHByb2R1Y3Rpb24gPyAxIDogMDtcbiAgICB9XG4gICAgLy9kZWZhdWx0IGlzIDFcbiAgICBBVi5hcHBsaWNhdGlvblByb2R1Y3Rpb24gPSBBVi5faXNOdWxsT3JVbmRlZmluZWQocHJvZHVjdGlvbikgPyAxOiBwcm9kdWN0aW9uO1xuICB9O1xuXG4gIC8vIElmIHdlJ3JlIHJ1bm5pbmcgaW4gbm9kZS5qcywgYWxsb3cgdXNpbmcgdGhlIG1hc3RlciBrZXkuXG4gIGlmIChBVi5faXNOb2RlKSB7XG4gICAgQVYuaW5pdGlhbGl6ZSA9IEFWLl9pbml0aWFsaXplO1xuXG4gICAgQVYuQ2xvdWQgPSBBVi5DbG91ZCB8fCB7fTtcbiAgICAvKipcbiAgICAgKiBTd2l0Y2hlcyB0aGUgQVZPU0Nsb3VkIFNESyB0byB1c2luZyB0aGUgTWFzdGVyIGtleS4gIFRoZSBNYXN0ZXIga2V5IGdyYW50c1xuICAgICAqIHByaXZlbGVnZWQgYWNjZXNzIHRvIHRoZSBkYXRhIGluIEFWT1NDbG91ZCBhbmQgY2FuIGJlIHVzZWQgdG8gYnlwYXNzIEFDTHMgYW5kXG4gICAgICogb3RoZXIgcmVzdHJpY3Rpb25zIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGNsaWVudCBTREtzLlxuICAgICAqIDxwPjxzdHJvbmc+PGVtPkF2YWlsYWJsZSBpbiBDbG91ZCBDb2RlIGFuZCBOb2RlLmpzIG9ubHkuPC9lbT48L3N0cm9uZz5cbiAgICAgKiA8L3A+XG4gICAgICovXG4gICAgQVYuQ2xvdWQudXNlTWFzdGVyS2V5ID0gZnVuY3Rpb24oKSB7XG4gICAgICBBVi5fdXNlTWFzdGVyS2V5ID0gdHJ1ZTtcbiAgICB9O1xuICB9XG5cblxuICAgLyoqXG4gICAgKlVzZSBjaGluYSBhdm9zY2xvdWQgQVBJIHNlcnZpY2U6aHR0cHM6Ly9jbi5hdm9zY2xvdWQuY29tXG4gICAgKi9cbiAgIEFWLnVzZUFWQ2xvdWRDTiA9IGZ1bmN0aW9uKCl7XG4gICAgQVYuc2VydmVyVVJMID0gXCJodHRwczovL2xlYW5jbG91ZC5jblwiO1xuICAgfTtcblxuICAgLyoqXG4gICAgKlVzZSBVU0EgYXZvc2Nsb3VkIEFQSSBzZXJ2aWNlOmh0dHBzOi8vdXMuYXZvc2Nsb3VkLmNvbVxuICAgICovXG4gICBBVi51c2VBVkNsb3VkVVMgPSBmdW5jdGlvbigpe1xuICAgIEFWLnNlcnZlclVSTCA9IFwiaHR0cHM6Ly91cy1hcGkubGVhbmNsb3VkLmNuXCI7XG4gICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHByZWZpeCBmb3IgbG9jYWxTdG9yYWdlIGtleXMgdXNlZCBieSB0aGlzIGluc3RhbmNlIG9mIEFWLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcmVsYXRpdmUgc3VmZml4IHRvIGFwcGVuZCB0byBpdC5cbiAgICogICAgIG51bGwgb3IgdW5kZWZpbmVkIGlzIHRyZWF0ZWQgYXMgdGhlIGVtcHR5IHN0cmluZy5cbiAgICogQHJldHVybiB7U3RyaW5nfSBUaGUgZnVsbCBrZXkgbmFtZS5cbiAgICovXG4gIEFWLl9nZXRBVlBhdGggPSBmdW5jdGlvbihwYXRoKSB7XG4gICAgaWYgKCFBVi5hcHBsaWNhdGlvbklkKSB7XG4gICAgICB0aHJvdyBcIllvdSBuZWVkIHRvIGNhbGwgQVYuaW5pdGlhbGl6ZSBiZWZvcmUgdXNpbmcgQVYuXCI7XG4gICAgfVxuICAgIGlmICghcGF0aCkge1xuICAgICAgcGF0aCA9IFwiXCI7XG4gICAgfVxuICAgIGlmICghQVYuXy5pc1N0cmluZyhwYXRoKSkge1xuICAgICAgdGhyb3cgXCJUcmllZCB0byBnZXQgYSBsb2NhbFN0b3JhZ2UgcGF0aCB0aGF0IHdhc24ndCBhIFN0cmluZy5cIjtcbiAgICB9XG4gICAgaWYgKHBhdGhbMF0gPT09IFwiL1wiKSB7XG4gICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIHJldHVybiBcIkFWL1wiICsgQVYuYXBwbGljYXRpb25JZCArIFwiL1wiICsgcGF0aDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdW5pcXVlIHN0cmluZyBmb3IgdGhpcyBhcHAgb24gdGhpcyBtYWNoaW5lLlxuICAgKiBHZXRzIHJlc2V0IHdoZW4gbG9jYWxTdG9yYWdlIGlzIGNsZWFyZWQuXG4gICAqL1xuICBBVi5faW5zdGFsbGF0aW9uSWQgPSBudWxsO1xuICBBVi5fZ2V0SW5zdGFsbGF0aW9uSWQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTZWUgaWYgaXQncyBjYWNoZWQgaW4gUkFNLlxuICAgIGlmIChBVi5faW5zdGFsbGF0aW9uSWQpIHtcbiAgICAgIHJldHVybiBBVi5Qcm9taXNlLmFzKEFWLl9pbnN0YWxsYXRpb25JZCk7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIGdldCBpdCBmcm9tIGxvY2FsU3RvcmFnZS5cbiAgICB2YXIgcGF0aCA9IEFWLl9nZXRBVlBhdGgoXCJpbnN0YWxsYXRpb25JZFwiKTtcbiAgICByZXR1cm4gQVYubG9jYWxTdG9yYWdlLmdldEl0ZW1Bc3luYyhwYXRoKS50aGVuKGZ1bmN0aW9uKF9pbnN0YWxsYXRpb25JZCl7XG4gICAgICBBVi5faW5zdGFsbGF0aW9uSWQgPSBfaW5zdGFsbGF0aW9uSWQ7XG4gICAgICBpZiAoIUFWLl9pbnN0YWxsYXRpb25JZCkge1xuICAgICAgICAvLyBJdCB3YXNuJ3QgaW4gbG9jYWxTdG9yYWdlLCBzbyBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgICB2YXIgaGV4T2N0ZXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoMStNYXRoLnJhbmRvbSgpKSoweDEwMDAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9O1xuICAgICAgICBBVi5faW5zdGFsbGF0aW9uSWQgPSAoXG4gICAgICAgICAgaGV4T2N0ZXQoKSArIGhleE9jdGV0KCkgKyBcIi1cIiArXG4gICAgICAgICAgaGV4T2N0ZXQoKSArIFwiLVwiICtcbiAgICAgICAgICBoZXhPY3RldCgpICsgXCItXCIgK1xuICAgICAgICAgIGhleE9jdGV0KCkgKyBcIi1cIiArXG4gICAgICAgICAgaGV4T2N0ZXQoKSArIGhleE9jdGV0KCkgKyBoZXhPY3RldCgpKTtcbiAgICAgICAgcmV0dXJuIEFWLmxvY2FsU3RvcmFnZS5zZXRJdGVtQXN5bmMocGF0aCwgQVYuX2luc3RhbGxhdGlvbklkKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gX2luc3RhbGxhdGlvbklkO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIEFWLl9wYXJzZURhdGUgPSBmdW5jdGlvbihpc284NjAxKSB7XG4gICAgdmFyIHJlZ2V4cCA9IG5ldyBSZWdFeHAoXG4gICAgICBcIl4oWzAtOV17MSw0fSktKFswLTldezEsMn0pLShbMC05XXsxLDJ9KVwiICsgXCJUXCIgK1xuICAgICAgXCIoWzAtOV17MSwyfSk6KFswLTldezEsMn0pOihbMC05XXsxLDJ9KVwiICtcbiAgICAgIFwiKC4oWzAtOV0rKSk/XCIgKyBcIlokXCIpO1xuICAgIHZhciBtYXRjaCA9IHJlZ2V4cC5leGVjKGlzbzg2MDEpO1xuICAgIGlmICghbWF0Y2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB5ZWFyID0gbWF0Y2hbMV0gfHwgMDtcbiAgICB2YXIgbW9udGggPSAobWF0Y2hbMl0gfHwgMSkgLSAxO1xuICAgIHZhciBkYXkgPSBtYXRjaFszXSB8fCAwO1xuICAgIHZhciBob3VyID0gbWF0Y2hbNF0gfHwgMDtcbiAgICB2YXIgbWludXRlID0gbWF0Y2hbNV0gfHwgMDtcbiAgICB2YXIgc2Vjb25kID0gbWF0Y2hbNl0gfHwgMDtcbiAgICB2YXIgbWlsbGkgPSBtYXRjaFs4XSB8fCAwO1xuXG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaSkpO1xuICB9O1xuXG4gIEFWLl9hamF4SUU4ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIGRhdGEpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBBVi5Qcm9taXNlKCk7XG4gICAgdmFyIHhkciA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIHhkci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXNwb25zZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlc3BvbnNlID0gSlNPTi5wYXJzZSh4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcHJvbWlzZS5yZWplY3QoZSk7XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgcHJvbWlzZS5yZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHhkci5vbmVycm9yID0geGRyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gTGV0J3MgZmFrZSBhIHJlYWwgZXJyb3IgbWVzc2FnZS5cbiAgICAgIHZhciBmYWtlUmVzcG9uc2UgPSB7XG4gICAgICAgIHJlc3BvbnNlVGV4dDogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNvZGU6IEFWLkVycm9yLlhfRE9NQUlOX1JFUVVFU1QsXG4gICAgICAgICAgZXJyb3I6IFwiSUUncyBYRG9tYWluUmVxdWVzdCBkb2VzIG5vdCBzdXBwbHkgZXJyb3IgaW5mby5cIlxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICAgIHByb21pc2UucmVqZWN0KHhkcik7XG4gICAgfTtcbiAgICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge307XG4gICAgeGRyLm9wZW4obWV0aG9kLCB1cmwpO1xuICAgIHhkci5zZW5kKGRhdGEpO1xuICAgIHJldHVybiBwcm9taXNlO1xuICB9O1xuXG4gICBBVi5fdXNlWERvbWFpblJlcXVlc3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICBpZiAodHlwZW9mKFhEb21haW5SZXF1ZXN0KSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAvLyBXZSdyZSBpbiBJRSA4Ky5cbiAgICAgICAgICAgaWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpKSB7XG4gICAgICAgICAgICAgICAvLyBXZSdyZSBpbiBJRSAxMCsuXG4gICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgIH1cbiAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgfVxuICAgICAgIHJldHVybiBmYWxzZTtcbiAgIH07XG5cbiAgQVYuX2FqYXggPSBmdW5jdGlvbihtZXRob2QsIHVybCwgZGF0YSwgc3VjY2VzcywgZXJyb3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgIHN1Y2Nlc3M6IHN1Y2Nlc3MsXG4gICAgICBlcnJvcjogZXJyb3JcbiAgICB9O1xuXG4gICAgaWYgKEFWLl91c2VYRG9tYWluUmVxdWVzdCgpKSB7XG4gICAgICByZXR1cm4gQVYuX2FqYXhJRTgobWV0aG9kLCB1cmwsIGRhdGEpLl90aGVuUnVuQ2FsbGJhY2tzKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBwcm9taXNlID0gbmV3IEFWLlByb21pc2UoKTtcbiAgICB2YXIgaGFuZGxlZCA9IGZhbHNlO1xuXG4gICAgdmFyIHhociA9IG5ldyBBVi5YTUxIdHRwUmVxdWVzdCgpO1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PT0gNCkge1xuICAgICAgICBpZiAoaGFuZGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVkID0gdHJ1ZTtcblxuICAgICAgICBpZiAoeGhyLnN0YXR1cyA+PSAyMDAgJiYgeGhyLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgIHZhciByZXNwb25zZTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHByb21pc2UucmVzb2x2ZShyZXNwb25zZSwgeGhyLnN0YXR1cywgeGhyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvbWlzZS5yZWplY3QoeGhyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgeGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwidGV4dC9wbGFpblwiKTsgIC8vIGF2b2lkIHByZS1mbGlnaHQuXG4gICAgaWYgKEFWLl9pc05vZGUpIHtcbiAgICAgIC8vIEFkZCBhIHNwZWNpYWwgdXNlciBhZ2VudCBqdXN0IGZvciByZXF1ZXN0IGZyb20gbm9kZS5qcy5cbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKFwiVXNlci1BZ2VudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBVi9cIiArIEFWLlZFUlNJT04gK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgKE5vZGVKUyBcIiArIHByb2Nlc3MudmVyc2lvbnMubm9kZSArIFwiKVwiKTtcbiAgICB9XG4gICAgeGhyLnNlbmQoZGF0YSk7XG4gICAgcmV0dXJuIHByb21pc2UuX3RoZW5SdW5DYWxsYmFja3Mob3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gQSBzZWxmLXByb3BhZ2F0aW5nIGV4dGVuZCBmdW5jdGlvbi5cbiAgQVYuX2V4dGVuZCA9IGZ1bmN0aW9uKHByb3RvUHJvcHMsIGNsYXNzUHJvcHMpIHtcbiAgICB2YXIgY2hpbGQgPSBpbmhlcml0cyh0aGlzLCBwcm90b1Byb3BzLCBjbGFzc1Byb3BzKTtcbiAgICBjaGlsZC5leHRlbmQgPSB0aGlzLmV4dGVuZDtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIHJvdXRlIGlzIGNsYXNzZXMsIHVzZXJzLCBsb2dpbiwgZXRjLlxuICAgKiBvYmplY3RJZCBpcyBudWxsIGlmIHRoZXJlIGlzIG5vIGFzc29jaWF0ZWQgb2JqZWN0SWQuXG4gICAqIG1ldGhvZCBpcyB0aGUgaHR0cCBtZXRob2QgZm9yIHRoZSBSRVNUIEFQSS5cbiAgICogZGF0YU9iamVjdCBpcyB0aGUgcGF5bG9hZCBhcyBhbiBvYmplY3QsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm9uZS5cbiAgICogQGlnbm9yZVxuICAgKi9cbiAgQVYuX3JlcXVlc3QgPSBmdW5jdGlvbihyb3V0ZSwgY2xhc3NOYW1lLCBvYmplY3RJZCwgbWV0aG9kLCBkYXRhT2JqZWN0KSB7XG4gICAgaWYgKCFBVi5hcHBsaWNhdGlvbklkKSB7XG4gICAgICB0aHJvdyBcIllvdSBtdXN0IHNwZWNpZnkgeW91ciBhcHBsaWNhdGlvbklkIHVzaW5nIEFWLmluaXRpYWxpemVcIjtcbiAgICB9XG5cbiAgICBpZiAoIUFWLmFwcGxpY2F0aW9uS2V5ICYmICFBVi5tYXN0ZXJLZXkpIHtcbiAgICAgIHRocm93IFwiWW91IG11c3Qgc3BlY2lmeSBhIGtleSB1c2luZyBBVi5pbml0aWFsaXplXCI7XG4gICAgfVxuXG5cbiAgICBpZiAocm91dGUgIT09IFwiYmF0Y2hcIiAmJlxuICAgICAgICByb3V0ZSAhPT0gXCJjbGFzc2VzXCIgJiZcbiAgICAgICAgcm91dGUgIT09IFwiZmlsZXNcIiAmJlxuICAgICAgICByb3V0ZSAhPT0gXCJkYXRlXCIgJiZcbiAgICAgICAgcm91dGUgIT09IFwiZnVuY3Rpb25zXCIgJiZcbiAgICAgICAgcm91dGUgIT09IFwibG9naW5cIiAmJlxuICAgICAgICByb3V0ZSAhPT0gXCJwdXNoXCIgJiZcbiAgICAgICAgcm91dGUgIT09IFwic2VhcmNoL3NlbGVjdFwiICYmXG4gICAgICAgIHJvdXRlICE9PSBcInJlcXVlc3RQYXNzd29yZFJlc2V0XCIgJiZcbiAgICAgICAgcm91dGUgIT09IFwicmVxdWVzdEVtYWlsVmVyaWZ5XCIgJiZcbiAgICAgICAgcm91dGUgIT09IFwicmVxdWVzdFBhc3N3b3JkUmVzZXRCeVNtc0NvZGVcIiAmJlxuICAgICAgICByb3V0ZSAhPT0gXCJyZXNldFBhc3N3b3JkQnlTbXNDb2RlXCIgJiZcbiAgICAgICAgcm91dGUgIT09IFwicmVxdWVzdE1vYmlsZVBob25lVmVyaWZ5XCIgJiZcbiAgICAgICAgcm91dGUgIT09IFwicmVxdWVzdExvZ2luU21zQ29kZVwiICYmXG4gICAgICAgIHJvdXRlICE9PSBcInZlcmlmeU1vYmlsZVBob25lXCIgJiZcbiAgICAgICAgcm91dGUgIT09IFwicmVxdWVzdFNtc0NvZGVcIiAmJlxuICAgICAgICByb3V0ZSAhPT0gXCJ2ZXJpZnlTbXNDb2RlXCIgJiZcbiAgICAgICAgcm91dGUgIT09IFwidXNlcnNcIiAmJlxuICAgICAgICByb3V0ZSAhPT0gXCJ1c2Vyc0J5TW9iaWxlUGhvbmVcIiAmJlxuICAgICAgICByb3V0ZSAhPT0gXCJjbG91ZFF1ZXJ5XCIgJiZcbiAgICAgICAgcm91dGUgIT09IFwicWluaXVcIiAmJlxuICAgICAgICByb3V0ZSAhPT0gXCJzdGF0dXNlc1wiICYmXG4gICAgICAgIHJvdXRlICE9PSBcImJpZ3F1ZXJ5XCIgJiZcbiAgICAgICAgcm91dGUgIT09ICdzZWFyY2gvc2VsZWN0JyAmJlxuICAgICAgICByb3V0ZSAhPT0gJ3N1YnNjcmliZS9zdGF0dXNlcy9jb3VudCcgJiZcbiAgICAgICAgcm91dGUgIT09ICdzdWJzY3JpYmUvc3RhdHVzZXMnICYmXG4gICAgICAgICEoL3VzZXJzXFwvW15cXC9dK1xcL3VwZGF0ZVBhc3N3b3JkLy50ZXN0KHJvdXRlKSkgJiZcbiAgICAgICAgISgvdXNlcnNcXC9bXlxcL10rXFwvZnJpZW5kc2hpcFxcL1teXFwvXSsvLnRlc3Qocm91dGUpKSkge1xuICAgICAgdGhyb3cgXCJCYWQgcm91dGU6ICdcIiArIHJvdXRlICsgXCInLlwiO1xuICAgIH1cblxuICAgIHZhciB1cmwgPSBBVi5zZXJ2ZXJVUkw7XG4gICAgaWYgKHVybC5jaGFyQXQodXJsLmxlbmd0aCAtIDEpICE9PSBcIi9cIikge1xuICAgICAgdXJsICs9IFwiL1wiO1xuICAgIH1cbiAgICB1cmwgKz0gXCIxLjEvXCIgKyByb3V0ZTtcbiAgICBpZiAoY2xhc3NOYW1lKSB7XG4gICAgICB1cmwgKz0gXCIvXCIgKyBjbGFzc05hbWU7XG4gICAgfVxuICAgIGlmIChvYmplY3RJZCkge1xuICAgICAgdXJsICs9IFwiL1wiICsgb2JqZWN0SWQ7XG4gICAgfVxuICAgIGlmICgocm91dGUgPT09J3VzZXJzJyB8fCByb3V0ZSA9PT0gJ2NsYXNzZXMnKSAmJiBkYXRhT2JqZWN0ICYmIGRhdGFPYmplY3QuX2ZldGNoV2hlblNhdmUpe1xuICAgICAgZGVsZXRlIGRhdGFPYmplY3QuX2ZldGNoV2hlblNhdmU7XG4gICAgICB1cmwgKz0gJz9uZXc9dHJ1ZSc7XG4gICAgfVxuXG4gICAgZGF0YU9iamVjdCA9IEFWLl8uY2xvbmUoZGF0YU9iamVjdCB8fCB7fSk7XG4gICAgaWYgKG1ldGhvZCAhPT0gXCJQT1NUXCIpIHtcbiAgICAgIGRhdGFPYmplY3QuX21ldGhvZCA9IG1ldGhvZDtcbiAgICAgIG1ldGhvZCA9IFwiUE9TVFwiO1xuICAgIH1cblxuICAgIGRhdGFPYmplY3QuX0FwcGxpY2F0aW9uSWQgPSBBVi5hcHBsaWNhdGlvbklkO1xuICAgIGRhdGFPYmplY3QuX0FwcGxpY2F0aW9uS2V5ID0gQVYuYXBwbGljYXRpb25LZXk7XG4gICAgaWYoIUFWLl9pc051bGxPclVuZGVmaW5lZChBVi5hcHBsaWNhdGlvblByb2R1Y3Rpb24pKSB7XG4gICAgICBkYXRhT2JqZWN0Ll9BcHBsaWNhdGlvblByb2R1Y3Rpb24gPSBBVi5hcHBsaWNhdGlvblByb2R1Y3Rpb247XG4gICAgfVxuICAgIGlmKEFWLl91c2VNYXN0ZXJLZXkpXG4gICAgICAgIGRhdGFPYmplY3QuX01hc3RlcktleSA9IEFWLm1hc3RlcktleTtcbiAgICBkYXRhT2JqZWN0Ll9DbGllbnRWZXJzaW9uID0gQVYuVkVSU0lPTjtcbiAgICAvLyBQYXNzIHRoZSBzZXNzaW9uIHRva2VuIG9uIGV2ZXJ5IHJlcXVlc3QuXG4gICAgcmV0dXJuIEFWLlVzZXIuY3VycmVudEFzeW5jKCkudGhlbihmdW5jdGlvbihjdXJyZW50VXNlcikge1xuICAgICAgaWYgKGN1cnJlbnRVc2VyICYmIGN1cnJlbnRVc2VyLl9zZXNzaW9uVG9rZW4pIHtcbiAgICAgICAgZGF0YU9iamVjdC5fU2Vzc2lvblRva2VuID0gY3VycmVudFVzZXIuX3Nlc3Npb25Ub2tlbjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBVi5fZ2V0SW5zdGFsbGF0aW9uSWQoKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uKF9JbnN0YWxsYXRpb25JZCkge1xuICAgICAgZGF0YU9iamVjdC5fSW5zdGFsbGF0aW9uSWQgPSBfSW5zdGFsbGF0aW9uSWQ7XG4gICAgICBcbiAgICAgIHZhciBkYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YU9iamVjdCk7XG4gICAgICByZXR1cm4gQVYuX2FqYXgobWV0aG9kLCB1cmwsIGRhdGEpLnRoZW4obnVsbCwgZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSBlcnJvciBpbnRvIGFuIGluc3RhbmNlIG9mIEFWLkVycm9yIGJ5IHRyeWluZyB0byBwYXJzZVxuICAgICAgICAvLyB0aGUgZXJyb3Igc3RyaW5nIGFzIEpTT04uXG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLnJlc3BvbnNlVGV4dCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgZXJyb3JKU09OID0gSlNPTi5wYXJzZShyZXNwb25zZS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgaWYgKGVycm9ySlNPTikge1xuICAgICAgICAgICAgICBlcnJvciA9IG5ldyBBVi5FcnJvcihlcnJvckpTT04uY29kZSwgZXJyb3JKU09OLmVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBmYWlsIHRvIHBhcnNlIHRoZSBlcnJvciB0ZXh0LCB0aGF0J3Mgb2theS5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IgPSBlcnJvciB8fCBuZXcgQVYuRXJyb3IoLTEsIHJlc3BvbnNlLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIC8vIEJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGEgcmVqZWN0ZWQgUHJvbWlzZSwgdGhpcyB3aWxsIHdvcmsgd2l0aFxuICAgICAgICAvLyBlaXRoZXIgalF1ZXJ5IG9yIFByb21pc2VzL0Egc2VtYW50aWNzLlxuICAgICAgICByZXR1cm4gQVYuUHJvbWlzZS5lcnJvcihlcnJvcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZ2V0IGEgdmFsdWUgZnJvbSBhIEJhY2tib25lIG9iamVjdCBhcyBhIHByb3BlcnR5XG4gIC8vIG9yIGFzIGEgZnVuY3Rpb24uXG4gIEFWLl9nZXRWYWx1ZSA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcCkge1xuICAgIGlmICghKG9iamVjdCAmJiBvYmplY3RbcHJvcF0pKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEFWLl8uaXNGdW5jdGlvbihvYmplY3RbcHJvcF0pID8gb2JqZWN0W3Byb3BdKCkgOiBvYmplY3RbcHJvcF07XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgdmFsdWUgaW4gYSBBViBPYmplY3QgaW50byB0aGUgYXBwcm9wcmlhdGUgcmVwcmVzZW50YXRpb24uXG4gICAqIFRoaXMgaXMgdGhlIEpTIGVxdWl2YWxlbnQgb2YgSmF2YSdzIEFWLm1heWJlUmVmZXJlbmNlQW5kRW5jb2RlKE9iamVjdClcbiAgICogaWYgc2Vlbk9iamVjdHMgaXMgZmFsc2V5LiBPdGhlcndpc2UgYW55IEFWLk9iamVjdHMgbm90IGluXG4gICAqIHNlZW5PYmplY3RzIHdpbGwgYmUgZnVsbHkgZW1iZWRkZWQgcmF0aGVyIHRoYW4gZW5jb2RlZFxuICAgKiBhcyBhIHBvaW50ZXIuICBUaGlzIGFycmF5IHdpbGwgYmUgdXNlZCB0byBwcmV2ZW50IGdvaW5nIGludG8gYW4gaW5maW5pdGVcbiAgICogbG9vcCBiZWNhdXNlIHdlIGhhdmUgY2lyY3VsYXIgcmVmZXJlbmNlcy4gIElmIDxzZWVuT2JqZWN0cz5cbiAgICogaXMgc2V0LCB0aGVuIG5vbmUgb2YgdGhlIEFWIE9iamVjdHMgdGhhdCBhcmUgc2VyaWFsaXplZCBjYW4gYmUgZGlydHkuXG4gICAqL1xuICBBVi5fZW5jb2RlID0gZnVuY3Rpb24odmFsdWUsIHNlZW5PYmplY3RzLCBkaXNhbGxvd09iamVjdHMpIHtcbiAgICB2YXIgXyA9IEFWLl87XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQVYuT2JqZWN0KSB7XG4gICAgICBpZiAoZGlzYWxsb3dPYmplY3RzKSB7XG4gICAgICAgIHRocm93IFwiQVYuT2JqZWN0cyBub3QgYWxsb3dlZCBoZXJlXCI7XG4gICAgICB9XG4gICAgICBpZiAoIXNlZW5PYmplY3RzIHx8IF8uaW5jbHVkZShzZWVuT2JqZWN0cywgdmFsdWUpIHx8ICF2YWx1ZS5faGFzRGF0YSkge1xuICAgICAgICByZXR1cm4gdmFsdWUuX3RvUG9pbnRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKCF2YWx1ZS5kaXJ0eSgpKSB7XG4gICAgICAgIHNlZW5PYmplY3RzID0gc2Vlbk9iamVjdHMuY29uY2F0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIEFWLl9lbmNvZGUodmFsdWUuX3RvRnVsbEpTT04oc2Vlbk9iamVjdHMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWVuT2JqZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzYWxsb3dPYmplY3RzKTtcbiAgICAgIH1cbiAgICAgIHRocm93IFwiVHJpZWQgdG8gc2F2ZSBhbiBvYmplY3Qgd2l0aCBhIHBvaW50ZXIgdG8gYSBuZXcsIHVuc2F2ZWQgb2JqZWN0LlwiO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBVi5BQ0wpIHtcbiAgICAgIHJldHVybiB2YWx1ZS50b0pTT04oKTtcbiAgICB9XG4gICAgaWYgKF8uaXNEYXRlKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHsgXCJfX3R5cGVcIjogXCJEYXRlXCIsIFwiaXNvXCI6IHZhbHVlLnRvSlNPTigpIH07XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFWLkdlb1BvaW50KSB7XG4gICAgICByZXR1cm4gdmFsdWUudG9KU09OKCk7XG4gICAgfVxuICAgIGlmIChfLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICByZXR1cm4gXy5tYXAodmFsdWUsIGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIEFWLl9lbmNvZGUoeCwgc2Vlbk9iamVjdHMsIGRpc2FsbG93T2JqZWN0cyk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKF8uaXNSZWdFeHAodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWUuc291cmNlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBVi5SZWxhdGlvbikge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvSlNPTigpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBVi5PcCkge1xuICAgICAgcmV0dXJuIHZhbHVlLnRvSlNPTigpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBVi5GaWxlKSB7XG4gICAgICBpZiAoIXZhbHVlLnVybCgpICYmICF2YWx1ZS5pZCkge1xuICAgICAgICB0aHJvdyBcIlRyaWVkIHRvIHNhdmUgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYW4gdW5zYXZlZCBmaWxlLlwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgX190eXBlOiBcIkZpbGVcIixcbiAgICAgICAgaWQ6ICB2YWx1ZS5pZCxcbiAgICAgICAgbmFtZTogdmFsdWUubmFtZSgpLFxuICAgICAgICB1cmw6IHZhbHVlLnVybCgpXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHZhciBvdXRwdXQgPSB7fTtcbiAgICAgIEFWLl9vYmplY3RFYWNoKHZhbHVlLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICAgIG91dHB1dFtrXSA9IEFWLl9lbmNvZGUodiwgc2Vlbk9iamVjdHMsIGRpc2FsbG93T2JqZWN0cyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogVGhlIGludmVyc2UgZnVuY3Rpb24gb2YgQVYuX2VuY29kZS5cbiAgICogVE9ETzogbWFrZSBkZWNvZGUgbm90IG11dGF0ZSB2YWx1ZS5cbiAgICovXG4gIEFWLl9kZWNvZGUgPSBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgdmFyIF8gPSBBVi5fO1xuICAgIGlmICghXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKF8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIEFWLl9hcnJheUVhY2godmFsdWUsIGZ1bmN0aW9uKHYsIGspIHtcbiAgICAgICAgdmFsdWVba10gPSBBVi5fZGVjb2RlKGssIHYpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFWLk9iamVjdCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBVi5GaWxlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFWLk9wKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5fX29wKSB7XG4gICAgICByZXR1cm4gQVYuT3AuX2RlY29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5fX3R5cGUgPT09IFwiUG9pbnRlclwiKSB7XG4gICAgICB2YXIgY2xhc3NOYW1lID0gdmFsdWUuY2xhc3NOYW1lO1xuICAgICAgdmFyIHBvaW50ZXIgPSBBVi5PYmplY3QuX2NyZWF0ZShjbGFzc05hbWUpO1xuICAgICAgaWYodmFsdWUuY3JlYXRlZEF0KXtcbiAgICAgICAgICBkZWxldGUgdmFsdWUuX190eXBlO1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZS5jbGFzc05hbWU7XG4gICAgICAgICAgcG9pbnRlci5fZmluaXNoRmV0Y2godmFsdWUsIHRydWUpO1xuICAgICAgfWVsc2V7XG4gICAgICAgICAgcG9pbnRlci5fZmluaXNoRmV0Y2goeyBvYmplY3RJZDogdmFsdWUub2JqZWN0SWQgfSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBvaW50ZXI7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5fX3R5cGUgPT09IFwiT2JqZWN0XCIpIHtcbiAgICAgIC8vIEl0J3MgYW4gT2JqZWN0IGluY2x1ZGVkIGluIGEgcXVlcnkgcmVzdWx0LlxuICAgICAgdmFyIGNsYXNzTmFtZSA9IHZhbHVlLmNsYXNzTmFtZTtcbiAgICAgIGRlbGV0ZSB2YWx1ZS5fX3R5cGU7XG4gICAgICBkZWxldGUgdmFsdWUuY2xhc3NOYW1lO1xuICAgICAgdmFyIG9iamVjdCA9IEFWLk9iamVjdC5fY3JlYXRlKGNsYXNzTmFtZSk7XG4gICAgICBvYmplY3QuX2ZpbmlzaEZldGNoKHZhbHVlLCB0cnVlKTtcbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5fX3R5cGUgPT09IFwiRGF0ZVwiKSB7XG4gICAgICByZXR1cm4gQVYuX3BhcnNlRGF0ZSh2YWx1ZS5pc28pO1xuICAgIH1cbiAgICBpZiAodmFsdWUuX190eXBlID09PSBcIkdlb1BvaW50XCIpIHtcbiAgICAgIHJldHVybiBuZXcgQVYuR2VvUG9pbnQoe1xuICAgICAgICBsYXRpdHVkZTogdmFsdWUubGF0aXR1ZGUsXG4gICAgICAgIGxvbmdpdHVkZTogdmFsdWUubG9uZ2l0dWRlXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGtleSA9PT0gXCJBQ0xcIikge1xuICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgQVYuQUNMKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQVYuQUNMKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLl9fdHlwZSA9PT0gXCJSZWxhdGlvblwiKSB7XG4gICAgICB2YXIgcmVsYXRpb24gPSBuZXcgQVYuUmVsYXRpb24obnVsbCwga2V5KTtcbiAgICAgIHJlbGF0aW9uLnRhcmdldENsYXNzTmFtZSA9IHZhbHVlLmNsYXNzTmFtZTtcbiAgICAgIHJldHVybiByZWxhdGlvbjtcbiAgICB9XG4gICAgaWYgKHZhbHVlLl9fdHlwZSA9PT0gXCJGaWxlXCIpIHtcbiAgICAgIHZhciBmaWxlID0gbmV3IEFWLkZpbGUodmFsdWUubmFtZSk7XG4gICAgICBmaWxlLl9tZXRhRGF0YSA9IHZhbHVlLm1ldGFEYXRhIHx8IHt9O1xuICAgICAgZmlsZS5fdXJsID0gdmFsdWUudXJsO1xuICAgICAgZmlsZS5pZCA9IHZhbHVlLm9iamVjdElkO1xuICAgICAgcmV0dXJuIGZpbGU7XG4gICAgfVxuICAgIEFWLl9vYmplY3RFYWNoKHZhbHVlLCBmdW5jdGlvbih2LCBrKSB7XG4gICAgICB2YWx1ZVtrXSA9IEFWLl9kZWNvZGUoaywgdik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIEFWLl9hcnJheUVhY2ggPSBBVi5fLmVhY2g7XG5cbiAgLyoqXG4gICAqIERvZXMgYSBkZWVwIHRyYXZlcnNhbCBvZiBldmVyeSBpdGVtIGluIG9iamVjdCwgY2FsbGluZyBmdW5jIG9uIGV2ZXJ5IG9uZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IG9yIGFycmF5IHRvIHRyYXZlcnNlIGRlZXBseS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZXZlcnkgaXRlbS4gSXQgd2lsbFxuICAgKiAgICAgYmUgcGFzc2VkIHRoZSBpdGVtIGFzIGFuIGFyZ3VtZW50LiBJZiBpdCByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLCB0aGF0XG4gICAqICAgICB2YWx1ZSB3aWxsIHJlcGxhY2UgdGhlIGl0ZW0gaW4gaXRzIHBhcmVudCBjb250YWluZXIuXG4gICAqIEByZXR1cm5zIHt9IHRoZSByZXN1bHQgb2YgY2FsbGluZyBmdW5jIG9uIHRoZSB0b3AtbGV2ZWwgb2JqZWN0IGl0c2VsZi5cbiAgICovXG4gIEFWLl90cmF2ZXJzZSA9IGZ1bmN0aW9uKG9iamVjdCwgZnVuYywgc2Vlbikge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBBVi5PYmplY3QpIHtcbiAgICAgIHNlZW4gPSBzZWVuIHx8IFtdO1xuICAgICAgaWYgKEFWLl8uaW5kZXhPZihzZWVuLCBvYmplY3QpID49IDApIHtcbiAgICAgICAgLy8gV2UndmUgYWxyZWFkeSB2aXNpdGVkIHRoaXMgb2JqZWN0IGluIHRoaXMgY2FsbC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2Vlbi5wdXNoKG9iamVjdCk7XG4gICAgICBBVi5fdHJhdmVyc2Uob2JqZWN0LmF0dHJpYnV0ZXMsIGZ1bmMsIHNlZW4pO1xuICAgICAgcmV0dXJuIGZ1bmMob2JqZWN0KTtcbiAgICB9XG4gICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEFWLlJlbGF0aW9uIHx8IG9iamVjdCBpbnN0YW5jZW9mIEFWLkZpbGUpIHtcbiAgICAgIC8vIE5vdGhpbmcgbmVlZHMgdG8gYmUgZG9uZSwgYnV0IHdlIGRvbid0IHdhbnQgdG8gcmVjdXJzZSBpbnRvIHRoZVxuICAgICAgLy8gb2JqZWN0J3MgcGFyZW50IGluZmluaXRlbHksIHNvIHdlIGNhdGNoIHRoaXMgY2FzZS5cbiAgICAgIHJldHVybiBmdW5jKG9iamVjdCk7XG4gICAgfVxuICAgIGlmIChBVi5fLmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgQVYuXy5lYWNoKG9iamVjdCwgZnVuY3Rpb24oY2hpbGQsIGluZGV4KSB7XG4gICAgICAgIHZhciBuZXdDaGlsZCA9IEFWLl90cmF2ZXJzZShjaGlsZCwgZnVuYywgc2Vlbik7XG4gICAgICAgIGlmIChuZXdDaGlsZCkge1xuICAgICAgICAgIG9iamVjdFtpbmRleF0gPSBuZXdDaGlsZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuYyhvYmplY3QpO1xuICAgIH1cbiAgICBpZiAoQVYuXy5pc09iamVjdChvYmplY3QpKSB7XG4gICAgICBBVi5fZWFjaChvYmplY3QsIGZ1bmN0aW9uKGNoaWxkLCBrZXkpIHtcbiAgICAgICAgdmFyIG5ld0NoaWxkID0gQVYuX3RyYXZlcnNlKGNoaWxkLCBmdW5jLCBzZWVuKTtcbiAgICAgICAgaWYgKG5ld0NoaWxkKSB7XG4gICAgICAgICAgb2JqZWN0W2tleV0gPSBuZXdDaGlsZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZnVuYyhvYmplY3QpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYyhvYmplY3QpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGxpa2UgXy5lYWNoLCBleGNlcHQ6XG4gICAqICogaXQgZG9lc24ndCB3b3JrIGZvciBzby1jYWxsZWQgYXJyYXktbGlrZSBvYmplY3RzLFxuICAgKiAqIGl0IGRvZXMgd29yayBmb3IgZGljdGlvbmFyaWVzIHdpdGggYSBcImxlbmd0aFwiIGF0dHJpYnV0ZS5cbiAgICovXG4gIEFWLl9vYmplY3RFYWNoID0gQVYuX2VhY2ggPSBmdW5jdGlvbihvYmosIGNhbGxiYWNrKSB7XG4gICAgdmFyIF8gPSBBVi5fO1xuICAgIGlmIChfLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgIF8uZWFjaChfLmtleXMob2JqKSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGNhbGxiYWNrKG9ialtrZXldLCBrZXkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF8uZWFjaChvYmosIGNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIG51bGwgb3IgdW5kZWZpbmVkLlxuICBBVi5faXNOdWxsT3JVbmRlZmluZWQgPSBmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIEFWLl8uaXNOdWxsKHgpIHx8IEFWLl8uaXNVbmRlZmluZWQoeCk7XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYi91dGlscy5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBcImpzMS4wLjAtcmMzXCI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbGliL3ZlcnNpb24uanNcIixcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWJcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuXG4vKmdsb2JhbCBfOiBmYWxzZSwgZG9jdW1lbnQ6IGZhbHNlICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKEFWKSB7XG4gIC8qKlxuICAgKiBDcmVhdGluZyBhIEFWLlZpZXcgY3JlYXRlcyBpdHMgaW5pdGlhbCBlbGVtZW50IG91dHNpZGUgb2YgdGhlIERPTSxcbiAgICogaWYgYW4gZXhpc3RpbmcgZWxlbWVudCBpcyBub3QgcHJvdmlkZWQuLi5cbiAgICogQGNsYXNzXG4gICAqXG4gICAqIDxwPkEgZm9yayBvZiBCYWNrYm9uZS5WaWV3LCBwcm92aWRlZCBmb3IgeW91ciBjb252ZW5pZW5jZS4gIElmIHlvdSB1c2UgdGhpc1xuICAgKiBjbGFzcywgeW91IG11c3QgYWxzbyBpbmNsdWRlIGpRdWVyeSwgb3IgYW5vdGhlciBsaWJyYXJ5IHRoYXQgcHJvdmlkZXMgYVxuICAgKiBqUXVlcnktY29tcGF0aWJsZSAkIGZ1bmN0aW9uLiAgRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSB0aGVcbiAgICogPGEgaHJlZj1cImh0dHA6Ly9kb2N1bWVudGNsb3VkLmdpdGh1Yi5jb20vYmFja2JvbmUvI1ZpZXdcIj5CYWNrYm9uZVxuICAgKiBkb2N1bWVudGF0aW9uPC9hPi48L3A+XG4gICAqIDxwPjxzdHJvbmc+PGVtPkF2YWlsYWJsZSBpbiB0aGUgY2xpZW50IFNESyBvbmx5LjwvZW0+PC9zdHJvbmc+PC9wPlxuICAgKi9cbiAgQVYuVmlldyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBjb25zb2xlLndhcm4oXCJBVi5WaWV3IGlzIGRlcHJlY2F0ZWQsIHBsZWFzZSBkb24ndCB1c2UgaXQgYW55bW9yZS5cIik7XG4gICAgdGhpcy5jaWQgPSBfLnVuaXF1ZUlkKCd2aWV3Jyk7XG4gICAgdGhpcy5fY29uZmlndXJlKG9wdGlvbnMgfHwge30pO1xuICAgIHRoaXMuX2Vuc3VyZUVsZW1lbnQoKTtcbiAgICB0aGlzLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gIH07XG5cbiAgLy8gQ2FjaGVkIHJlZ2V4IHRvIHNwbGl0IGtleXMgZm9yIGBkZWxlZ2F0ZWAuXG4gIHZhciBldmVudFNwbGl0dGVyID0gL14oXFxTKylcXHMqKC4qKSQvO1xuXG4gIC8vIExpc3Qgb2YgdmlldyBvcHRpb25zIHRvIGJlIG1lcmdlZCBhcyBwcm9wZXJ0aWVzLlxuXG4gIHZhciB2aWV3T3B0aW9ucyA9IFsnbW9kZWwnLCAnY29sbGVjdGlvbicsICdlbCcsICdpZCcsICdhdHRyaWJ1dGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICdjbGFzc05hbWUnLCAndGFnTmFtZSddO1xuXG4gIC8vIFNldCB1cCBhbGwgaW5oZXJpdGFibGUgKipBVi5WaWV3KiogcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cbiAgXy5leHRlbmQoQVYuVmlldy5wcm90b3R5cGUsIEFWLkV2ZW50cyxcbiAgICAgICAgICAgLyoqIEBsZW5kcyBBVi5WaWV3LnByb3RvdHlwZSAqLyB7XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBgdGFnTmFtZWAgb2YgYSBWaWV3J3MgZWxlbWVudCBpcyBgXCJkaXZcImAuXG4gICAgdGFnTmFtZTogJ2RpdicsXG5cbiAgICAvKipcbiAgICAgKiBqUXVlcnkgZGVsZWdhdGUgZm9yIGVsZW1lbnQgbG9va3VwLCBzY29wZWQgdG8gRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGVcbiAgICAgKiBjdXJyZW50IHZpZXcuIFRoaXMgc2hvdWxkIGJlIHByZWZlcmVkIHRvIGdsb2JhbCBsb29rdXBzIHdoZXJlIHBvc3NpYmxlLlxuICAgICAqL1xuICAgICQ6IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gICAgICByZXR1cm4gdGhpcy4kZWwuZmluZChzZWxlY3Rvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgaXMgYW4gZW1wdHkgZnVuY3Rpb24gYnkgZGVmYXVsdC4gT3ZlcnJpZGUgaXQgd2l0aCB5b3VyIG93blxuICAgICAqIGluaXRpYWxpemF0aW9uIGxvZ2ljLlxuICAgICAqL1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCl7fSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBjb3JlIGZ1bmN0aW9uIHRoYXQgeW91ciB2aWV3IHNob3VsZCBvdmVycmlkZSwgaW4gb3JkZXJcbiAgICAgKiB0byBwb3B1bGF0ZSBpdHMgZWxlbWVudCAoYHRoaXMuZWxgKSwgd2l0aCB0aGUgYXBwcm9wcmlhdGUgSFRNTC4gVGhlXG4gICAgICogY29udmVudGlvbiBpcyBmb3IgKipyZW5kZXIqKiB0byBhbHdheXMgcmV0dXJuIGB0aGlzYC5cbiAgICAgKi9cbiAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSB0aGlzIHZpZXcgZnJvbSB0aGUgRE9NLiBOb3RlIHRoYXQgdGhlIHZpZXcgaXNuJ3QgcHJlc2VudCBpbiB0aGVcbiAgICAgKiBET00gYnkgZGVmYXVsdCwgc28gY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgYmUgYSBuby1vcC5cbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy4kZWwucmVtb3ZlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRm9yIHNtYWxsIGFtb3VudHMgb2YgRE9NIEVsZW1lbnRzLCB3aGVyZSBhIGZ1bGwtYmxvd24gdGVtcGxhdGUgaXNuJ3RcbiAgICAgKiBuZWVkZWQsIHVzZSAqKm1ha2UqKiB0byBtYW51ZmFjdHVyZSBlbGVtZW50cywgb25lIGF0IGEgdGltZS5cbiAgICAgKiA8cHJlPlxuICAgICAqICAgICB2YXIgZWwgPSB0aGlzLm1ha2UoJ2xpJywgeydjbGFzcyc6ICdyb3cnfSxcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kZWwuZXNjYXBlKCd0aXRsZScpKTs8L3ByZT5cbiAgICAgKi9cbiAgICBtYWtlOiBmdW5jdGlvbih0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjb250ZW50KSB7XG4gICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgICAgaWYgKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgQVYuJChlbCkuYXR0cihhdHRyaWJ1dGVzKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb250ZW50KSB7XG4gICAgICAgIEFWLiQoZWwpLmh0bWwoY29udGVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENoYW5nZXMgdGhlIHZpZXcncyBlbGVtZW50IChgdGhpcy5lbGAgcHJvcGVydHkpLCBpbmNsdWRpbmcgZXZlbnRcbiAgICAgKiByZS1kZWxlZ2F0aW9uLlxuICAgICAqL1xuICAgIHNldEVsZW1lbnQ6IGZ1bmN0aW9uKGVsZW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgICB0aGlzLiRlbCA9IEFWLiQoZWxlbWVudCk7XG4gICAgICB0aGlzLmVsID0gdGhpcy4kZWxbMF07XG4gICAgICBpZiAoZGVsZWdhdGUgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgY2FsbGJhY2tzLiAgPGNvZGU+dGhpcy5ldmVudHM8L2NvZGU+IGlzIGEgaGFzaCBvZlxuICAgICAqIDxwcmU+XG4gICAgICogKntcImV2ZW50IHNlbGVjdG9yXCI6IFwiY2FsbGJhY2tcIn0qXG4gICAgICpcbiAgICAgKiAgICAge1xuICAgICAqICAgICAgICdtb3VzZWRvd24gLnRpdGxlJzogICdlZGl0JyxcbiAgICAgKiAgICAgICAnY2xpY2sgLmJ1dHRvbic6ICAgICAnc2F2ZSdcbiAgICAgKiAgICAgICAnY2xpY2sgLm9wZW4nOiAgICAgICBmdW5jdGlvbihlKSB7IC4uLiB9XG4gICAgICogICAgIH1cbiAgICAgKiA8L3ByZT5cbiAgICAgKiBwYWlycy4gQ2FsbGJhY2tzIHdpbGwgYmUgYm91bmQgdG8gdGhlIHZpZXcsIHdpdGggYHRoaXNgIHNldCBwcm9wZXJseS5cbiAgICAgKiBVc2VzIGV2ZW50IGRlbGVnYXRpb24gZm9yIGVmZmljaWVuY3kuXG4gICAgICogT21pdHRpbmcgdGhlIHNlbGVjdG9yIGJpbmRzIHRoZSBldmVudCB0byBgdGhpcy5lbGAuXG4gICAgICogVGhpcyBvbmx5IHdvcmtzIGZvciBkZWxlZ2F0ZS1hYmxlIGV2ZW50czogbm90IGBmb2N1c2AsIGBibHVyYCwgYW5kXG4gICAgICogbm90IGBjaGFuZ2VgLCBgc3VibWl0YCwgYW5kIGByZXNldGAgaW4gSW50ZXJuZXQgRXhwbG9yZXIuXG4gICAgICovXG4gICAgZGVsZWdhdGVFdmVudHM6IGZ1bmN0aW9uKGV2ZW50cykge1xuICAgICAgZXZlbnRzID0gZXZlbnRzIHx8IEFWLl9nZXRWYWx1ZSh0aGlzLCAnZXZlbnRzJyk7XG4gICAgICBpZiAoIWV2ZW50cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnVuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgIEFWLl9vYmplY3RFYWNoKGV2ZW50cywgZnVuY3Rpb24obWV0aG9kLCBrZXkpIHtcbiAgICAgICAgaWYgKCFfLmlzRnVuY3Rpb24obWV0aG9kKSkge1xuICAgICAgICAgIG1ldGhvZCA9IHNlbGZbZXZlbnRzW2tleV1dO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbWV0aG9kKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudCBcIicgKyBldmVudHNba2V5XSArICdcIiBkb2VzIG5vdCBleGlzdCcpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaCA9IGtleS5tYXRjaChldmVudFNwbGl0dGVyKTtcbiAgICAgICAgdmFyIGV2ZW50TmFtZSA9IG1hdGNoWzFdLCBzZWxlY3RvciA9IG1hdGNoWzJdO1xuICAgICAgICBtZXRob2QgPSBfLmJpbmQobWV0aG9kLCBzZWxmKTtcbiAgICAgICAgZXZlbnROYW1lICs9ICcuZGVsZWdhdGVFdmVudHMnICsgc2VsZi5jaWQ7XG4gICAgICAgIGlmIChzZWxlY3RvciA9PT0gJycpIHtcbiAgICAgICAgICBzZWxmLiRlbC5iaW5kKGV2ZW50TmFtZSwgbWV0aG9kKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWxmLiRlbC5kZWxlZ2F0ZShzZWxlY3RvciwgZXZlbnROYW1lLCBtZXRob2QpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGFsbCBjYWxsYmFja3MgcHJldmlvdXNseSBib3VuZCB0byB0aGUgdmlldyB3aXRoIGBkZWxlZ2F0ZUV2ZW50c2AuXG4gICAgICogWW91IHVzdWFsbHkgZG9uJ3QgbmVlZCB0byB1c2UgdGhpcywgYnV0IG1heSB3aXNoIHRvIGlmIHlvdSBoYXZlIG11bHRpcGxlXG4gICAgICogQmFja2JvbmUgdmlld3MgYXR0YWNoZWQgdG8gdGhlIHNhbWUgRE9NIGVsZW1lbnQuXG4gICAgICovXG4gICAgdW5kZWxlZ2F0ZUV2ZW50czogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLiRlbC51bmJpbmQoJy5kZWxlZ2F0ZUV2ZW50cycgKyB0aGlzLmNpZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSBpbml0aWFsIGNvbmZpZ3VyYXRpb24gb2YgYSBWaWV3IHdpdGggYSBzZXQgb2Ygb3B0aW9ucy5cbiAgICAgKiBLZXlzIHdpdGggc3BlY2lhbCBtZWFuaW5nICoobW9kZWwsIGNvbGxlY3Rpb24sIGlkLCBjbGFzc05hbWUpKiwgYXJlXG4gICAgICogYXR0YWNoZWQgZGlyZWN0bHkgdG8gdGhlIHZpZXcuXG4gICAgICovXG4gICAgX2NvbmZpZ3VyZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gXy5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICBfLmVhY2godmlld09wdGlvbnMsIGZ1bmN0aW9uKGF0dHIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnNbYXR0cl0pIHtcbiAgICAgICAgICBzZWxmW2F0dHJdID0gb3B0aW9uc1thdHRyXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbnN1cmUgdGhhdCB0aGUgVmlldyBoYXMgYSBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICAgKiBJZiBgdGhpcy5lbGAgaXMgYSBzdHJpbmcsIHBhc3MgaXQgdGhyb3VnaCBgJCgpYCwgdGFrZSB0aGUgZmlyc3RcbiAgICAgKiBtYXRjaGluZyBlbGVtZW50LCBhbmQgcmUtYXNzaWduIGl0IHRvIGBlbGAuIE90aGVyd2lzZSwgY3JlYXRlXG4gICAgICogYW4gZWxlbWVudCBmcm9tIHRoZSBgaWRgLCBgY2xhc3NOYW1lYCBhbmQgYHRhZ05hbWVgIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgX2Vuc3VyZUVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmVsKSB7XG4gICAgICAgIHZhciBhdHRycyA9IEFWLl9nZXRWYWx1ZSh0aGlzLCAnYXR0cmlidXRlcycpIHx8IHt9O1xuICAgICAgICBpZiAodGhpcy5pZCkge1xuICAgICAgICAgIGF0dHJzLmlkID0gdGhpcy5pZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jbGFzc05hbWUpIHtcbiAgICAgICAgICBhdHRyc1snY2xhc3MnXSA9IHRoaXMuY2xhc3NOYW1lO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudCh0aGlzLm1ha2UodGhpcy50YWdOYW1lLCBhdHRycyksIGZhbHNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0RWxlbWVudCh0aGlzLmVsLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBAZnVuY3Rpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlUHJvcHMgSW5zdGFuY2UgcHJvcGVydGllcyBmb3IgdGhlIHZpZXcuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjbGFzc1Byb3BzIENsYXNzIHByb3BlcmllcyBmb3IgdGhlIHZpZXcuXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIG5ldyBzdWJjbGFzcyBvZiA8Y29kZT5BVi5WaWV3PC9jb2RlPi5cbiAgICovXG4gIEFWLlZpZXcuZXh0ZW5kID0gQVYuX2V4dGVuZDtcblxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJvTWZwQW5cIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi8uLi8uLi9ub2RlX21vZHVsZXMvYXZvc2Nsb3VkLXNkay9saWIvdmlldy5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbihmdW5jdGlvbihyb290KSB7XG4gIHZhciBsb2NhbFN0b3JhZ2VNZW1vcnkgPSB7fTtcbiAgdmFyIGNhY2hlID0ge307XG5cbiAgLyoqXG4gICAqIG51bWJlciBvZiBzdG9yZWQgaXRlbXMuXG4gICAqL1xuICBsb2NhbFN0b3JhZ2VNZW1vcnkubGVuZ3RoID0gMDtcblxuICAvKipcbiAgICogcmV0dXJucyBpdGVtIGZvciBwYXNzZWQga2V5LCBvciBudWxsXG4gICAqXG4gICAqIEBwYXJhIHtTdHJpbmd9IGtleVxuICAgKiAgICAgICBuYW1lIG9mIGl0ZW0gdG8gYmUgcmV0dXJuZWRcbiAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgKi9cbiAgbG9jYWxTdG9yYWdlTWVtb3J5LmdldEl0ZW0gPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gY2FjaGVba2V5XSB8fCBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAgKiBzZXRzIGl0ZW0gZm9yIGtleSB0byBwYXNzZWQgdmFsdWUsIGFzIFN0cmluZ1xuICAgKlxuICAgKiBAcGFyYSB7U3RyaW5nfSBrZXlcbiAgICogICAgICAgbmFtZSBvZiBpdGVtIHRvIGJlIHNldFxuICAgKiBAcGFyYSB7U3RyaW5nfSB2YWx1ZVxuICAgKiAgICAgICB2YWx1ZSwgd2lsbCBhbHdheXMgYmUgdHVybmVkIGludG8gYSBTdHJpbmdcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGxvY2FsU3RvcmFnZU1lbW9yeS5zZXRJdGVtID0gZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBsb2NhbFN0b3JhZ2VNZW1vcnkucmVtb3ZlSXRlbShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWNoZVtrZXldID0gJycgKyB2YWx1ZTtcbiAgICAgIGxvY2FsU3RvcmFnZU1lbW9yeS5sZW5ndGgrKztcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIHJlbW92ZXMgaXRlbSBmb3IgcGFzc2VkIGtleVxuICAgKlxuICAgKiBAcGFyYSB7U3RyaW5nfSBrZXlcbiAgICogICAgICAgbmFtZSBvZiBpdGVtIHRvIGJlIHJlbW92ZWRcbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGxvY2FsU3RvcmFnZU1lbW9yeS5yZW1vdmVJdGVtID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgZGVsZXRlIGNhY2hlW2tleV07XG4gICAgbG9jYWxTdG9yYWdlTWVtb3J5Lmxlbmd0aC0tO1xuICB9O1xuXG4gIC8qKlxuICAgKiByZXR1cm5zIG5hbWUgb2Yga2V5IGF0IHBhc3NlZCBpbmRleFxuICAgKlxuICAgKiBAcGFyYSB7TnVtYmVyfSBpbmRleFxuICAgKiAgICAgICBQb3NpdGlvbiBmb3Iga2V5IHRvIGJlIHJldHVybmVkIChzdGFydHMgYXQgMClcbiAgICogQHJldHVybnMge1N0cmluZ3xudWxsfVxuICAgKi9cbiAgbG9jYWxTdG9yYWdlTWVtb3J5LmtleSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGNhY2hlKVtpbmRleF0gfHwgbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogcmVtb3ZlcyBhbGwgc3RvcmVkIGl0ZW1zIGFuZCBzZXRzIGxlbmd0aCB0byAwXG4gICAqXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBsb2NhbFN0b3JhZ2VNZW1vcnkuY2xlYXIgPSBmdW5jdGlvbigpIHtcbiAgICBjYWNoZSA9IHt9O1xuICAgIGxvY2FsU3RvcmFnZU1lbW9yeS5sZW5ndGggPSAwO1xuICB9O1xuXG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGxvY2FsU3RvcmFnZU1lbW9yeTtcbiAgfSBlbHNlIHtcbiAgICByb290LmxvY2FsU3RvcmFnZU1lbW9yeSA9IGxvY2FsU3RvcmFnZU1lbW9yeTtcbiAgfVxufSkodGhpcyk7XG5cblxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL25vZGVfbW9kdWxlcy9sb2NhbHN0b3JhZ2UtbWVtb3J5L2xpYi9sb2NhbHN0b3JhZ2UtbWVtb3J5LmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbm9kZV9tb2R1bGVzL2xvY2Fsc3RvcmFnZS1tZW1vcnkvbGliXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuLy8gICAgIFVuZGVyc2NvcmUuanMgMS44LjNcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVDcmVhdGUgICAgICAgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjguMyc7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQSBtb3N0bHktaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWRcbiAgLy8gdG8gZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgdW5kZWZpbmVkT25seSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCF1bmRlZmluZWRPbmx5IHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgcHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIC8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgZ2V0TGVuZ3RoID0gcHJvcGVydHkoJ2xlbmd0aCcpO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAgIC8vIE9wdGltaXplZCBpdGVyYXRvciBmdW5jdGlvbiBhcyB1c2luZyBhcmd1bWVudHMubGVuZ3RoXG4gICAgLy8gaW4gdGhlIG1haW4gZnVuY3Rpb24gd2lsbCBkZW9wdGltaXplIHRoZSwgc2VlICMxOTkxLlxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIC8vIERldGVybWluZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBrZXkgPSBfLmZpbmRJbmRleChvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IF8uZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IC0xKSByZXR1cm4gb2JqW2tleV07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgaXRlbSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCBndWFyZCkgZnJvbUluZGV4ID0gMDtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgaXRlbSwgZnJvbUluZGV4KSA+PSAwO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbiwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzZXQgPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgcmFuZDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSBzZXRbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgc3RhcnRJbmRleCkge1xuICAgIHZhciBvdXRwdXQgPSBbXSwgaWR4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcbiAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bnppcChhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzXG4gIF8udW56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgZ2V0TGVuZ3RoKS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGxpc3QpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKDEpO1xuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgaW5kZXhPZiBhbmQgbGFzdEluZGV4T2YgZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggPSBpZHggPj0gMCA/IE1hdGgubWluKGlkeCArIDEsIGxlbmd0aCkgOiBpZHggKyBsZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZEluZGV4ICYmIGlkeCAmJiBsZW5ndGgpIHtcbiAgICAgICAgaWR4ID0gc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaWR4XSA9PT0gaXRlbSA/IGlkeCA6IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgaWR4ID0gcHJlZGljYXRlRmluZChzbGljZS5jYWxsKGFycmF5LCBpLCBsZW5ndGgpLCBfLmlzTmFOKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwID8gaWR4ICsgaSA6IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChpZHggPSBkaXIgPiAwID8gaSA6IGxlbmd0aCAtIDE7IGlkeCA+PSAwICYmIGlkeCA8IGxlbmd0aDsgaWR4ICs9IGRpcikge1xuICAgICAgICBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgXy5maW5kSW5kZXgsIF8uc29ydGVkSW5kZXgpO1xuICBfLmxhc3RJbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEsIF8uZmluZExhc3RJbmRleCk7XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3RcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgIGN1cnJlbnRLZXk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKVxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIF8uZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cblxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvciddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXG4gIC8vIElFIDExICgjMTYyMSksIGFuZCBpbiBTYWZhcmkgOCAoIzE5MjkpLlxuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBfLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZlxuICAvLyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBmYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2F2b3NjbG91ZC1zZGsvbm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9hdm9zY2xvdWQtc2RrL25vZGVfbW9kdWxlcy91bmRlcnNjb3JlXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZVwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTJcblxuLyoqXG4gKiBJZiBgQnVmZmVyLl91c2VUeXBlZEFycmF5c2A6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBVc2UgT2JqZWN0IGltcGxlbWVudGF0aW9uIChjb21wYXRpYmxlIGRvd24gdG8gSUU2KVxuICovXG5CdWZmZXIuX3VzZVR5cGVkQXJyYXlzID0gKGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IGlmIGJyb3dzZXIgc3VwcG9ydHMgVHlwZWQgQXJyYXlzLiBTdXBwb3J0ZWQgYnJvd3NlcnMgYXJlIElFIDEwKywgRmlyZWZveCA0KyxcbiAgLy8gQ2hyb21lIDcrLCBTYWZhcmkgNS4xKywgT3BlcmEgMTEuNissIGlPUyA0LjIrLiBJZiB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGFkZGluZ1xuICAvLyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YCBpbnN0YW5jZXMsIHRoZW4gdGhhdCdzIHRoZSBzYW1lIGFzIG5vIGBVaW50OEFycmF5YCBzdXBwb3J0XG4gIC8vIGJlY2F1c2Ugd2UgbmVlZCB0byBiZSBhYmxlIHRvIGFkZCBhbGwgdGhlIG5vZGUgQnVmZmVyIEFQSSBtZXRob2RzLiBUaGlzIGlzIGFuIGlzc3VlXG4gIC8vIGluIEZpcmVmb3ggNC0yOS4gTm93IGZpeGVkOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzhcbiAgdHJ5IHtcbiAgICB2YXIgYnVmID0gbmV3IEFycmF5QnVmZmVyKDApXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KGJ1ZilcbiAgICBhcnIuZm9vID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfVxuICAgIHJldHVybiA0MiA9PT0gYXJyLmZvbygpICYmXG4gICAgICAgIHR5cGVvZiBhcnIuc3ViYXJyYXkgPT09ICdmdW5jdGlvbicgLy8gQ2hyb21lIDktMTAgbGFjayBgc3ViYXJyYXlgXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufSkoKVxuXG4vKipcbiAqIENsYXNzOiBCdWZmZXJcbiAqID09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGFyZSBhdWdtZW50ZWRcbiAqIHdpdGggZnVuY3Rpb24gcHJvcGVydGllcyBmb3IgYWxsIHRoZSBub2RlIGBCdWZmZXJgIEFQSSBmdW5jdGlvbnMuIFdlIHVzZVxuICogYFVpbnQ4QXJyYXlgIHNvIHRoYXQgc3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXQgcmV0dXJuc1xuICogYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogQnkgYXVnbWVudGluZyB0aGUgaW5zdGFuY2VzLCB3ZSBjYW4gYXZvaWQgbW9kaWZ5aW5nIHRoZSBgVWludDhBcnJheWBcbiAqIHByb3RvdHlwZS5cbiAqL1xuZnVuY3Rpb24gQnVmZmVyIChzdWJqZWN0LCBlbmNvZGluZywgbm9aZXJvKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCdWZmZXIpKVxuICAgIHJldHVybiBuZXcgQnVmZmVyKHN1YmplY3QsIGVuY29kaW5nLCBub1plcm8pXG5cbiAgdmFyIHR5cGUgPSB0eXBlb2Ygc3ViamVjdFxuXG4gIC8vIFdvcmthcm91bmQ6IG5vZGUncyBiYXNlNjQgaW1wbGVtZW50YXRpb24gYWxsb3dzIGZvciBub24tcGFkZGVkIHN0cmluZ3NcbiAgLy8gd2hpbGUgYmFzZTY0LWpzIGRvZXMgbm90LlxuICBpZiAoZW5jb2RpbmcgPT09ICdiYXNlNjQnICYmIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgc3ViamVjdCA9IHN0cmluZ3RyaW0oc3ViamVjdClcbiAgICB3aGlsZSAoc3ViamVjdC5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgICBzdWJqZWN0ID0gc3ViamVjdCArICc9J1xuICAgIH1cbiAgfVxuXG4gIC8vIEZpbmQgdGhlIGxlbmd0aFxuICB2YXIgbGVuZ3RoXG4gIGlmICh0eXBlID09PSAnbnVtYmVyJylcbiAgICBsZW5ndGggPSBjb2VyY2Uoc3ViamVjdClcbiAgZWxzZSBpZiAodHlwZSA9PT0gJ3N0cmluZycpXG4gICAgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoc3ViamVjdCwgZW5jb2RpbmcpXG4gIGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKVxuICAgIGxlbmd0aCA9IGNvZXJjZShzdWJqZWN0Lmxlbmd0aCkgLy8gYXNzdW1lIHRoYXQgb2JqZWN0IGlzIGFycmF5LWxpa2VcbiAgZWxzZVxuICAgIHRocm93IG5ldyBFcnJvcignRmlyc3QgYXJndW1lbnQgbmVlZHMgdG8gYmUgYSBudW1iZXIsIGFycmF5IG9yIHN0cmluZy4nKVxuXG4gIHZhciBidWZcbiAgaWYgKEJ1ZmZlci5fdXNlVHlwZWRBcnJheXMpIHtcbiAgICAvLyBQcmVmZXJyZWQ6IFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgYnVmID0gQnVmZmVyLl9hdWdtZW50KG5ldyBVaW50OEFycmF5KGxlbmd0aCkpXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBUSElTIGluc3RhbmNlIG9mIEJ1ZmZlciAoY3JlYXRlZCBieSBgbmV3YClcbiAgICBidWYgPSB0aGlzXG4gICAgYnVmLmxlbmd0aCA9IGxlbmd0aFxuICAgIGJ1Zi5faXNCdWZmZXIgPSB0cnVlXG4gIH1cblxuICB2YXIgaVxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cyAmJiB0eXBlb2Ygc3ViamVjdC5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgIC8vIFNwZWVkIG9wdGltaXphdGlvbiAtLSB1c2Ugc2V0IGlmIHdlJ3JlIGNvcHlpbmcgZnJvbSBhIHR5cGVkIGFycmF5XG4gICAgYnVmLl9zZXQoc3ViamVjdClcbiAgfSBlbHNlIGlmIChpc0FycmF5aXNoKHN1YmplY3QpKSB7XG4gICAgLy8gVHJlYXQgYXJyYXktaXNoIG9iamVjdHMgYXMgYSBieXRlIGFycmF5XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpKVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0LnJlYWRVSW50OChpKVxuICAgICAgZWxzZVxuICAgICAgICBidWZbaV0gPSBzdWJqZWN0W2ldXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgYnVmLndyaXRlKHN1YmplY3QsIDAsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzICYmICFub1plcm8pIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbi8vIFNUQVRJQyBNRVRIT0RTXG4vLyA9PT09PT09PT09PT09PVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAncmF3JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gKGIpIHtcbiAgcmV0dXJuICEhKGIgIT09IG51bGwgJiYgYiAhPT0gdW5kZWZpbmVkICYmIGIuX2lzQnVmZmVyKVxufVxuXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIChzdHIsIGVuY29kaW5nKSB7XG4gIHZhciByZXRcbiAgc3RyID0gc3RyICsgJydcbiAgc3dpdGNoIChlbmNvZGluZyB8fCAndXRmOCcpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgICAgcmV0ID0gc3RyLmxlbmd0aCAvIDJcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgICAgcmV0ID0gdXRmOFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAncmF3JzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IGJhc2U2NFRvQnl0ZXMoc3RyKS5sZW5ndGhcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldCA9IHN0ci5sZW5ndGggKiAyXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2RpbmcnKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBhc3NlcnQoaXNBcnJheShsaXN0KSwgJ1VzYWdlOiBCdWZmZXIuY29uY2F0KGxpc3QsIFt0b3RhbExlbmd0aF0pXFxuJyArXG4gICAgICAnbGlzdCBzaG91bGQgYmUgYW4gQXJyYXkuJylcblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcigwKVxuICB9IGVsc2UgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGxpc3RbMF1cbiAgfVxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdG90YWxMZW5ndGggIT09ICdudW1iZXInKSB7XG4gICAgdG90YWxMZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZiA9IG5ldyBCdWZmZXIodG90YWxMZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldXG4gICAgaXRlbS5jb3B5KGJ1ZiwgcG9zKVxuICAgIHBvcyArPSBpdGVtLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZcbn1cblxuLy8gQlVGRkVSIElOU1RBTkNFIE1FVEhPRFNcbi8vID09PT09PT09PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIF9oZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGFzc2VydChzdHJMZW4gJSAyID09PSAwLCAnSW52YWxpZCBoZXggc3RyaW5nJylcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGJ5dGUgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgYXNzZXJ0KCFpc05hTihieXRlKSwgJ0ludmFsaWQgaGV4IHN0cmluZycpXG4gICAgYnVmW29mZnNldCArIGldID0gYnl0ZVxuICB9XG4gIEJ1ZmZlci5fY2hhcnNXcml0dGVuID0gaSAqIDJcbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gX3V0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9hc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIGNoYXJzV3JpdHRlbiA9IEJ1ZmZlci5fY2hhcnNXcml0dGVuID1cbiAgICBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBfYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG4gIHJldHVybiBjaGFyc1dyaXR0ZW5cbn1cblxuZnVuY3Rpb24gX3V0ZjE2bGVXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHZhciBjaGFyc1dyaXR0ZW4gPSBCdWZmZXIuX2NoYXJzV3JpdHRlbiA9XG4gICAgYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxuICByZXR1cm4gY2hhcnNXcml0dGVuXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gU3VwcG9ydCBib3RoIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZylcbiAgLy8gYW5kIHRoZSBsZWdhY3kgKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIGlmICghaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHsgIC8vIGxlZ2FjeVxuICAgIHZhciBzd2FwID0gZW5jb2RpbmdcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIG9mZnNldCA9IGxlbmd0aFxuICAgIGxlbmd0aCA9IHN3YXBcbiAgfVxuXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG5cbiAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcgfHwgJ3V0ZjgnKS50b0xvd2VyQ2FzZSgpXG4gIHN0YXJ0ID0gTnVtYmVyKHN0YXJ0KSB8fCAwXG4gIGVuZCA9IChlbmQgIT09IHVuZGVmaW5lZClcbiAgICA/IE51bWJlcihlbmQpXG4gICAgOiBlbmQgPSBzZWxmLmxlbmd0aFxuXG4gIC8vIEZhc3RwYXRoIGVtcHR5IHN0cmluZ3NcbiAgaWYgKGVuZCA9PT0gc3RhcnQpXG4gICAgcmV0dXJuICcnXG5cbiAgdmFyIHJldFxuICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICAgIHJldCA9IF9oZXhTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgICByZXQgPSBfdXRmOFNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIHJldCA9IF9hc2NpaVNsaWNlKHNlbGYsIHN0YXJ0LCBlbmQpXG4gICAgICBicmVha1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXQgPSBfYmluYXJ5U2xpY2Uoc2VsZiwgc3RhcnQsIGVuZClcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHJldCA9IF9iYXNlNjRTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0ID0gX3V0ZjE2bGVTbGljZShzZWxmLCBzdGFydCwgZW5kKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nJylcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uICh0YXJnZXQsIHRhcmdldF9zdGFydCwgc3RhcnQsIGVuZCkge1xuICB2YXIgc291cmNlID0gdGhpc1xuXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICghdGFyZ2V0X3N0YXJ0KSB0YXJnZXRfc3RhcnQgPSAwXG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgc291cmNlLmxlbmd0aCA9PT0gMCkgcmV0dXJuXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBhc3NlcnQoZW5kID49IHN0YXJ0LCAnc291cmNlRW5kIDwgc291cmNlU3RhcnQnKVxuICBhc3NlcnQodGFyZ2V0X3N0YXJ0ID49IDAgJiYgdGFyZ2V0X3N0YXJ0IDwgdGFyZ2V0Lmxlbmd0aCxcbiAgICAgICd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgYXNzZXJ0KHN0YXJ0ID49IDAgJiYgc3RhcnQgPCBzb3VyY2UubGVuZ3RoLCAnc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gc291cmNlLmxlbmd0aCwgJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpXG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRfc3RhcnQgPCBlbmQgLSBzdGFydClcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0X3N0YXJ0ICsgc3RhcnRcblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAobGVuIDwgMTAwIHx8ICFCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0X3N0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5fc2V0KHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSwgdGFyZ2V0X3N0YXJ0KVxuICB9XG59XG5cbmZ1bmN0aW9uIF9iYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gX3V0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXMgPSAnJ1xuICB2YXIgdG1wID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgaWYgKGJ1ZltpXSA8PSAweDdGKSB7XG4gICAgICByZXMgKz0gZGVjb2RlVXRmOENoYXIodG1wKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICAgICAgdG1wID0gJydcbiAgICB9IGVsc2Uge1xuICAgICAgdG1wICs9ICclJyArIGJ1ZltpXS50b1N0cmluZygxNilcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzICsgZGVjb2RlVXRmOENoYXIodG1wKVxufVxuXG5mdW5jdGlvbiBfYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIF9iaW5hcnlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHJldHVybiBfYXNjaWlTbGljZShidWYsIHN0YXJ0LCBlbmQpXG59XG5cbmZ1bmN0aW9uIF9oZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIF91dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIGJ5dGVzW2krMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gY2xhbXAoc3RhcnQsIGxlbiwgMClcbiAgZW5kID0gY2xhbXAoZW5kLCBsZW4sIGxlbilcblxuICBpZiAoQnVmZmVyLl91c2VUeXBlZEFycmF5cykge1xuICAgIHJldHVybiBCdWZmZXIuX2F1Z21lbnQodGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSlcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIHZhciBuZXdCdWYgPSBuZXcgQnVmZmVyKHNsaWNlTGVuLCB1bmRlZmluZWQsIHRydWUpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzbGljZUxlbjsgaSsrKSB7XG4gICAgICBuZXdCdWZbaV0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gICAgcmV0dXJuIG5ld0J1ZlxuICB9XG59XG5cbi8vIGBnZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5nZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLnJlYWRVSW50OChvZmZzZXQpXG59XG5cbi8vIGBzZXRgIHdpbGwgYmUgcmVtb3ZlZCBpbiBOb2RlIDAuMTMrXG5CdWZmZXIucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uICh2LCBvZmZzZXQpIHtcbiAgY29uc29sZS5sb2coJy5zZXQoKSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdXNpbmcgYXJyYXkgaW5kZXhlcyBpbnN0ZWFkLicpXG4gIHJldHVybiB0aGlzLndyaXRlVUludDgodiwgb2Zmc2V0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5mdW5jdGlvbiBfcmVhZFVJbnQxNiAoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIHZhciB2YWxcbiAgaWYgKGxpdHRsZUVuZGlhbikge1xuICAgIHZhbCA9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdIDw8IDhcbiAgfSBlbHNlIHtcbiAgICB2YWwgPSBidWZbb2Zmc2V0XSA8PCA4XG4gICAgaWYgKG9mZnNldCArIDEgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDFdXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQxNih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3JlYWRVSW50MzIgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsXG4gIGlmIChsaXR0bGVFbmRpYW4pIHtcbiAgICBpZiAob2Zmc2V0ICsgMiA8IGxlbilcbiAgICAgIHZhbCA9IGJ1ZltvZmZzZXQgKyAyXSA8PCAxNlxuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsIHw9IGJ1ZltvZmZzZXQgKyAxXSA8PCA4XG4gICAgdmFsIHw9IGJ1ZltvZmZzZXRdXG4gICAgaWYgKG9mZnNldCArIDMgPCBsZW4pXG4gICAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldCArIDNdIDw8IDI0ID4+PiAwKVxuICB9IGVsc2Uge1xuICAgIGlmIChvZmZzZXQgKyAxIDwgbGVuKVxuICAgICAgdmFsID0gYnVmW29mZnNldCArIDFdIDw8IDE2XG4gICAgaWYgKG9mZnNldCArIDIgPCBsZW4pXG4gICAgICB2YWwgfD0gYnVmW29mZnNldCArIDJdIDw8IDhcbiAgICBpZiAob2Zmc2V0ICsgMyA8IGxlbilcbiAgICAgIHZhbCB8PSBidWZbb2Zmc2V0ICsgM11cbiAgICB2YWwgPSB2YWwgKyAoYnVmW29mZnNldF0gPDwgMjQgPj4+IDApXG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZFVJbnQzMih0aGlzLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLFxuICAgICAgICAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgdmFyIG5lZyA9IHRoaXNbb2Zmc2V0XSAmIDB4ODBcbiAgaWYgKG5lZylcbiAgICByZXR1cm4gKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xXG4gIGVsc2VcbiAgICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbmZ1bmN0aW9uIF9yZWFkSW50MTYgKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMSA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gcmVhZCBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICB2YXIgdmFsID0gX3JlYWRVSW50MTYoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgdHJ1ZSlcbiAgdmFyIG5lZyA9IHZhbCAmIDB4ODAwMFxuICBpZiAobmVnKVxuICAgIHJldHVybiAoMHhmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MTYodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDE2KHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEludDMyIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDMgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHJlYWQgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgdmFyIHZhbCA9IF9yZWFkVUludDMyKGJ1Ziwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIHRydWUpXG4gIHZhciBuZWcgPSB2YWwgJiAweDgwMDAwMDAwXG4gIGlmIChuZWcpXG4gICAgcmV0dXJuICgweGZmZmZmZmZmIC0gdmFsICsgMSkgKiAtMVxuICBlbHNlXG4gICAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkSW50MzIodGhpcywgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiBfcmVhZEludDMyKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfcmVhZEZsb2F0IChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiAob2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gX3JlYWRGbG9hdCh0aGlzLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRmxvYXQodGhpcywgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF9yZWFkRG91YmxlIChidWYsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgKyA3IDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byByZWFkIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgfVxuXG4gIHJldHVybiBpZWVlNzU0LnJlYWQoYnVmLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIF9yZWFkRG91YmxlKHRoaXMsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0IDwgdGhpcy5sZW5ndGgsICd0cnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmdWludCh2YWx1ZSwgMHhmZilcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHJldHVyblxuXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAxIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmYpXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBmb3IgKHZhciBpID0gMCwgaiA9IE1hdGgubWluKGxlbiAtIG9mZnNldCwgMik7IGkgPCBqOyBpKyspIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPVxuICAgICAgICAodmFsdWUgJiAoMHhmZiA8PCAoOCAqIChsaXR0bGVFbmRpYW4gPyBpIDogMSAtIGkpKSkpID4+PlxuICAgICAgICAgICAgKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkgKiA4XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ3RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZ1aW50KHZhbHVlLCAweGZmZmZmZmZmKVxuICB9XG5cbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcbiAgaWYgKG9mZnNldCA+PSBsZW4pXG4gICAgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihsZW4gLSBvZmZzZXQsIDQpOyBpIDwgajsgaSsrKSB7XG4gICAgYnVmW29mZnNldCArIGldID1cbiAgICAgICAgKHZhbHVlID4+PiAobGl0dGxlRW5kaWFuID8gaSA6IDMgLSBpKSAqIDgpICYgMHhmZlxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgPCB0aGlzLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZzaW50KHZhbHVlLCAweDdmLCAtMHg4MClcbiAgfVxuXG4gIGlmIChvZmZzZXQgPj0gdGhpcy5sZW5ndGgpXG4gICAgcmV0dXJuXG5cbiAgaWYgKHZhbHVlID49IDApXG4gICAgdGhpcy53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgdGhpcy53cml0ZVVJbnQ4KDB4ZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIF93cml0ZUludDE2IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHZhbHVlICE9PSBudWxsLCAnbWlzc2luZyB2YWx1ZScpXG4gICAgYXNzZXJ0KHR5cGVvZiBsaXR0bGVFbmRpYW4gPT09ICdib29sZWFuJywgJ21pc3Npbmcgb3IgaW52YWxpZCBlbmRpYW4nKVxuICAgIGFzc2VydChvZmZzZXQgIT09IHVuZGVmaW5lZCAmJiBvZmZzZXQgIT09IG51bGwsICdtaXNzaW5nIG9mZnNldCcpXG4gICAgYXNzZXJ0KG9mZnNldCArIDEgPCBidWYubGVuZ3RoLCAnVHJ5aW5nIHRvIHdyaXRlIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbiAgICB2ZXJpZnNpbnQodmFsdWUsIDB4N2ZmZiwgLTB4ODAwMClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGlmICh2YWx1ZSA+PSAwKVxuICAgIF93cml0ZVVJbnQxNihidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpXG4gIGVsc2VcbiAgICBfd3JpdGVVSW50MTYoYnVmLCAweGZmZmYgKyB2YWx1ZSArIDEsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIF93cml0ZUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gX3dyaXRlSW50MzIgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgMyA8IGJ1Zi5sZW5ndGgsICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmc2ludCh2YWx1ZSwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIH1cblxuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICBpZiAob2Zmc2V0ID49IGxlbilcbiAgICByZXR1cm5cblxuICBpZiAodmFsdWUgPj0gMClcbiAgICBfd3JpdGVVSW50MzIoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxuICBlbHNlXG4gICAgX3dyaXRlVUludDMyKGJ1ZiwgMHhmZmZmZmZmZiArIHZhbHVlICsgMSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBhc3NlcnQodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCwgJ21pc3NpbmcgdmFsdWUnKVxuICAgIGFzc2VydCh0eXBlb2YgbGl0dGxlRW5kaWFuID09PSAnYm9vbGVhbicsICdtaXNzaW5nIG9yIGludmFsaWQgZW5kaWFuJylcbiAgICBhc3NlcnQob2Zmc2V0ICE9PSB1bmRlZmluZWQgJiYgb2Zmc2V0ICE9PSBudWxsLCAnbWlzc2luZyBvZmZzZXQnKVxuICAgIGFzc2VydChvZmZzZXQgKyAzIDwgYnVmLmxlbmd0aCwgJ1RyeWluZyB0byB3cml0ZSBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG4gICAgdmVyaWZJRUVFNzU0KHZhbHVlLCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICBfd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiBfd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwsICdtaXNzaW5nIHZhbHVlJylcbiAgICBhc3NlcnQodHlwZW9mIGxpdHRsZUVuZGlhbiA9PT0gJ2Jvb2xlYW4nLCAnbWlzc2luZyBvciBpbnZhbGlkIGVuZGlhbicpXG4gICAgYXNzZXJ0KG9mZnNldCAhPT0gdW5kZWZpbmVkICYmIG9mZnNldCAhPT0gbnVsbCwgJ21pc3Npbmcgb2Zmc2V0JylcbiAgICBhc3NlcnQob2Zmc2V0ICsgNyA8IGJ1Zi5sZW5ndGgsXG4gICAgICAgICdUcnlpbmcgdG8gd3JpdGUgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxuICAgIHZlcmlmSUVFRTc1NCh2YWx1ZSwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG4gIGlmIChvZmZzZXQgPj0gbGVuKVxuICAgIHJldHVyblxuXG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgX3dyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gZmlsbCh2YWx1ZSwgc3RhcnQ9MCwgZW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAodmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCF2YWx1ZSkgdmFsdWUgPSAwXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCkgZW5kID0gdGhpcy5sZW5ndGhcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHZhbHVlID0gdmFsdWUuY2hhckNvZGVBdCgwKVxuICB9XG5cbiAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSwgJ3ZhbHVlIGlzIG5vdCBhIG51bWJlcicpXG4gIGFzc2VydChlbmQgPj0gc3RhcnQsICdlbmQgPCBzdGFydCcpXG5cbiAgLy8gRmlsbCAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm5cbiAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm5cblxuICBhc3NlcnQoc3RhcnQgPj0gMCAmJiBzdGFydCA8IHRoaXMubGVuZ3RoLCAnc3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGFzc2VydChlbmQgPj0gMCAmJiBlbmQgPD0gdGhpcy5sZW5ndGgsICdlbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpKyspIHtcbiAgICB0aGlzW2ldID0gdmFsdWVcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBvdXQgPSBbXVxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIG91dFtpXSA9IHRvSGV4KHRoaXNbaV0pXG4gICAgaWYgKGkgPT09IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMpIHtcbiAgICAgIG91dFtpICsgMV0gPSAnLi4uJ1xuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBvdXQuam9pbignICcpICsgJz4nXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBgQXJyYXlCdWZmZXJgIHdpdGggdGhlICpjb3BpZWQqIG1lbW9yeSBvZiB0aGUgYnVmZmVyIGluc3RhbmNlLlxuICogQWRkZWQgaW4gTm9kZSAwLjEyLiBPbmx5IGF2YWlsYWJsZSBpbiBicm93c2VycyB0aGF0IHN1cHBvcnQgQXJyYXlCdWZmZXIuXG4gKi9cbkJ1ZmZlci5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmIChCdWZmZXIuX3VzZVR5cGVkQXJyYXlzKSB7XG4gICAgICByZXR1cm4gKG5ldyBCdWZmZXIodGhpcykpLmJ1ZmZlclxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5sZW5ndGgpXG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gYnVmLmxlbmd0aDsgaSA8IGxlbjsgaSArPSAxKVxuICAgICAgICBidWZbaV0gPSB0aGlzW2ldXG4gICAgICByZXR1cm4gYnVmLmJ1ZmZlclxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlci50b0FycmF5QnVmZmVyIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyJylcbiAgfVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIHN0cmluZ3RyaW0gKHN0cikge1xuICBpZiAoc3RyLnRyaW0pIHJldHVybiBzdHIudHJpbSgpXG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpXG59XG5cbnZhciBCUCA9IEJ1ZmZlci5wcm90b3R5cGVcblxuLyoqXG4gKiBBdWdtZW50IGEgVWludDhBcnJheSAqaW5zdGFuY2UqIChub3QgdGhlIFVpbnQ4QXJyYXkgY2xhc3MhKSB3aXRoIEJ1ZmZlciBtZXRob2RzXG4gKi9cbkJ1ZmZlci5fYXVnbWVudCA9IGZ1bmN0aW9uIChhcnIpIHtcbiAgYXJyLl9pc0J1ZmZlciA9IHRydWVcblxuICAvLyBzYXZlIHJlZmVyZW5jZSB0byBvcmlnaW5hbCBVaW50OEFycmF5IGdldC9zZXQgbWV0aG9kcyBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgYXJyLl9nZXQgPSBhcnIuZ2V0XG4gIGFyci5fc2V0ID0gYXJyLnNldFxuXG4gIC8vIGRlcHJlY2F0ZWQsIHdpbGwgYmUgcmVtb3ZlZCBpbiBub2RlIDAuMTMrXG4gIGFyci5nZXQgPSBCUC5nZXRcbiAgYXJyLnNldCA9IEJQLnNldFxuXG4gIGFyci53cml0ZSA9IEJQLndyaXRlXG4gIGFyci50b1N0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0xvY2FsZVN0cmluZyA9IEJQLnRvU3RyaW5nXG4gIGFyci50b0pTT04gPSBCUC50b0pTT05cbiAgYXJyLmNvcHkgPSBCUC5jb3B5XG4gIGFyci5zbGljZSA9IEJQLnNsaWNlXG4gIGFyci5yZWFkVUludDggPSBCUC5yZWFkVUludDhcbiAgYXJyLnJlYWRVSW50MTZMRSA9IEJQLnJlYWRVSW50MTZMRVxuICBhcnIucmVhZFVJbnQxNkJFID0gQlAucmVhZFVJbnQxNkJFXG4gIGFyci5yZWFkVUludDMyTEUgPSBCUC5yZWFkVUludDMyTEVcbiAgYXJyLnJlYWRVSW50MzJCRSA9IEJQLnJlYWRVSW50MzJCRVxuICBhcnIucmVhZEludDggPSBCUC5yZWFkSW50OFxuICBhcnIucmVhZEludDE2TEUgPSBCUC5yZWFkSW50MTZMRVxuICBhcnIucmVhZEludDE2QkUgPSBCUC5yZWFkSW50MTZCRVxuICBhcnIucmVhZEludDMyTEUgPSBCUC5yZWFkSW50MzJMRVxuICBhcnIucmVhZEludDMyQkUgPSBCUC5yZWFkSW50MzJCRVxuICBhcnIucmVhZEZsb2F0TEUgPSBCUC5yZWFkRmxvYXRMRVxuICBhcnIucmVhZEZsb2F0QkUgPSBCUC5yZWFkRmxvYXRCRVxuICBhcnIucmVhZERvdWJsZUxFID0gQlAucmVhZERvdWJsZUxFXG4gIGFyci5yZWFkRG91YmxlQkUgPSBCUC5yZWFkRG91YmxlQkVcbiAgYXJyLndyaXRlVUludDggPSBCUC53cml0ZVVJbnQ4XG4gIGFyci53cml0ZVVJbnQxNkxFID0gQlAud3JpdGVVSW50MTZMRVxuICBhcnIud3JpdGVVSW50MTZCRSA9IEJQLndyaXRlVUludDE2QkVcbiAgYXJyLndyaXRlVUludDMyTEUgPSBCUC53cml0ZVVJbnQzMkxFXG4gIGFyci53cml0ZVVJbnQzMkJFID0gQlAud3JpdGVVSW50MzJCRVxuICBhcnIud3JpdGVJbnQ4ID0gQlAud3JpdGVJbnQ4XG4gIGFyci53cml0ZUludDE2TEUgPSBCUC53cml0ZUludDE2TEVcbiAgYXJyLndyaXRlSW50MTZCRSA9IEJQLndyaXRlSW50MTZCRVxuICBhcnIud3JpdGVJbnQzMkxFID0gQlAud3JpdGVJbnQzMkxFXG4gIGFyci53cml0ZUludDMyQkUgPSBCUC53cml0ZUludDMyQkVcbiAgYXJyLndyaXRlRmxvYXRMRSA9IEJQLndyaXRlRmxvYXRMRVxuICBhcnIud3JpdGVGbG9hdEJFID0gQlAud3JpdGVGbG9hdEJFXG4gIGFyci53cml0ZURvdWJsZUxFID0gQlAud3JpdGVEb3VibGVMRVxuICBhcnIud3JpdGVEb3VibGVCRSA9IEJQLndyaXRlRG91YmxlQkVcbiAgYXJyLmZpbGwgPSBCUC5maWxsXG4gIGFyci5pbnNwZWN0ID0gQlAuaW5zcGVjdFxuICBhcnIudG9BcnJheUJ1ZmZlciA9IEJQLnRvQXJyYXlCdWZmZXJcblxuICByZXR1cm4gYXJyXG59XG5cbi8vIHNsaWNlKHN0YXJ0LCBlbmQpXG5mdW5jdGlvbiBjbGFtcCAoaW5kZXgsIGxlbiwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIGluZGV4ID0gfn5pbmRleDsgIC8vIENvZXJjZSB0byBpbnRlZ2VyLlxuICBpZiAoaW5kZXggPj0gbGVuKSByZXR1cm4gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgaW5kZXggKz0gbGVuXG4gIGlmIChpbmRleCA+PSAwKSByZXR1cm4gaW5kZXhcbiAgcmV0dXJuIDBcbn1cblxuZnVuY3Rpb24gY29lcmNlIChsZW5ndGgpIHtcbiAgLy8gQ29lcmNlIGxlbmd0aCB0byBhIG51bWJlciAocG9zc2libHkgTmFOKSwgcm91bmQgdXBcbiAgLy8gaW4gY2FzZSBpdCdzIGZyYWN0aW9uYWwgKGUuZy4gMTIzLjQ1NikgdGhlbiBkbyBhXG4gIC8vIGRvdWJsZSBuZWdhdGUgdG8gY29lcmNlIGEgTmFOIHRvIDAuIEVhc3ksIHJpZ2h0P1xuICBsZW5ndGggPSB+fk1hdGguY2VpbCgrbGVuZ3RoKVxuICByZXR1cm4gbGVuZ3RoIDwgMCA/IDAgOiBsZW5ndGhcbn1cblxuZnVuY3Rpb24gaXNBcnJheSAoc3ViamVjdCkge1xuICByZXR1cm4gKEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHN1YmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN1YmplY3QpID09PSAnW29iamVjdCBBcnJheV0nXG4gIH0pKHN1YmplY3QpXG59XG5cbmZ1bmN0aW9uIGlzQXJyYXlpc2ggKHN1YmplY3QpIHtcbiAgcmV0dXJuIGlzQXJyYXkoc3ViamVjdCkgfHwgQnVmZmVyLmlzQnVmZmVyKHN1YmplY3QpIHx8XG4gICAgICBzdWJqZWN0ICYmIHR5cGVvZiBzdWJqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgdHlwZW9mIHN1YmplY3QubGVuZ3RoID09PSAnbnVtYmVyJ1xufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGIgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGlmIChiIDw9IDB4N0YpXG4gICAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSlcbiAgICBlbHNlIHtcbiAgICAgIHZhciBzdGFydCA9IGlcbiAgICAgIGlmIChiID49IDB4RDgwMCAmJiBiIDw9IDB4REZGRikgaSsrXG4gICAgICB2YXIgaCA9IGVuY29kZVVSSUNvbXBvbmVudChzdHIuc2xpY2Uoc3RhcnQsIGkrMSkpLnN1YnN0cigxKS5zcGxpdCgnJScpXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGgubGVuZ3RoOyBqKyspXG4gICAgICAgIGJ5dGVBcnJheS5wdXNoKHBhcnNlSW50KGhbal0sIDE2KSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoc3RyKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgdmFyIHBvc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKVxuICAgICAgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBkZWNvZGVVdGY4Q2hhciAoc3RyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzdHIpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4RkZGRCkgLy8gVVRGIDggaW52YWxpZCBjaGFyXG4gIH1cbn1cblxuLypcbiAqIFdlIGhhdmUgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIHZhbHVlIGlzIGEgdmFsaWQgaW50ZWdlci4gVGhpcyBtZWFucyB0aGF0IGl0XG4gKiBpcyBub24tbmVnYXRpdmUuIEl0IGhhcyBubyBmcmFjdGlvbmFsIGNvbXBvbmVudCBhbmQgdGhhdCBpdCBkb2VzIG5vdFxuICogZXhjZWVkIHRoZSBtYXhpbXVtIGFsbG93ZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHZlcmlmdWludCAodmFsdWUsIG1heCkge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPj0gMCwgJ3NwZWNpZmllZCBhIG5lZ2F0aXZlIHZhbHVlIGZvciB3cml0aW5nIGFuIHVuc2lnbmVkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlIDw9IG1heCwgJ3ZhbHVlIGlzIGxhcmdlciB0aGFuIG1heGltdW0gdmFsdWUgZm9yIHR5cGUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZnNpbnQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxuICBhc3NlcnQoTWF0aC5mbG9vcih2YWx1ZSkgPT09IHZhbHVlLCAndmFsdWUgaGFzIGEgZnJhY3Rpb25hbCBjb21wb25lbnQnKVxufVxuXG5mdW5jdGlvbiB2ZXJpZklFRUU3NTQgKHZhbHVlLCBtYXgsIG1pbikge1xuICBhc3NlcnQodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJywgJ2Nhbm5vdCB3cml0ZSBhIG5vbi1udW1iZXIgYXMgYSBudW1iZXInKVxuICBhc3NlcnQodmFsdWUgPD0gbWF4LCAndmFsdWUgbGFyZ2VyIHRoYW4gbWF4aW11bSBhbGxvd2VkIHZhbHVlJylcbiAgYXNzZXJ0KHZhbHVlID49IG1pbiwgJ3ZhbHVlIHNtYWxsZXIgdGhhbiBtaW5pbXVtIGFsbG93ZWQgdmFsdWUnKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHRlc3QsIG1lc3NhZ2UpIHtcbiAgaWYgKCF0ZXN0KSB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSB8fCAnRmFpbGVkIGFzc2VydGlvbicpXG59XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzXCIsXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyXCIpIiwiKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCxCdWZmZXIsX19hcmd1bWVudDAsX19hcmd1bWVudDEsX19hcmd1bWVudDIsX19hcmd1bWVudDMsX19maWxlbmFtZSxfX2Rpcm5hbWUpe1xudmFyIGxvb2t1cCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblxuOyhmdW5jdGlvbiAoZXhwb3J0cykge1xuXHQndXNlIHN0cmljdCc7XG5cbiAgdmFyIEFyciA9ICh0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgPyBVaW50OEFycmF5XG4gICAgOiBBcnJheVxuXG5cdHZhciBQTFVTICAgPSAnKycuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0ggID0gJy8nLmNoYXJDb2RlQXQoMClcblx0dmFyIE5VTUJFUiA9ICcwJy5jaGFyQ29kZUF0KDApXG5cdHZhciBMT1dFUiAgPSAnYScuY2hhckNvZGVBdCgwKVxuXHR2YXIgVVBQRVIgID0gJ0EnLmNoYXJDb2RlQXQoMClcblx0dmFyIFBMVVNfVVJMX1NBRkUgPSAnLScuY2hhckNvZGVBdCgwKVxuXHR2YXIgU0xBU0hfVVJMX1NBRkUgPSAnXycuY2hhckNvZGVBdCgwKVxuXG5cdGZ1bmN0aW9uIGRlY29kZSAoZWx0KSB7XG5cdFx0dmFyIGNvZGUgPSBlbHQuY2hhckNvZGVBdCgwKVxuXHRcdGlmIChjb2RlID09PSBQTFVTIHx8XG5cdFx0ICAgIGNvZGUgPT09IFBMVVNfVVJMX1NBRkUpXG5cdFx0XHRyZXR1cm4gNjIgLy8gJysnXG5cdFx0aWYgKGNvZGUgPT09IFNMQVNIIHx8XG5cdFx0ICAgIGNvZGUgPT09IFNMQVNIX1VSTF9TQUZFKVxuXHRcdFx0cmV0dXJuIDYzIC8vICcvJ1xuXHRcdGlmIChjb2RlIDwgTlVNQkVSKVxuXHRcdFx0cmV0dXJuIC0xIC8vbm8gbWF0Y2hcblx0XHRpZiAoY29kZSA8IE5VTUJFUiArIDEwKVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBOVU1CRVIgKyAyNiArIDI2XG5cdFx0aWYgKGNvZGUgPCBVUFBFUiArIDI2KVxuXHRcdFx0cmV0dXJuIGNvZGUgLSBVUFBFUlxuXHRcdGlmIChjb2RlIDwgTE9XRVIgKyAyNilcblx0XHRcdHJldHVybiBjb2RlIC0gTE9XRVIgKyAyNlxuXHR9XG5cblx0ZnVuY3Rpb24gYjY0VG9CeXRlQXJyYXkgKGI2NCkge1xuXHRcdHZhciBpLCBqLCBsLCB0bXAsIHBsYWNlSG9sZGVycywgYXJyXG5cblx0XHRpZiAoYjY0Lmxlbmd0aCAlIDQgPiAwKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuXHRcdH1cblxuXHRcdC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXG5cdFx0Ly8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuXHRcdC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuXHRcdC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xuXHRcdC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2Vcblx0XHR2YXIgbGVuID0gYjY0Lmxlbmd0aFxuXHRcdHBsYWNlSG9sZGVycyA9ICc9JyA9PT0gYjY0LmNoYXJBdChsZW4gLSAyKSA/IDIgOiAnPScgPT09IGI2NC5jaGFyQXQobGVuIC0gMSkgPyAxIDogMFxuXG5cdFx0Ly8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5cdFx0YXJyID0gbmV3IEFycihiNjQubGVuZ3RoICogMyAvIDQgLSBwbGFjZUhvbGRlcnMpXG5cblx0XHQvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG5cdFx0bCA9IHBsYWNlSG9sZGVycyA+IDAgPyBiNjQubGVuZ3RoIC0gNCA6IGI2NC5sZW5ndGhcblxuXHRcdHZhciBMID0gMFxuXG5cdFx0ZnVuY3Rpb24gcHVzaCAodikge1xuXHRcdFx0YXJyW0wrK10gPSB2XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgaiA9IDA7IGkgPCBsOyBpICs9IDQsIGogKz0gMykge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxOCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCAxMikgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDIpKSA8PCA2KSB8IGRlY29kZShiNjQuY2hhckF0KGkgKyAzKSlcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMDAwKSA+PiAxNilcblx0XHRcdHB1c2goKHRtcCAmIDB4RkYwMCkgPj4gOClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9XG5cblx0XHRpZiAocGxhY2VIb2xkZXJzID09PSAyKSB7XG5cdFx0XHR0bXAgPSAoZGVjb2RlKGI2NC5jaGFyQXQoaSkpIDw8IDIpIHwgKGRlY29kZShiNjQuY2hhckF0KGkgKyAxKSkgPj4gNClcblx0XHRcdHB1c2godG1wICYgMHhGRilcblx0XHR9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuXHRcdFx0dG1wID0gKGRlY29kZShiNjQuY2hhckF0KGkpKSA8PCAxMCkgfCAoZGVjb2RlKGI2NC5jaGFyQXQoaSArIDEpKSA8PCA0KSB8IChkZWNvZGUoYjY0LmNoYXJBdChpICsgMikpID4+IDIpXG5cdFx0XHRwdXNoKCh0bXAgPj4gOCkgJiAweEZGKVxuXHRcdFx0cHVzaCh0bXAgJiAweEZGKVxuXHRcdH1cblxuXHRcdHJldHVybiBhcnJcblx0fVxuXG5cdGZ1bmN0aW9uIHVpbnQ4VG9CYXNlNjQgKHVpbnQ4KSB7XG5cdFx0dmFyIGksXG5cdFx0XHRleHRyYUJ5dGVzID0gdWludDgubGVuZ3RoICUgMywgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcblx0XHRcdG91dHB1dCA9IFwiXCIsXG5cdFx0XHR0ZW1wLCBsZW5ndGhcblxuXHRcdGZ1bmN0aW9uIGVuY29kZSAobnVtKSB7XG5cdFx0XHRyZXR1cm4gbG9va3VwLmNoYXJBdChudW0pXG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcblx0XHRcdHJldHVybiBlbmNvZGUobnVtID4+IDE4ICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDEyICYgMHgzRikgKyBlbmNvZGUobnVtID4+IDYgJiAweDNGKSArIGVuY29kZShudW0gJiAweDNGKVxuXHRcdH1cblxuXHRcdC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcblx0XHRmb3IgKGkgPSAwLCBsZW5ndGggPSB1aW50OC5sZW5ndGggLSBleHRyYUJ5dGVzOyBpIDwgbGVuZ3RoOyBpICs9IDMpIHtcblx0XHRcdHRlbXAgPSAodWludDhbaV0gPDwgMTYpICsgKHVpbnQ4W2kgKyAxXSA8PCA4KSArICh1aW50OFtpICsgMl0pXG5cdFx0XHRvdXRwdXQgKz0gdHJpcGxldFRvQmFzZTY0KHRlbXApXG5cdFx0fVxuXG5cdFx0Ly8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuXHRcdHN3aXRjaCAoZXh0cmFCeXRlcykge1xuXHRcdFx0Y2FzZSAxOlxuXHRcdFx0XHR0ZW1wID0gdWludDhbdWludDgubGVuZ3RoIC0gMV1cblx0XHRcdFx0b3V0cHV0ICs9IGVuY29kZSh0ZW1wID4+IDIpXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPDwgNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gJz09J1xuXHRcdFx0XHRicmVha1xuXHRcdFx0Y2FzZSAyOlxuXHRcdFx0XHR0ZW1wID0gKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDJdIDw8IDgpICsgKHVpbnQ4W3VpbnQ4Lmxlbmd0aCAtIDFdKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKHRlbXAgPj4gMTApXG5cdFx0XHRcdG91dHB1dCArPSBlbmNvZGUoKHRlbXAgPj4gNCkgJiAweDNGKVxuXHRcdFx0XHRvdXRwdXQgKz0gZW5jb2RlKCh0ZW1wIDw8IDIpICYgMHgzRilcblx0XHRcdFx0b3V0cHV0ICs9ICc9J1xuXHRcdFx0XHRicmVha1xuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXRcblx0fVxuXG5cdGV4cG9ydHMudG9CeXRlQXJyYXkgPSBiNjRUb0J5dGVBcnJheVxuXHRleHBvcnRzLmZyb21CeXRlQXJyYXkgPSB1aW50OFRvQmFzZTY0XG59KHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/ICh0aGlzLmJhc2U2NGpzID0ge30pIDogZXhwb3J0cykpXG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvLi4vLi4vbm9kZV9tb2R1bGVzL2d1bHAtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnVmZmVyL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvbGliL2I2NC5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2xpYlwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2J1ZmZlci9ub2RlX21vZHVsZXMvaWVlZTc1NFwiKSIsIihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsQnVmZmVyLF9fYXJndW1lbnQwLF9fYXJndW1lbnQxLF9fYXJndW1lbnQyLF9fYXJndW1lbnQzLF9fZmlsZW5hbWUsX19kaXJuYW1lKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnByb2Nlc3MubmV4dFRpY2sgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBjYW5TZXRJbW1lZGlhdGUgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5zZXRJbW1lZGlhdGU7XG4gICAgdmFyIGNhblBvc3QgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgICYmIHdpbmRvdy5wb3N0TWVzc2FnZSAmJiB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lclxuICAgIDtcblxuICAgIGlmIChjYW5TZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChmKSB7IHJldHVybiB3aW5kb3cuc2V0SW1tZWRpYXRlKGYpIH07XG4gICAgfVxuXG4gICAgaWYgKGNhblBvc3QpIHtcbiAgICAgICAgdmFyIHF1ZXVlID0gW107XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICB2YXIgc291cmNlID0gZXYuc291cmNlO1xuICAgICAgICAgICAgaWYgKChzb3VyY2UgPT09IHdpbmRvdyB8fCBzb3VyY2UgPT09IG51bGwpICYmIGV2LmRhdGEgPT09ICdwcm9jZXNzLXRpY2snKSB7XG4gICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZuID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRydWUpO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBuZXh0VGljayhmbikge1xuICAgICAgICAgICAgcXVldWUucHVzaChmbik7XG4gICAgICAgICAgICB3aW5kb3cucG9zdE1lc3NhZ2UoJ3Byb2Nlc3MtdGljaycsICcqJyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG5leHRUaWNrKGZuKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICAgIH07XG59KSgpO1xuXG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn1cblxuLy8gVE9ETyhzaHR5bG1hbilcbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qc1wiLFwiLy4uLy4uL25vZGVfbW9kdWxlcy9ndWxwLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3NcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBDdXN0b21BcHBwIGlzIGEgdXRpbGl0eSBjbGFzcyBmb3IgYXBwcyBlbXBvd2VyZWQgZm9yIEN1c3RvbUFwcHBcbi8vIEF1dGhvcjogWHVqaWUgU29uZ1xuLy8gQ29weXJpZ2h0OiBTSzggUFRZIExURFxuLy8gVjAuOS42XG4vLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cblwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIFNIIGlzIHRoZSBmdW5kYW1lbnRhbCBtb2R1bGUgZm9yIEN1c3RvbUFwcHAgTGlicmFyeS4gQWxsIHN1YmNsYXNzZXMgb3IgbWV0aG9kcyB3aWxsIHN0YXJ0IHdpdGggdGhpcyBmdW5jdGlvbi5cbiAqIEBtb2R1bGUgU0hcbiAqIEBhdXRob3IgWHVqaWUgU29uZ1xuICogQGNvcHlyaWdodCBTSzggUFRZIExURCAyMDE1XG4gKiBAc2VlIHtAbGluayBodHRwczovL2xlYW5jbG91ZC5jbi9kb2NzL2xlYW5lbmdpbmVfZ3VpZGUtbm9kZS5odG1sIExlYW5FbmdpbmUgUmVmZXJlbmNlfVxuICovXG52YXIgU0ggPSBmdW5jdGlvbigpIHt9XG5TSC5BUFBfSUQgPSBwcm9jZXNzLmVudi5MQ19BUFBfSUQgfHwgXCJhcHBpZGFwcGlkYXBwcGlkYXBwaWRcIjtcblNILkFQUF9LRVkgPSBwcm9jZXNzLmVudi5MQ19BUFBfS0VZIHx8IFwiYXBwa2V5YXBwa2V5YXBwa2V5YXBwa2V5XCI7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBBViBNb2R1bGUgPGJyPlxuICogQG1vZHVsZSBBVlxuICogQGV4YW1wbGUgdmFyIEFWID0gcmVxdWlyZSgnYXZvc2Nsb3VkLXNkaycpLkFWOyBcbiAqIC8vaW5zdGVhZCBvZiBcbiAqIC8vdmFyIEFWID0gcmVxdWlyZSgnbGVhbmVuZ2luZScpOyA8YnI+ICBcbiAqIC8vUmVhc29uIGJlaW5nIE5vZGUgbW9kdWxlICdsZWFuZW5naW5lJyB1c2VzIEV4cHJlc3MgNCBhbmQgYm9keS1wYXJzZXIsIHdoaWNoIGRvZXMgbm90IHdvcmsgd2VsbCB3aXRoIGJyb3dzZXJpZnkgPGJyPlxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9sZWFuY2xvdWQuY24vZG9jcy9sZWFuZW5naW5lX2d1aWRlLW5vZGUuaHRtbCBMZWFuRW5naW5lIFJlZmVyZW5jZX1cbiAqL1xudmFyIEFWID0gcmVxdWlyZShcImF2b3NjbG91ZC1zZGtcIikuQVY7XG5BVi5pbml0aWFsaXplKFNILkFQUF9JRCwgU0guQVBQX0tFWSk7XG5cbnJlcXVpcmUoJy4vc3JjL1NILmpzJykoU0gsIEFWKTtcbnJlcXVpcmUoJy4vc3JjL1NILkVycm9yLmpzJykoU0gsIEFWKTtcbnJlcXVpcmUoJy4vc3JjL1NILlVzZXIuanMnKShTSCk7XG5cbmdsb2JhbC5TSCA9IFNIO1xuZ2xvYmFsLkFWID0gU0guQVY7XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL2Zha2VfMzQ1MjgzOWEuanNcIixcIi9cIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXRpbGl0eSBFcnJvciBGdW5jdGlvbiwgZGVjbGFyZSBzeXN0ZW0gZXJyb3JzIGhlcmVcbiAqIEBmdW5jIFNILkVycm9yXG4gKiBAYXV0aG9yIFh1amllIFNvbmdcbiAqIEBjb3B5cmlnaHQgU0s4IFBUWSBMVEQgMjAxNVxuICogQHBhcmFtIHtJbnR9IEVycm9yIFRoZSBlcnJvciBjb2RlXG4gKiBAcmV0dXJuIHtTdHJpbmd9IEVycm9yIGRlc2NyaXB0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oU0gpIHtcbiAgICBTSC5FcnJvciA9IGZ1bmN0aW9uIChFcnJvcikge1xuICAgICAgICB2YXIgRXJyb3JDb2RlID0gXCIgRXJyb3I6IFwiICsgKFwiMDAwXCIgKyBFcnJvcikuc2xpY2UoLTQpO1xuICAgICAgICBzd2l0Y2ggKEVycm9yKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgLy8gQSB1c2VyIChTSFVzZXIpIG9iamVjdCBpcyByZXF1aXJlZCBiZWZvcmUgc2F2aW5nIGFuIFNIQWRkcmVzcyBvYmplY3RcbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZSA9IFwiVGhpcyBpcyBhIHNhbXBsZSBFcnJvciBtZXNzYWdlLlwiXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2UgKyBFcnJvckNvZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIC8vIEVycm9yIGNvZGUgbm90IGZvdW5kXG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2UgPSBcIkVycm9yIGNvdW5kIG5vdCBmb3VuZC5cIlxuICAgICAgICAgICAgICAgIHJldHVybiBtZXNzYWdlICsgRXJyb3JDb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxufSkuY2FsbCh0aGlzLHJlcXVpcmUoXCJvTWZwQW5cIiksdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9LHJlcXVpcmUoXCJidWZmZXJcIikuQnVmZmVyLGFyZ3VtZW50c1szXSxhcmd1bWVudHNbNF0sYXJndW1lbnRzWzVdLGFyZ3VtZW50c1s2XSxcIi9zcmMvU0guRXJyb3IuanNcIixcIi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2xhc3MgZm9yIGFsbCBVc2VyIG9iamVjdCB1c2VkIGluIFNoZWxmIHN5c3RlbVxuICogQGNsYXNzIFNILlVzZXJcbiAqIEBtZW1iZXJvZiEgPGdsb2JhbD5cbiAqIEBhdXRob3IgWHVqaWUgU29uZ1xuICogQGNvcHlyaWdodCBTSzggUFRZIExURCAyMDE1XG4gKiBAZXh0ZW5kcyB7QVYuVXNlcn1cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbGVhbmNsb3VkLmNuL2RvY3MvanNfZ3VpZGUuaHRtbCPnlKjmiLcgQVYuVXNlcn1cbiAqIEBwcm9wZXJ0eSB7U0guQWRkcmVzc30gYWRkcmVzcyBUaGUgcG9pbnRlciBvZiB0aGUgZGVmYXVsdCBhZGRyZXNzIG9mIHRoaXMgX1VzZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbYXV0aERhdGFdIEF1dGhEYXRhIG9mIHRoaXMgX1VzZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB1c2VybmFtZSBVc2VybmFtZSBvZiB0aGlzIF9Vc2VyXG4gKiBAcHJvcGVydHkge1N0cmluZ30gcGFzc3dvcmQgUGFzc3dvcmQgb2YgdGhpcyBfVXNlclxuICovXG52YXIgQ2xhc3NOYW1lID0gXCJfVXNlclwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoU0gsIFZlcmlmaWNhdGlvbikge1xuICAgIC8qKlxuICAgICAqIFJlY29tbWVuZGVkIHdheSB0b1xuICAgICAqIEluaXRpYWxpemUgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIENsYXNzXG4gICAgICogQGZ1bmMgU0guVXNlci5wcm90b3R5cGUubmV3XG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtkYXRhXSBBbiBqc29uIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZSBkYXRhXG4gICAgICogQGV4YW1wbGUgdmFyIHVzZXIgPSBTSC5Vc2VyLm5ldyh7XCJpZFwiOiBcImFiY2RcIn0pO1xuICAgICAqL1xuICAgIFNILlVzZXIgPSBTSC5BVi5PYmplY3QuZXh0ZW5kKENsYXNzTmFtZSwge1xuICAgICAgICAvL0luc3RhbmNlIHZhcmlhYmxlc1xuICAgICAgICAvL0luc3RhbmNlIGZ1bmN0aW9uc1xuICAgIH0sIHtcbiAgICAgICAgLy9TdGF0aWMgdmFyaWFibGVzXG4gICAgICAgIC8vU3RhdGljIGZ1bmN0aW9uc1xuICAgIH0pO1xuICAgIGlmIChWZXJpZmljYXRpb24gIT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIFNILkFWLkNsb3VkLmJlZm9yZVNhdmUoQ2xhc3NOYW1lLCBWZXJpZmljYXRpb24uYmVmb3JlU2F2ZShTSCkpO1xuICAgICAgICBTSC5BVi5DbG91ZC5hZnRlclNhdmUoQ2xhc3NOYW1lLCBWZXJpZmljYXRpb24uYWZ0ZXJTYXZlKFNIKSk7XG4gICAgICAgIFNILkFWLkNsb3VkLmFmdGVyVXBkYXRlKENsYXNzTmFtZSwgVmVyaWZpY2F0aW9uLmFmdGVyVXBkYXRlKFNIKSk7XG4gICAgICAgIFNILkFWLkNsb3VkLmJlZm9yZURlbGV0ZShDbGFzc05hbWUsIFZlcmlmaWNhdGlvbi5iZWZvcmVEZWxldGUoU0gpKTtcbiAgICAgICAgU0guQVYuQ2xvdWQuYWZ0ZXJEZWxldGUoQ2xhc3NOYW1lLCBWZXJpZmljYXRpb24uYWZ0ZXJEZWxldGUoU0gpKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNILlVzZXIucHJvdG90eXBlLCBcImF1dGhEYXRhXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJhdXRoRGF0YVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KFwiYXV0aERhdGFcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNILlVzZXIucHJvdG90eXBlLCBcImVtYWlsXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJlbWFpbFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KFwiZW1haWxcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNILlVzZXIucHJvdG90eXBlLCBcInBhc3N3b3JkXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJwYXNzd29yZFwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KFwicGFzc3dvcmRcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFNILlVzZXIucHJvdG90eXBlLCBcInVzZXJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoXCJ1c2VybmFtZVwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KFwidXNlcm5hbWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogaXNVc2VyIG1ldGhvZCBjaGVjayBpZiB0d28gdXNlciBvYmplY3RzIGFyZSBlcXVpdmFsZW50IHRvIGVhY2ggb3RoZXJcbiAgICAgKiBAcGFyYW0ge1NILlVzZXJ9IHVzZXIgVGFyZ2V0IHVzZXIgdG8gY29tcGFyZVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IGJvb2xlYW4gVHJ1ZSBpZiB0d28gdXNlcnMgYXJlIHRoZSBlcXVpdmFsZW50LCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBTSC5Vc2VyLnByb3RvdHlwZS5pc1VzZXIgPSBmdW5jdGlvbiAodXNlcikge1xuICAgICAgICBpZiAodXNlciAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmlkID09IHVzZXIuaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgdGhlIHVzZXIgaGFzIHZlcmlmaWVkIGhpcy9oZXIgZW1haWxcbiAgICAgKiBAZnVuYyBTSC5Vc2VyLnByb3RvdHlwZS5oYXNWZXJpZmllZEVtYWlsXG4gICAgICogQGV4YW1wbGUgaWYgKHVzZXIuaGFzVmVyaWZpZWRFbWFpbCgpKSB7XG4gICAgICAgICAqICAgICAgLy9Vc2VyIGhhZCB2ZXJpZmllZCBoaXMvaGVyIGVtYWlsXG4gICAgICAgICAqIH0gZWxzZSB7XG4gICAgICAgICAqICAgICAgLy9Vc2VyIGhhZCBub3QgdmVyaWZpZWQgaGlzL2hlciBlbWFpbFxuICAgICAgICAgKiB9XG4gICAgICovXG4gICAgU0guVXNlci5wcm90b3R5cGUuaGFzVmVyaWZpZWRFbWFpbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KFwiZW1haWxWZXJpZmllZFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9sbG93IHRvIGEgcGFydGljdWxhciB1c2VyXG4gICAgICogQGZ1bmMgU0guVXNlci5wcm90b3R5cGUuZm9sbG93XG4gICAgICogQHBhcmFtIHtTSC5Vc2VyfSB1c2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja10gQW4gb2JqZWN0IHRoYXQgaGFzIGFuIG9wdGlvbmFsIHN1Y2Nlc3MgZnVuY3Rpb24sIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRzIGFuZCB3aWxsIGJlIGNhbGxlZCBvbiBhIHN1Y2Nlc3NmdWwgcHVzaCwgYW5kIGFuIGVycm9yIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBBVi5FcnJvciBhbmQgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHB1c2ggZmFpbGVkLlxuICAgICAqIEBleGFtcGxlIHVzZXIuZm9sbG93KHVzZXIsIHtcbiAgICAgICAgICogICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24odXNlcikge1xuICAgICAgICAgKiAgICAgICAgICAgICAgLy9VcGRhdGVkIHVzZXJcbiAgICAgICAgICogICAgICAgICAgfSxcbiAgICAgICAgICogICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAvL1NILnNob3dFcnJvcihlcnJvcik7XG4gICAgICAgICAqICAgICAgICAgIH1cbiAgICAgICAgICogICAgICB9KTtcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBVbmZvbGxvdyB0byBhIHBhcnRpY3VsYXIgdXNlclxuICAgICAqIEBmdW5jIFNILlVzZXIucHJvdG90eXBlLnVuZm9sbG93XG4gICAgICogQHBhcmFtIHtTSC5Vc2VyfSB1c2VyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtjYWxsYmFja10gQW4gb2JqZWN0IHRoYXQgaGFzIGFuIG9wdGlvbmFsIHN1Y2Nlc3MgZnVuY3Rpb24sIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRzIGFuZCB3aWxsIGJlIGNhbGxlZCBvbiBhIHN1Y2Nlc3NmdWwgcHVzaCwgYW5kIGFuIGVycm9yIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBBVi5FcnJvciBhbmQgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHB1c2ggZmFpbGVkLlxuICAgICAqIEBleGFtcGxlIHVzZXIudW5mb2xsb3codXNlciwge1xuICAgICAgICAgKiAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbih1c2VyKSB7XG4gICAgICAgICAqICAgICAgICAgICAgICAvL1VwZGF0ZWQgdXNlclxuICAgICAgICAgKiAgICAgICAgICB9LFxuICAgICAgICAgKiAgICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICogICAgICAgICAgICAgIC8vU0guc2hvd0Vycm9yKGVycm9yKTtcbiAgICAgICAgICogICAgICAgICAgfVxuICAgICAgICAgKiAgICAgIH0pO1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZvbGxvd2VlIHF1ZXJ5IHRvIHF1ZXJ5IHRoZSB1c2VyJ3MgZm9sbG93ZWVzLlxuICAgICAqIEBmdW5jIFNILlVzZXIucHJvdG90eXBlLmZvbGxvd2VlUXVlcnkoKVxuICAgICAqIEBleGFtcGxlIHZhciBmb2xsb3dlZVF1ZXJ5ID0gdXNlci5mb2xsb3dlZVF1ZXJ5KCk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZm9sbG93ZXIgcXVlcnkgdG8gcXVlcnkgdGhlIHVzZXIncyBmb2xsb3dlcnMuXG4gICAgICogQGZ1bmMgU0guVXNlci5wcm90b3R5cGUuZm9sbG93ZXJRdWVyeSgpXG4gICAgICogQGV4YW1wbGUgdmFyIGZvbGxvd2VyUXVlcnkgPSB1c2VyLmZvbGxvd2VyUXVlcnkoKTtcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFNpZ25zIHVwIGEgbmV3IHVzZXIuIFlvdSBzaG91bGQgY2FsbCB0aGlzIGluc3RlYWQgb2Ygc2F2ZSBmb3JcbiAgICAgKiBuZXcgU0guVXNlcnMuIFRoaXMgd2lsbCBjcmVhdGUgYSBuZXcgU0guVXNlciBvbiB0aGUgc2VydmVyLCBhbmRcbiAgICAgKiBhbHNvIHBlcnNpc3QgdGhlIHNlc3Npb24gb24gZGlzayBzbyB0aGF0IHlvdSBjYW4gYWNjZXNzIHRoZSB1c2VyIHVzaW5nXG4gICAgICogPGNvZGU+Y3VycmVudDwvY29kZT4uXG4gICAgICpcbiAgICAgKiA8cD5BIHVzZXJuYW1lIGFuZCBwYXNzd29yZCBtdXN0IGJlIHNldCBiZWZvcmUgY2FsbGluZyBzaWduVXAuPC9wPlxuICAgICAqXG4gICAgICogPHA+Q2FsbHMgb3B0aW9ucy5zdWNjZXNzIG9yIG9wdGlvbnMuZXJyb3Igb24gY29tcGxldGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAZnVuYyBTSC5Vc2VyLnNpZ25VcFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBFeHRyYSBmaWVsZHMgdG8gc2V0IG9uIHRoZSBuZXcgdXNlciwgb3IgbnVsbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIHRoZSBzaWdudXBcbiAgICAgKiAgICAgZmluaXNoZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgIHZhciB1c2VyID0gU0guVXNlci5uZXcoKTtcbiAgICAgKiAgICAgIHVzZXIudXNlcm5hbWUgPSBcIjEzMzM0MjMwMUAxNjMuY29tXCI7XG4gICAgICogICAgICB1c2VyLnBhc3N3b3JkID0gXCJhYmNkZWZnXCI7XG4gICAgICogICAgICB1c2VyLnNpZ25VcChudWxsLCB7XG4gICAgICogICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgKiAgICAgICAgICAvLyDms6jlhozmiJDlip/vvIzlj6/ku6Xkvb/nlKjkuoYuXG4gICAgICogICAgICAgIH0sXG4gICAgICogICAgICAgIGVycm9yOiBmdW5jdGlvbih1c2VyLCBlcnJvcikge1xuICAgICAqICAgICAgICAgIC8vU0guc2hvd0Vycm9yKGVycm9yKTtcbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICAgfSk7XG4gICAgICovXG4gICAgLyoqXG4gICAgICogU2lnbnMgdXAgYSBuZXcgdXNlciB3aXRoIG1vYmlsZSBwaG9uZSBhbmQgc21zIGNvZGUuXG4gICAgICogWW91IHNob3VsZCBjYWxsIHRoaXMgaW5zdGVhZCBvZiBzYXZlIGZvclxuICAgICAqIG5ldyBBVi5Vc2Vycy4gVGhpcyB3aWxsIGNyZWF0ZSBhIG5ldyBBVi5Vc2VyIG9uIHRoZSBzZXJ2ZXIsIGFuZFxuICAgICAqIGFsc28gcGVyc2lzdCB0aGUgc2Vzc2lvbiBvbiBkaXNrIHNvIHRoYXQgeW91IGNhbiBhY2Nlc3MgdGhlIHVzZXIgdXNpbmdcbiAgICAgKiA8Y29kZT5jdXJyZW50PC9jb2RlPi5cbiAgICAgKlxuICAgICAqIDxwPkEgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIG11c3QgYmUgc2V0IGJlZm9yZSBjYWxsaW5nIHNpZ25VcC48L3A+XG4gICAgICpcbiAgICAgKiA8cD5DYWxscyBvcHRpb25zLnN1Y2Nlc3Mgb3Igb3B0aW9ucy5lcnJvciBvbiBjb21wbGV0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBmdW5jIFNILlVzZXIuc2lnblVwT3Jsb2dJbldpdGhNb2JpbGVQaG9uZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdHRycyBFeHRyYSBmaWVsZHMgdG8gc2V0IG9uIHRoZSBuZXcgdXNlciwgb3IgbnVsbC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aGVuIHRoZSBzaWdudXBcbiAgICAgKiAgICAgZmluaXNoZXMuXG4gICAgICogQHNlZSBAbGluayBodHRwczovL2xlYW5jbG91ZC5jbi9kb2NzL2pzX2d1aWRlLmh0bWwj5omL5py65Y+356CB5LiA6ZSu55m75b2VIEFWLkNsb3VkLnJlcXVlc3RTbXNDb2RlfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgICB2YXIgdXNlciA9IFNILlVzZXIubmV3KCk7XG4gICAgICogICAgICB1c2VyLnVzZXJuYW1lID0gXCIxMzMzNDIzMDFAMTYzLmNvbVwiO1xuICAgICAqICAgICAgdXNlci5wYXNzd29yZCA9IFwiYWJjZGVmZ1wiO1xuICAgICAqICAgICAgdXNlci5zaWduVXBPcmxvZ0luV2l0aE1vYmlsZVBob25lKHtcbiAgICAgKiAgICAgICAgbW9iaWxlUGhvbmVOdW1iZXI6ICcxODZ4eHh4eHh4eCcsXG4gICAgICogICAgICAgIHNtc0NvZGU6ICfmiYvmnLrmlLbliLDnmoQgNiDkvY3pqozor4HnoIHlrZfnrKbkuLInLFxuICAgICAqICAgICAgICB1c2VybmFtZTogXCJmZWVkYmFja0BzazguYXNpYVwiLFxuICAgICAqICAgICAgICBwYXNzd3JvZDogXCIxMjM0NTY3OFwiXG4gICAgICogICAgICAgIG90aGVyUHJvcGVydHk6IG90aGVyVmFsdWVcbiAgICAgKiAgICAgIH0sIHtcbiAgICAgKiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24odXNlcikge1xuICAgICAqICAgICAgICAgIC8vIOazqOWGjOaIkOWKn++8jOWPr+S7peS9v+eUqOS6hi5cbiAgICAgKiAgICAgICAgfSxcbiAgICAgKiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHVzZXIsIGVycm9yKSB7XG4gICAgICogICAgICAgICAgLy9TSC5zaG93RXJyb3IoZXJyb3IpO1xuICAgICAqICAgICAgICB9XG4gICAgICogICAgICB9KTtcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIExvZ3MgaW4gYSB1c2VyIHdpdGggYSBtb2JpbGUgcGhvbmUgbnVtYmVyIGFuZCBwYXNzd29yZC4gT24gc3VjY2VzcywgdGhpc1xuICAgICAqIHNhdmVzIHRoZSBzZXNzaW9uIHRvIGRpc2ssIHNvIHlvdSBjYW4gcmV0cmlldmUgdGhlIGN1cnJlbnRseSBsb2dnZWQgaW5cbiAgICAgKiB1c2VyIHVzaW5nIDxjb2RlPmN1cnJlbnQ8L2NvZGU+LlxuICAgICAqXG4gICAgICogPHA+Q2FsbHMgb3B0aW9ucy5zdWNjZXNzIG9yIG9wdGlvbnMuZXJyb3Igb24gY29tcGxldGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAZnVuYyBTSC5Vc2VyLmxvZ0luV2l0aE1vYmlsZVBob25lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vYmlsZVBob25lIFRoZSB1c2VyJ3MgbW9iaWxlUGhvbmVOdW1iZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGxvZyBpbiB3aXRoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIHVzZXIgd2hlblxuICAgICAqICAgICB0aGUgbG9naW4gY29tcGxldGVzLlxuICAgICAqIEBzZWUgQGxpbmsgaHR0cHM6Ly9sZWFuY2xvdWQuY24vZG9jcy9qc19ndWlkZS5odG1sI+aJi+acuuWPt+eggeWSjOefreS/oeeZu+W9lSBBVi5Vc2VyLmxvZ0luV2l0aE1vYmlsZVBob25lfVxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgICBTSC5Vc2VyLmxvZ0luV2l0aE1vYmlsZVBob25lKCcxODZ4eHh4eHh4eCcsIHBhc3N3b3JkLCB7XG4gICAgICogICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHVzZXIpIHtcbiAgICAgKiAgICAgICAgICAvLyDms6jlhozmiJDlip/vvIzlj6/ku6Xkvb/nlKjkuoYuXG4gICAgICogICAgICAgIH0sXG4gICAgICogICAgICAgIGVycm9yOiBmdW5jdGlvbih1c2VyLCBlcnJvcikge1xuICAgICAqICAgICAgICAgIC8vU0guc2hvd0Vycm9yKGVycm9yKTtcbiAgICAgKiAgICAgICAgfVxuICAgICAqICAgICAgfSk7XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBMb2dzIG91dCB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIHNlc3Npb24uIFRoaXMgd2lsbCByZW1vdmUgdGhlXG4gICAgICogc2Vzc2lvbiBmcm9tIGRpc2ssIGxvZyBvdXQgb2YgbGlua2VkIHNlcnZpY2VzLCBhbmQgZnV0dXJlIGNhbGxzIHRvXG4gICAgICogPGNvZGU+Y3VycmVudDwvY29kZT4gd2lsbCByZXR1cm4gPGNvZGU+bnVsbDwvY29kZT4uXG4gICAgICogQGZ1bmMgU0guVXNlci5sb2dPdXRcbiAgICAgKiBAZXhhbXBsZSBTSC5Vc2VyLmxvZ091dCgpO1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYSBwYXNzd29yZCByZXNldCBlbWFpbCB0byBiZSBzZW50IHRvIHRoZSBzcGVjaWZpZWQgZW1haWwgYWRkcmVzc1xuICAgICAqIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciBhY2NvdW50LiBUaGlzIGVtYWlsIGFsbG93cyB0aGUgdXNlciB0byBzZWN1cmVseVxuICAgICAqIHJlc2V0IHRoZWlyIHBhc3N3b3JkIG9uIHRoZSBBViBzaXRlLlxuICAgICAqXG4gICAgICogPHA+Q2FsbHMgb3B0aW9ucy5zdWNjZXNzIG9yIG9wdGlvbnMuZXJyb3Igb24gY29tcGxldGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAZnVuYyBTSC5Vc2VyLnJlcXVlc3RQYXNzd29yZFJlc2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciB0aGF0XG4gICAgICogICAgIGZvcmdvdCB0aGVpciBwYXNzd29yZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgICBTSC5Vc2VyLnJlcXVlc3RQYXNzd29yZFJlc2V0KFwiZW1haWxAZXhhbXBsZS5jb21cIiwge1xuICAgICAqICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAvLyBQYXNzd29yZCByZXNldCByZXF1ZXN0IHdhcyBzZW50IHN1Y2Nlc3NmdWxseVxuICAgICAqICAgICAgICB9LFxuICAgICAqICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgKiAgICAgICAgICAvL1NILnNob3dFcnJvcihlcnJvcik7XG4gICAgICogICAgICB9KTtcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGEgdmVyaWZ5IGVtYWlsIHRvIGJlIHNlbnQgdG8gdGhlIHNwZWNpZmllZCBlbWFpbCBhZGRyZXNzXG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSB1c2VyIGFjY291bnQuIFRoaXMgZW1haWwgYWxsb3dzIHRoZSB1c2VyIHRvIHNlY3VyZWx5XG4gICAgICogdmVyaWZ5IHRoZWlyIGVtYWlsIGFkZHJlc3Mgb24gdGhlIEFWIHNpdGUuXG4gICAgICpcbiAgICAgKiA8cD5DYWxscyBvcHRpb25zLnN1Y2Nlc3Mgb3Igb3B0aW9ucy5lcnJvciBvbiBjb21wbGV0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBmdW5jIFNILlVzZXIucmVxdWVzdEVtYWlsVmVyaWZ5XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGVtYWlsIFRoZSBlbWFpbCBhZGRyZXNzIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciB0aGF0XG4gICAgICogICAgIGRvZXNuJ3QgdmVyaWZ5IHRoZWlyIGVtYWlsIGFkZHJlc3MuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAgU0guVXNlci5yZXF1ZXN0RW1haWxWZXJpZnkoXCJlbWFpbEBleGFtcGxlLmNvbVwiLCB7XG4gICAgICogICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgIC8vIFZlcmlmaWNhdGlvbiBlbWFpbCB3YXMgc2VudCBzdWNjZXNzZnVsbHlcbiAgICAgKiAgICAgICAgfSxcbiAgICAgKiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICogICAgICAgICAgLy9TSC5zaG93RXJyb3IoZXJyb3IpO1xuICAgICAqICAgICAgfSk7XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0cyBhIHZlcmlmeSBzbXMgY29kZSB0byBiZSBzZW50IHRvIHRoZSBzcGVjaWZpZWQgbW9iaWxlIHBob25lXG4gICAgICogbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciBhY2NvdW50LiBUaGlzIHNtcyBjb2RlIGFsbG93cyB0aGUgdXNlciB0b1xuICAgICAqIHZlcmlmeSB0aGVpciBtb2JpbGUgcGhvbmUgbnVtYmVyIGJ5IGNhbGxpbmcgQVYuVXNlci52ZXJpZnlNb2JpbGVQaG9uZVxuICAgICAqXG4gICAgICogPHA+Q2FsbHMgb3B0aW9ucy5zdWNjZXNzIG9yIG9wdGlvbnMuZXJyb3Igb24gY29tcGxldGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAZnVuYyBTSC5Vc2VyLnJlcXVlc3RNb2JpbGVQaG9uZVZlcmlmeVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtb2JpbGVQaG9uZSBUaGUgbW9iaWxlIHBob25lIG51bWJlciAgYXNzb2NpYXRlZCB3aXRoIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgdXNlciB0aGF0IGRvZXNuJ3QgdmVyaWZ5IHRoZWlyIG1vYmlsZSBwaG9uZSBudW1iZXIuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAZXhtYXBsZVxuICAgICAqICAgICAgQVYuVXNlci5yZXF1ZXN0TW9iaWxlUGhvbmVWZXJpZnkoJzE4Nnh4eHh4eHh4JykudGhlbihmdW5jdGlvbigpe1xuICAgICAqICAgICAgICAvL+WPkemAgeaIkOWKn1xuICAgICAqICAgICAgfSwgZnVuY3Rpb24oZXJyKXtcbiAgICAgKiAgICAgICAgIC8vU0guc2hvd0Vycm9yKGVycm9yKTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogUmVxdWVzdHMgYSByZXNldCBwYXNzd29yZCBzbXMgY29kZSB0byBiZSBzZW50IHRvIHRoZSBzcGVjaWZpZWQgbW9iaWxlIHBob25lXG4gICAgICogbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgdXNlciBhY2NvdW50LiBUaGlzIHNtcyBjb2RlIGFsbG93cyB0aGUgdXNlciB0b1xuICAgICAqIHJlc2V0IHRoZWlyIGFjY291bnQncyBwYXNzd29yZCBieSBjYWxsaW5nIEFWLlVzZXIucmVzZXRQYXNzd29yZEJ5U21zQ29kZVxuICAgICAqXG4gICAgICogPHA+Q2FsbHMgb3B0aW9ucy5zdWNjZXNzIG9yIG9wdGlvbnMuZXJyb3Igb24gY29tcGxldGlvbi48L3A+XG4gICAgICpcbiAgICAgKiBAZnVuYyBTSC5Vc2VyLnJlcXVlc3RQYXNzd29yZFJlc2V0QnlTbXNDb2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vYmlsZVBob25lIFRoZSBtb2JpbGUgcGhvbmUgbnVtYmVyICBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogICAgICAgICAgICAgICAgICB1c2VyIHRoYXQgZG9lc24ndCB2ZXJpZnkgdGhlaXIgbW9iaWxlIHBob25lIG51bWJlci5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgICBTSC5Vc2VyLnJlcXVlc3RQYXNzd29yZFJlc2V0QnlTbXNDb2RlKFwiMTg2eHh4eHh4eHhcIiwge1xuICAgICAqICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAvLyBQYXNzd29yZCByZXNldCByZXF1ZXN0IHdhcyBzZW50IHN1Y2Nlc3NmdWxseVxuICAgICAqICAgICAgICB9LFxuICAgICAqICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgKiAgICAgICAgICAvL1NILnNob3dFcnJvcihlcnJvcik7XG4gICAgICogICAgICB9KTtcbiAgICAgKi9cbiAgICAvKipcbiAgICAgKiBNYWtlcyBhIGNhbGwgdG8gcmVzZXQgdXNlcidzIGFjY291bnQgcGFzc3dvcmQgYnkgc21zIGNvZGUgYW5kIG5ldyBwYXNzd29yZC5cbiAgICAgKiBUaGUgc21zIGNvZGUgaXMgc2VudCBieSBBVi5Vc2VyLnJlcXVlc3RQYXNzd29yZFJlc2V0QnlTbXNDb2RlLlxuICAgICAqIEBmdW5jIFNILlVzZXIucmVzZXRQYXNzd29yZEJ5U21zQ29kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb2RlIFRoZSBzbXMgY29kZSBzZW50IGJ5IEFWLlVzZXIuQ2xvdWQucmVxdWVzdFNtc0NvZGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFzc3dvcmQgVGhlIG5ldyBwYXNzd29yZC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgd2lsbCBiZSByZXNvbHZlZCB3aXRoIHRoZSByZXN1bHRcbiAgICAgKiBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgIFNILlVzZXIucmVxdWVzdFBhc3N3b3JkUmVzZXRCeVNtc0NvZGUoXCIxMjM0NTZcIiwgXCJuZXdQYXNzd29yZFwiLCB7XG4gICAgICogICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgIC8vIFBhc3N3b3JkIHJlc2V0IHJlcXVlc3Qgd2FzIHNlbnQgc3VjY2Vzc2Z1bGx5XG4gICAgICogICAgICAgIH0sXG4gICAgICogICAgICAgIGVycm9yOiBmdW5jdGlvbihlcnJvcikge1xuICAgICAqICAgICAgICAgIC8vU0guc2hvd0Vycm9yKGVycm9yKTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIE1ha2VzIGEgY2FsbCB0byB2ZXJpZnkgc21zIGNvZGUgdGhhdCBzZW50IGJ5IEFWLlVzZXIuQ2xvdWQucmVxdWVzdFNtc0NvZGVcbiAgICAgKiBJZiB2ZXJpZnkgc3VjY2Vzc2Z1bGx5LHRoZSB1c2VyIG1vYmlsZVBob25lVmVyaWZpZWQgYXR0cmlidXRlIHdpbGwgYmUgdHJ1ZS5cbiAgICAgKiBAZnVuYyBTSC5Vc2VyLnZlcmlmeU1vYmlsZVBob25lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNvZGUgVGhlIHNtcyBjb2RlIHNlbnQgYnkgQVYuVXNlci5DbG91ZC5yZXF1ZXN0U21zQ29kZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggdGhlIHJlc3VsdFxuICAgICAqIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAgU0guVXNlci52ZXJpZnlNb2JpbGVQaG9uZShcIjEyMzQ1NlwiLCB7XG4gICAgICogICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCkge1xuICAgICAqICAgICAgICAgIC8vIFBhc3N3b3JkIHJlc2V0IHJlcXVlc3Qgd2FzIHNlbnQgc3VjY2Vzc2Z1bGx5XG4gICAgICogICAgICAgIH0sXG4gICAgICogICAgICAgIGVycm9yOiBmdW5jdGlvbihlcnJvcikge1xuICAgICAqICAgICAgICAgIC8vU0guc2hvd0Vycm9yKGVycm9yKTtcbiAgICAgKiAgICAgIH0pO1xuICAgICAqL1xuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGEgbG9nSW4gc21zIGNvZGUgdG8gYmUgc2VudCB0byB0aGUgc3BlY2lmaWVkIG1vYmlsZSBwaG9uZVxuICAgICAqIG51bWJlciBhc3NvY2lhdGVkIHdpdGggdGhlIHVzZXIgYWNjb3VudC4gVGhpcyBzbXMgY29kZSBhbGxvd3MgdGhlIHVzZXIgdG9cbiAgICAgKiBsb2dpbiBieSBBVi5Vc2VyLmxvZ0luV2l0aE1vYmlsZVBob25lU21zQ29kZSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIDxwPkNhbGxzIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIG9uIGNvbXBsZXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQGZ1bmMgU0guVXNlci5yZXF1ZXN0TG9naW5TbXNDb2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vYmlsZVBob25lIFRoZSBtb2JpbGUgcGhvbmUgbnVtYmVyICBhc3NvY2lhdGVkIHdpdGggdGhlXG4gICAgICogICAgICAgICAgIHVzZXIgdGhhdCB3YW50IHRvIGxvZ2luIGJ5IEFWLlVzZXIubG9nSW5XaXRoTW9iaWxlUGhvbmVTbXNDb2RlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQSBCYWNrYm9uZS1zdHlsZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAgU0guVXNlci5yZXF1ZXN0TG9naW5TbXNDb2RlKCcxODZ4eHh4eHh4eCcsIHtcbiAgICAgKiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oKSB7XG4gICAgICogICAgICAgICAgLy8gUGFzc3dvcmQgcmVzZXQgcmVxdWVzdCB3YXMgc2VudCBzdWNjZXNzZnVsbHlcbiAgICAgKiAgICAgICAgfSxcbiAgICAgKiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICogICAgICAgICAgLy9TSC5zaG93RXJyb3IoZXJyb3IpO1xuICAgICAqICAgICAgfSk7XG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGluIGEgdXNlciB3aXRoIGEgbW9iaWxlIHBob25lIG51bWJlciBhbmQgc21zIGNvZGUgc2VudCBieVxuICAgICAqIEFWLlVzZXIucmVxdWVzdExvZ2luU21zQ29kZS5PbiBzdWNjZXNzLCB0aGlzXG4gICAgICogc2F2ZXMgdGhlIHNlc3Npb24gdG8gZGlzaywgc28geW91IGNhbiByZXRyaWV2ZSB0aGUgY3VycmVudGx5IGxvZ2dlZCBpblxuICAgICAqIHVzZXIgdXNpbmcgPGNvZGU+Y3VycmVudDwvY29kZT4uXG4gICAgICpcbiAgICAgKiA8cD5DYWxscyBvcHRpb25zLnN1Y2Nlc3Mgb3Igb3B0aW9ucy5lcnJvciBvbiBjb21wbGV0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBmdW5jIFNILlVzZXIubG9nSW5XaXRoTW9iaWxlUGhvbmVTbXNDb2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1vYmlsZVBob25lIFRoZSB1c2VyJ3MgbW9iaWxlUGhvbmVOdW1iZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc21zQ29kZSBUaGUgc21zIGNvZGUgc2VudCBieSBBVi5Vc2VyLnJlcXVlc3RMb2dpblNtc0NvZGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge0FWLlByb21pc2V9IEEgcHJvbWlzZSB0aGF0IGlzIGZ1bGZpbGxlZCB3aXRoIHRoZSB1c2VyIHdoZW5cbiAgICAgKiAgICAgdGhlIGxvZ2luIGNvbXBsZXRlcy5cbiAgICAgKiBAZnVuYyBTSC5Vc2VyI2xvZ0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgIFNILlVzZXIubG9nSW5XaXRoTW9iaWxlUGhvbmVTbXNDb2RlKFwiMTg2eHh4eHh4eHhcIiwgXCIxMjM0NTZcIiwge1xuICAgICAqICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbigpIHtcbiAgICAgKiAgICAgICAgICAvLyBQYXNzd29yZCByZXNldCByZXF1ZXN0IHdhcyBzZW50IHN1Y2Nlc3NmdWxseVxuICAgICAqICAgICAgICB9LFxuICAgICAqICAgICAgICBlcnJvcjogZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgKiAgICAgICAgICAvL1NILnNob3dFcnJvcihlcnJvcik7XG4gICAgICogICAgICB9KTtcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIExvZ3MgaW4gYSBBVi5Vc2VyLiBPbiBzdWNjZXNzLCB0aGlzIHNhdmVzIHRoZSBzZXNzaW9uIHRvIGxvY2FsU3RvcmFnZSxcbiAgICAgKiBzbyB5b3UgY2FuIHJldHJpZXZlIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIgdXNpbmdcbiAgICAgKiA8Y29kZT5jdXJyZW50PC9jb2RlPi5cbiAgICAgKlxuICAgICAqIDxwPkEgdXNlcm5hbWUgYW5kIHBhc3N3b3JkIG11c3QgYmUgc2V0IGJlZm9yZSBjYWxsaW5nIGxvZ0luLjwvcD5cbiAgICAgKlxuICAgICAqIDxwPkNhbGxzIG9wdGlvbnMuc3VjY2VzcyBvciBvcHRpb25zLmVycm9yIG9uIGNvbXBsZXRpb24uPC9wPlxuICAgICAqXG4gICAgICogQGZ1bmMgU0guVXNlci5wcm90b3R5cGUubG9nSW5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBBIEJhY2tib25lLXN0eWxlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBmdW5jIFNILlVzZXIubG9nSW5cbiAgICAgKiBAcmV0dXJuIHtBVi5Qcm9taXNlfSBBIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2l0aCB0aGUgdXNlciB3aGVuXG4gICAgICogICAgIHRoZSBsb2dpbiBpcyBjb21wbGV0ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqICAgICAgQVYuVXNlci5sb2dJbihcIm15VXNlcm5hbWVcIiwgXCJteVBhc3N3b3JkXCIsIHtcbiAgICAgKiAgICAgICAgc3VjY2VzczogZnVuY3Rpb24odXNlcikge1xuICAgICAqICAgICAgICAgIC8vIOaIkOWKn+S6hu+8jOeOsOWcqOWPr+S7peWBmuWFtuS7luS6i+aDheS6hi5cbiAgICAgKiAgICAgICAgfSxcbiAgICAgKiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHVzZXIsIGVycm9yKSB7XG4gICAgICogICAgICAgICAgLy9TSC5zaG93RXJyb3IoZXJyb3IpO1xuICAgICAqICAgICAgICB9XG4gICAgICogICAgICB9KTtcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB1c2VyJ3MgbmV3IHBhc3N3b3JkIHNhZmVseSBiYXNlZCBvbiBvbGQgcGFzc3dvcmQuXG4gICAgICogQGZ1bmMgU0guVXNlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2xkUGFzc3dvcmQsIHRoZSBvbGQgcGFzc3dvcmQuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5ld1Bhc3N3b3JkLCB0aGUgbmV3IHBhc3N3b3JkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBBbiBvcHRpb25hbCBCYWNrYm9uZS1saWtlIG9wdGlvbnMgb2JqZWN0IHdpdGhcbiAgICAgKiAgICAgc3VjY2VzcyBhbmQgZXJyb3IgY2FsbGJhY2tzIHRoYXQgd2lsbCBiZSBpbnZva2VkIG9uY2UgdGhlIGl0ZXJhdGlvblxuICAgICAqICAgICBoYXMgZmluaXNoZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiAgICAgIHZhciB1c2VyID0gQVYuVXNlci5jdXJyZW50KCk7XG4gICAgICogICAgICB1c2VyLnVwZGF0ZVBhc3N3b3JkKCdjdXJyZW50UGFzc3dvcmQnLCAnbmV3UGFzc3dvcmQnLCB7XG4gICAgICogICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCl7XG4gICAgICogICAgICAgICAgLy/mm7TmlrDmiJDlip9cbiAgICAgKiAgICAgICAgfSxcbiAgICAgKiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHVzZXIsIGVycil7XG4gICAgICogICAgICAgICAgLy9TSC5zaG93RXJyb3IoZXJyb3IpO1xuICAgICAqICAgICAgICB9XG4gICAgICogICAgICB9KTtcbiAgICAgKi9cblxuICAgIC8qKlxuICAgICAqIExvZ3MgaW4gYSB1c2VyIHdpdGggYSBzZXNzaW9uIHRva2VuLiBPbiBzdWNjZXNzLCB0aGlzIHNhdmVzIHRoZSBzZXNzaW9uXG4gICAgICogdG8gZGlzaywgc28geW91IGNhbiByZXRyaWV2ZSB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIHVzaW5nXG4gICAgICogPGNvZGU+Y3VycmVudDwvY29kZT4uXG4gICAgICpcbiAgICAgKiA8cD5DYWxscyBvcHRpb25zLnN1Y2Nlc3Mgb3Igb3B0aW9ucy5lcnJvciBvbiBjb21wbGV0aW9uLjwvcD5cbiAgICAgKlxuICAgICAqIEBmdW5jIFNILlVzZXIuYmVjb21lXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHNlc3Npb25Ub2tlbiBUaGUgc2Vzc2lvblRva2VuIHRvIGxvZyBpbiB3aXRoLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIEEgQmFja2JvbmUtc3R5bGUgb3B0aW9ucyBvYmplY3QuXG4gICAgICogQHJldHVybiB7QVYuUHJvbWlzZX0gQSBwcm9taXNlIHRoYXQgaXMgZnVsZmlsbGVkIHdpdGggdGhlIHVzZXIgd2hlblxuICAgICAqICAgICB0aGUgbG9naW4gY29tcGxldGVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICogICAgICBTSC5Vc2VyLmJlY29tZShcInNlc3Npb25Ub2tlblwiLCB7XG4gICAgICogICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKCl7XG4gICAgICogICAgICAgICAgLy/mm7TmlrDmiJDlip9cbiAgICAgKiAgICAgICAgfSxcbiAgICAgKiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKHVzZXIsIGVycil7XG4gICAgICogICAgICAgICAgLy9TSC5zaG93RXJyb3IoZXJyb3IpO1xuICAgICAqICAgICAgICB9XG4gICAgICogICAgICB9KTtcbiAgICAgKi9cbn1cbn0pLmNhbGwodGhpcyxyZXF1aXJlKFwib01mcEFuXCIpLHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSxyZXF1aXJlKFwiYnVmZmVyXCIpLkJ1ZmZlcixhcmd1bWVudHNbM10sYXJndW1lbnRzWzRdLGFyZ3VtZW50c1s1XSxhcmd1bWVudHNbNl0sXCIvc3JjL1NILlVzZXIuanNcIixcIi9zcmNcIikiLCIoZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsLEJ1ZmZlcixfX2FyZ3VtZW50MCxfX2FyZ3VtZW50MSxfX2FyZ3VtZW50MixfX2FyZ3VtZW50MyxfX2ZpbGVuYW1lLF9fZGlybmFtZSl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU0ggaXMgdGhlIGZ1bmRhbWVudGFsIGZ1bmN0aW9uIGZvciBDdXN0b21fQXBwIExpYnJhcnkuIEFsbCBzdWJjbGFzc2VzIG9yIG1ldGhvZHMgd2lsbCBzdGFydCB3aXRoIHRoaXMgZnVuY3Rpb24uXG4gKiBAY2xhc3MgU0hcbiAqIEBhdXRob3IgWHVqaWUgU29uZ1xuICogQGNvcHlyaWdodCAoYykgU0s4IFBUWSBMVEQgMjAxNS4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vbGVhbmNsb3VkLmNuL2RvY3MvbGVhbmVuZ2luZV9ndWlkZS1ub2RlLmh0bWwgTGVhbkVuZ2luZSBSZWZlcmVuY2V9XG4gKiBAdG9kbyBSZXNvbHZlIGRlcGxveSBlcnJvciAnVW5hdXRob3JpemVkJ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKFNILCBBVikge1xuICBTSC5BViA9IEFWO1xuICAvKipcbiAgICogSW5pdGlhdGlvbiBtZXRob2QgZm9yIEN1c3RvbV9BcHAgQXBwXG4gICAqIEBmdW5jIFNILmluaXRpYWxpemVcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNob3BJZCBUaGUgaWQgb2YgdGhlIFNob3AuIFVzdWFsbHkgbGluayB3b3VsZCBsb29rIGxpa2UgaHR0cDovL3Nob3BJZC5zaGVsZi5pc1xuICAgKiBAcGFyYW0ge09iamVjdH0gY2FsbGJhY2sgQW4gb2JqZWN0IHRoYXQgaGFzIGFuIG9wdGlvbmFsIHN1Y2Nlc3MgZnVuY3Rpb24sIHRoYXQgdGFrZXMgbm8gYXJndW1lbnRzIGFuZCB3aWxsIGJlIGNhbGxlZCBvbiBhIHN1Y2Nlc3NmdWwgcHVzaCwgYW5kIGFuIGVycm9yIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYSBBVi5FcnJvciBhbmQgd2lsbCBiZSBjYWxsZWQgaWYgdGhlIHB1c2ggZmFpbGVkLlxuICAgKiBAZXhhbXBsZSBTSC5pbml0aWFsaXplKFwiYWJjZFNob3BJZFwiLCB7XG4gICAqICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHNob3ApIHtcbiAgICogICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5jdXJyZW50U2hvcCA9IFNILmN1cnJlbnRTaG9wO1xuICAgKiAgICAgICAgICAgICAgLy8kcm9vdFNjb3BlLmN1cnJlbnRTZWxsZXIgPSBTSC5jdXJyZW50U2hvcC5vd25lcjtcbiAgICogICAgICAgICAgICAgIC8vJHJvb3RTY29wZS5jdXJyZW50VXNlciA9IFNILmN1cnJlbnRVc2VyO1xuICAgKiAgICAgICAgICAgICAgLy8kc2NvcGUucmVsb2FkU2hvcChzaG9wKTtcbiAgICogICAgICAgICAgfSxcbiAgICogICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAqICAgICAgICAgICAgICBTSC5zaG93RXJyb3IoZXJyb3IpO1xuICAgKiAgICAgICAgICB9XG4gICAqIH0pO1xuICAgKi9cbiAgU0guaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uKHNob3BJZCwgY2FsbGJhY2spIHtcbiAgICAvL0luaXRpbGl6YXRpb24gY29kZSBmb3IgQ3VzdG9tX0FwcFxuICB9O1xuICAgIC8qKlxuICAgICAqIFNob3cgYW4gcHJvbW90ZSB0byB1c2VyLCBpdCdzIGN1cnJlbnRseSBhbiBhbGVydC5cbiAgICAgKiBAZnVuYyBTSC5Qcm9tb3RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgeW91IHdpc2ggdG8gcHJvbW90ZVxuICAgICAqIEBleGFtcGxlIFNILnByb21vdGUoXCJDdXN0b21fQXBwIGlzIGF3ZXNvbWUhXCIpO1xuICAgICAqL1xuICBTSC5wcm9tb3RlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgICAgU0gubG9nKG1lc3NhZ2UpO1xuICAgICAgd2luZG93LmFsZXJ0KG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2cgdGhlIGVycm9yIG1lc3NhZ2UgaW4gY29uc29sZSwgYW5kICdwcm9tb3RlJyBpdCB0byB1c2VyXG4gICAgICogQGZ1bmMgU0guc2hvd0Vycm9yXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgSFRUUCBFcnJvclxuICAgICAqIEBleGFtcGxlIFNILnNob3dFcnJvcihlcnJvcik7XG4gICAgICovXG4gIFNILnNob3dFcnJvciA9IGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICBTSC5sb2coZXJyb3IubWVzc2FnZSk7XG4gICAgICB3aW5kb3cuYWxlcnQoZXJyb3IubWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGN1c3RvbSBTSC5sb2cgZnVuY3Rpb24uXG4gICAgICogQGZ1bmMgU0gubG9nXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgeW91IHdpc2ggdG8gbG9nXG4gICAgICogQGV4YW1wbGUgU0gubG9nKG1lc3NhZ2UpO1xuICAgICAqL1xuICBTSC5sb2cgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcbiAgICB9XG4gIFNILm9wZW5VUkwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICB3aW5kb3cub3Blbih1cmwsICdfYmxhbmsnLCAncmVzaXphYmxlPXllcycpO1xuICB9XG59XG59KS5jYWxsKHRoaXMscmVxdWlyZShcIm9NZnBBblwiKSx0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30scmVxdWlyZShcImJ1ZmZlclwiKS5CdWZmZXIsYXJndW1lbnRzWzNdLGFyZ3VtZW50c1s0XSxhcmd1bWVudHNbNV0sYXJndW1lbnRzWzZdLFwiL3NyYy9TSC5qc1wiLFwiL3NyY1wiKSJdfQ==
